<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录点滴成长</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianwl.com/"/>
  <updated>2018-09-18T13:47:09.172Z</updated>
  <id>http://jianwl.com/</id>
  
  <author>
    <name>流云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReentrantLock源码学习</title>
    <link href="http://jianwl.com/2018/09/17/ReentrantLock%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/09/17/ReentrantLock源码学习/</id>
    <published>2018-09-17T14:22:28.000Z</published>
    <updated>2018-09-18T13:47:09.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>ReentrantLock是一个重入锁，提供了公平锁和非公平锁的选择，通过构造方法接受参数fair，为true为公平锁，反之为非公平锁。默认为非公平锁。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在进行源码阅读之前，我有几个问题，带着问题，我们来进一步学习源码，会更加有目的性。</p><blockquote><p>1 如何实现加锁的，lock()方法都做了些什么？</p><p>2 是如何实现公平锁的，如何让等待更久的线程，可以优先获取锁呢？好奇</p><p>3 lock()、tryLock()、lockInterruptibly()这三个方法有什么区别呢？</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-9-17/47777084.jpg" alt=""></p><p>ReentrantLock实现了Lock接口，Sync抽象类继承了AQS，公平锁类和非公平锁类继承了Sync抽象类。</p><h3 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h3><p>从使用的角度来分析，每一步它都是怎么实现的，抽丝剥茧那么整个流程通了。而后再重点分析核心类。即「构造方法」-&gt; 「lock」-&gt; 「unlock」-&gt; 「Sync」</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private final Sync sync;</span><br><span class="line">// 默认为非公平锁</span><br><span class="line">    public ReentrantLock() &#123;</span><br><span class="line">        sync = new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// fair == true,为公平锁</span><br><span class="line">    public ReentrantLock(boolean fair) &#123;</span><br><span class="line">        sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### lock()</span><br><span class="line"></span><br><span class="line">若初始化为非公平锁，调用lock方法，其实是调用了NonfairSync的lock方法。</span><br><span class="line"></span><br><span class="line">&gt; ReetrantLock&amp;lock</span><br></pre></td></tr></table></figure><pre><code>public void lock() {    sync.lock();}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">compareAndSetState为CAS操作，即：如果同步状态state的值为0，就更新为1，此操作是原子性的。如果更新成功，则设置当前线程为同步锁的独占线程。反之，则执行#acquire(1)操作。</span><br><span class="line"></span><br><span class="line">&gt; NonfairSync&amp;lock</span><br></pre></td></tr></table></figure><pre><code>final void lock() {    if (compareAndSetState(0, 1))        setExclusiveOwnerThread(Thread.currentThread());    else        acquire(1);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NonfairSync#tryAcquire，重载了AQS中的tryAcquire方法，而其实现为抽象类Sync#nonfairTryAcquire，NonfairSync非公平锁继承了Sync抽象类。</span><br><span class="line"></span><br><span class="line">通过tryAcquire尝试获取锁，如果获取失败，将当前线程封装为Node，放到同步队列里去，如果此过程没有发生中断操作，则返回false。反之为true，自身需要再中断一次。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; AbstractQueuedSynchronizer&amp;acquire</span><br></pre></td></tr></table></figure><pre><code>public final void acquire(int arg) {    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; NonfairTryAcquire&amp;tryAcquire</span><br></pre></td></tr></table></figure><pre><code>protected final boolean tryAcquire(int acquires) {    return nonfairTryAcquire(acquires);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">获取当前同步状态state，如果state == 0, 没有线程独占同步对象Sync，更新当前同步状态由0 -&gt; acquires,成功则设置同步对象的独占线程为当前线程。如果当前线程 == 同步对象Sync的独占线程，则当前设置同步状态为「当前值 + acquires」,如果重入的次数溢出，则抛出异常。</span><br><span class="line"></span><br><span class="line">&gt; Sync&amp;nonfairTryAcquire</span><br></pre></td></tr></table></figure><pre><code>final boolean nonfairTryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();    if (c == 0) {        if (compareAndSetState(0, acquires)) {            setExclusiveOwnerThread(current);            return true;        }    }    else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc &lt; 0) // overflow            throw new Error(&quot;Maximum lock count exceeded&quot;);        setState(nextc);        return true;    }    return false;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; AbstractQueuedSynchronizer&amp;acquireQueued</span><br></pre></td></tr></table></figure><pre><code>final boolean acquireQueued(final Node node, int arg) {    boolean failed = true;    try {        boolean interrupted = false;        for (;;) {        // 获取前继节点「① 前继节点可能为空的吧，假设队列里没有节点呢，添加一个节点不就是首节点？」            final Node p = node.predecessor();            // 前继节点为首节点，那么当前节点可以尝试获取锁，采用自旋的方式            if (p == head &amp;&amp; tryAcquire(arg)) {                setHead(node);                p.next = null; // help GC                failed = false;                return interrupted;            }            // 如果前继节点状态为SIGNAL，表示lock被其他线程占用，需要调用parkAndCheckInterrupt方法来中断当前线程，休息下。            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                 interrupted = true;        }    } finally {        if (failed)                // 清除node节点(清除过程是先给节点打上Node标签，再移除节点)            cancelAcquire(node);    }}  </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">shouldParkAfterFailedAcquire方法用于判断是否需要中断，如果前继节点处于SIGNA状态则需要唤醒。</span><br><span class="line"></span><br><span class="line">&gt; AbstractQueuedSynchronizer&amp;shouldParkAfterFailedAcquire</span><br></pre></td></tr></table></figure><p>private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {<br>        int ws = pred.waitStatus;<br>        if (ws == Node.SIGNAL)<br>            return true;<br>            // ① ws &gt; 0 的状态只有取消状态；<br>        if (ws &gt; 0) {<br>              // 跳过「直接」前继节点，往前遍历直到找到队列等待状态为SIGNAL的「间接」前继节点。<br>            do {<br>                node.prev = pred = pred.prev;<br>            } while (pred.waitStatus &gt; 0);<br>            pred.next = node;<br>        } else {<br>            // 前继节点为其他的状态时(非取消、非唤醒状态)，CAS设置为唤醒状态。<br>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>        }<br>        return false;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### unlock()</span><br><span class="line"></span><br><span class="line">若同步锁初始化为非公平锁，即调用NonfairSync的unlock方法，NonfairSync本身没有这个方法，使用继承抽象类Sync的继承抽象类AbstractQueuedSynchronizer的unlock方法。</span><br><span class="line"></span><br><span class="line">&gt; ReentrantLock&amp;unlock</span><br></pre></td></tr></table></figure></p><pre><code>public void unlock() {    sync.release(1);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tryRelease方法,被继承的父类Sync重载了。通过tryRelease方法释放锁，如果返回true，表示锁表成功释放。</span><br><span class="line"></span><br><span class="line">&gt; AbstractQueuedSynchronizer&amp;release</span><br></pre></td></tr></table></figure><pre><code>public final boolean release(int arg) {    if (tryRelease(arg)) {        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)        // 唤醒头节点的后继节点            unparkSuccessor(h);        return true;    }    return false;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此处是为了唤醒头节点的后继节点</span><br><span class="line"></span><br><span class="line">&gt; AbstractQueuedSynchronizer&amp;unparkSuccessor</span><br></pre></td></tr></table></figure><pre><code>private void unparkSuccessor(Node node) {    int ws = node.waitStatus;    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);   // 后继节点    Node s = node.next;     if (s == null || s.waitStatus &gt; 0) {        s = null;        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            if (t.waitStatus &lt;= 0)                s = t;    }    if (s != null)    // 唤醒后继节点线程        LockSupport.unpark(s.thread);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">获取当前同步状态state，如果当前线程不是lock对象的独占线程则抛错。若「state - releases == 0」,设置释放lock的独占线程并更新同步状态state为「state - releases」并返回true，表示锁已被释放，反之返回false，表示当前锁未被释放。</span><br><span class="line"></span><br><span class="line">&gt; Sync&amp;tryRelease</span><br></pre></td></tr></table></figure><pre><code>protected final boolean tryRelease(int releases) {    int c = getState() - releases;    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free = false;    if (c == 0) {        free = true;        setExclusiveOwnerThread(null);    }    setState(c);    return free;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 如何实现公平锁的？</span><br><span class="line"></span><br><span class="line">&gt; FairSync&amp;lock</span><br></pre></td></tr></table></figure><pre><code>final void lock() {    acquire(1);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; FairSync&amp;tryAcquire</span><br></pre></td></tr></table></figure><pre><code>protected final boolean tryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();    if (c == 0) {    // hasQueuedPredecessors判断是否有前继节点，如果没有才能获取锁        if (!hasQueuedPredecessors() &amp;&amp;                compareAndSetState(0, acquires)) {            setExclusiveOwnerThread(current);            return true;        }    }    else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc &lt; 0)            throw new Error(&quot;Maximum lock count exceeded&quot;);        setState(nextc);        return true;    }    return false;}</code></pre><p><code>`</code></p><h3 id="lock-、tryLock-、lockInterruptibly-的区别"><a href="#lock-、tryLock-、lockInterruptibly-的区别" class="headerlink" title="lock()、tryLock()、lockInterruptibly()的区别"></a>lock()、tryLock()、lockInterruptibly()的区别</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-9-18/95738650.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;ReentrantLock是一个重入锁，提供了公平锁和非公平锁的选择，通过构造方法接受参数fair，为true为公平锁，反之为非公平锁。默认
      
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java并发源码学习系列</title>
    <link href="http://jianwl.com/2018/09/17/Java%E5%B9%B6%E5%8F%91%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    <id>http://jianwl.com/2018/09/17/Java并发源码学习系列/</id>
    <published>2018-09-17T13:07:42.000Z</published>
    <updated>2018-09-18T13:43:01.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第二期源码刻意练习，本专题针对 锁、线程池、队列、并发容器，这个四个方面进行学习和梳理。以下会列出每个主题需要学习的内容</p><h3 id="训练计划"><a href="#训练计划" class="headerlink" title="训练计划"></a>训练计划</h3><p>锁</p><blockquote><p>1 <a href="http://jianwl.com/2018/09/17/ReentrantLock%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">ReentrantLock</a> 「√」</p><p>2 ReentrantReadWriteLock </p><p>3 Condition </p><p>4 CAS </p><p>5 CountDownLatch</p><p>6 CycliBarrier </p><p>7 Semaphore  </p><p>8 Exchanger </p></blockquote><p>多线程</p><blockquote><p>ScheduledThreadPoolExecutor</p><p>ThreadPoolExecutor</p><p>Executors</p></blockquote><p>队列</p><blockquote><p>ArrayBlockingQueue</p><p>LinkedBlockingQueue</p><p>DelayQueue</p><p>PriorityBlockingQueue</p><p>SynchronousQueue</p></blockquote><p>并发容器</p><blockquote><p>ConcurrentHashMap</p><p>ConcurrentLinkedQueue</p><p>ConcurrentSkipListMap</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;第二期源码刻意练习，本专题针对 锁、线程池、队列、并发容器，这个四个方面进行学习和梳理。以下会列出每个主题需要学习的内容&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>使用RAP,Mock第三方服务</title>
    <link href="http://jianwl.com/2018/09/08/%E4%BD%BF%E7%94%A8RAP-Mock%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1/"/>
    <id>http://jianwl.com/2018/09/08/使用RAP-Mock第三方服务/</id>
    <published>2018-09-08T02:26:33.000Z</published>
    <updated>2018-09-08T02:32:12.769Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>RAP是一个可视化接口管理工具 通过分析接口结构，动态生成模拟数据，校验真实接口正确性， 围绕接口定义，通过一系列自动化工具提升我们的协作效率。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>DEV环境的服务A，某个接口依赖第三方的服务。但DEV环境并没有部署第三方服务，那么要测试这个接口「除第三方之外的逻辑」，必须要Mock第三方服务。这个此时就可以使用RAP。具体使用详情，可以查看官网教程。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://rap2.taobao.org/" target="_blank" rel="noopener">RAP官网</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;RAP是一个可视化接口管理工具 通过分析接口结构，动态生成模拟数据，校验真实接口正确性， 围绕接口定义，通过一系列自动化工具提升我们的协作效
      
    
    </summary>
    
      <category term="Mock" scheme="http://jianwl.com/categories/Mock/"/>
    
    
      <category term="Mock" scheme="http://jianwl.com/tags/Mock/"/>
    
  </entry>
  
  <entry>
    <title>使用Charles抓Https包</title>
    <link href="http://jianwl.com/2018/09/08/%E4%BD%BF%E7%94%A8Charles%E6%8A%93Https%E5%8C%85/"/>
    <id>http://jianwl.com/2018/09/08/使用Charles抓Https包/</id>
    <published>2018-09-08T01:29:54.000Z</published>
    <updated>2018-09-08T02:35:49.072Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Charles是一个HTTP代理/ HTTP监视器/反向代理，使开发人员能够查看其机器和Internet之间的所有HTTP和SSL / HTTPS流量。 这包括请求，响应和HTTP标头（包含cookie和缓存信息）。这篇文章将会介绍如何抓取手机App上的请求。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://www.charlesproxy.com/download/" target="_blank" rel="noopener">Charles下载链接</a></p><h3 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h3><p>1、 打开charles, 设置proxy settings，记下端口号，默认8888</p><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-9-8/30793892.jpg" alt=""></p><p>2、查看本地电脑IP</p><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-9-8/22283825.jpg" alt=""></p><p>3、打开手机的wifi详情,选择http代理,选择手动，填入刚刚记下的电脑的ip地址,还有上面记下的charles的端口号(例如,默认的8888)</p><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-9-8/85988494.jpg" alt=""></p><p>4、打开Safari,输入chls.pro/ssl,安装charles证书</p><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-9-8/53294009.jpg" alt=""></p><p>5、在设置-通用-关于本机-证书信任，查看下载的证书是否已信任(PS：通用 - 描述文件与设备管理, 也需要设置证书信任)</p><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-9-8/48914902.jpg" alt=""></p><p>6、在手机上进行网络访问,这样charles会出现一个提示,大体上意思是,是否允许charles作为手机的网络请求代理，选择Allow</p><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-9-8/91391446.jpg" alt=""></p><p>7、在Proxy下，勾选macOS Proxy</p><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-9-8/19859492.jpg" alt=""></p><p>8、这样我们就可以愉快的抓包了，但打开的链接很多是左边是有锁的，点击下面都是<unknown>怎么办呢</unknown></p><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-9-8/7691650.jpg" alt=""></p><p>9、右键该链接，选择”Enable SSL Proxying”</p><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-9-8/21501010.jpg" alt=""></p><p>10、关闭charles，再打开，神奇的一幕出现了，请求报文可以看见了</p><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-9-8/2689691.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Charles是一个HTTP代理/ HTTP监视器/反向代理，使开发人员能够查看其机器和Internet之间的所有HTTP和SSL / HT
      
    
    </summary>
    
      <category term="Mac" scheme="http://jianwl.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://jianwl.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Astah之时序图教程</title>
    <link href="http://jianwl.com/2018/09/02/Astah%E4%B9%8B%E6%97%B6%E5%BA%8F%E5%9B%BE%E6%95%99%E7%A8%8B/"/>
    <id>http://jianwl.com/2018/09/02/Astah之时序图教程/</id>
    <published>2018-09-02T03:38:31.000Z</published>
    <updated>2018-09-02T03:41:42.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://astah.net/manual/434-sequence-diagram" target="_blank" rel="noopener">时序图 - Astah官方教程</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://astah.net/manual/434-sequence-diagram&quot; t
      
    
    </summary>
    
      <category term="UML" scheme="http://jianwl.com/categories/UML/"/>
    
    
      <category term="UML" scheme="http://jianwl.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>声明不可变类的策略</title>
    <link href="http://jianwl.com/2018/09/01/%E5%A3%B0%E6%98%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E7%9A%84%E7%AD%96%E7%95%A5/"/>
    <id>http://jianwl.com/2018/09/01/声明不可变类的策略/</id>
    <published>2018-09-01T10:08:48.000Z</published>
    <updated>2018-09-01T10:28:28.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不可变类定义"><a href="#不可变类定义" class="headerlink" title="不可变类定义"></a>不可变类定义</h3><ol><li>方法所有属性均不提供setter方法</li><li>所有属性均为final、private</li><li>不允许子类重构方法，最简单的方式，就是在类上加上final关键字，这样类不可继承，即所有方法均不会被重构；</li><li>如果属性为可变类的引用，则 ① 不提供改变可变类的方法 ② 不要共享对可变对象的引用。 永远不要存储对传递给构造函数的外部可变对象的引用; 如有必要，创建副本并存储对副本的引用。 同样，必要时创建内部可变对象的副本，以避免在方法中返回原始对象。</li></ol><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><h4 id="1-不可变类-包含可变引用属性"><a href="#1-不可变类-包含可变引用属性" class="headerlink" title="1. 不可变类(包含可变引用属性)"></a>1. 不可变类(包含可变引用属性)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class Employee&#123;</span><br><span class="line">    private final int id;</span><br><span class="line">    private final Address address;</span><br><span class="line">    public Employee(int id, Address address)</span><br><span class="line">    &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.address=new Address();  // defensive copy</span><br><span class="line">        this.address.setStreet(address.getStreet());</span><br><span class="line">    &#125;</span><br><span class="line">    pulbic int getId()&#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public Address getAddress() &#123;</span><br><span class="line">        Address nuAdd = new Address(); // must copy here too</span><br><span class="line">        nuAdd.setStreet(address.getStreet());</span><br><span class="line">        return nuAdd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-可变类"><a href="#2-可变类" class="headerlink" title="2. 可变类"></a>2. 可变类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Address&#123;</span><br><span class="line">    private String street;</span><br><span class="line">    public String getStreet()&#123;</span><br><span class="line">        return street;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setStreet(String street)&#123;</span><br><span class="line">        this.street = street;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/imstrat.html" target="_blank" rel="noopener">不可变类策略 - 官方链接</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;不可变类定义&quot;&gt;&lt;a href=&quot;#不可变类定义&quot; class=&quot;headerlink&quot; title=&quot;不可变类定义&quot;&gt;&lt;/a&gt;不可变类定义&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;方法所有属性均不提供setter方法&lt;/li&gt;
&lt;li&gt;所有属性均为final、private&lt;
      
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>spring bean加载</title>
    <link href="http://jianwl.com/2018/08/28/spring-bean%E5%8A%A0%E8%BD%BD/"/>
    <id>http://jianwl.com/2018/08/28/spring-bean加载/</id>
    <published>2018-08-28T13:09:16.000Z</published>
    <updated>2018-08-28T13:39:48.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Bean获取时序图"><a href="#1-Bean获取时序图" class="headerlink" title="1. Bean获取时序图"></a>1. Bean获取时序图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-28/85819316.jpg" alt=""></p><h5 id="1-尝试从缓存中加载单例-P-1-1"><a href="#1-尝试从缓存中加载单例-P-1-1" class="headerlink" title="1. 尝试从缓存中加载单例(P.1.1)"></a>1. 尝试从缓存中加载单例(P.1.1)</h5><p>单例在Spring的同一个容器内只会被创建一次，后续再获取bean，就直接从单例缓存中获取了。当然这里也只是尝试加载，首先尝试从缓存中加载，如果加载不成功则再次尝试从singletonFactories中加载。因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖，在spring中创建bean的原则是不等bean创建完成就会将创建bean的ObjectFactory提早曝光加入到缓存中，一旦下一个bean创建时候需要依赖上一个bean则直接使用ObjectFactory。</p><h5 id="2-bean的实例化-P-1-2"><a href="#2-bean的实例化-P-1-2" class="headerlink" title="2. bean的实例化(P.1.2)"></a>2. bean的实例化(P.1.2)</h5><p>如果从缓存中得到了bean的原始状态，则需要对bean进行实例化，这里有必要强调下，缓存中记录的只是原始的bean状态，并不一定是我们最终想要的bean。举个例子，假如我们需要对工厂bean进行处理，那么这里得到的其实是工厂bean的初始状态，但是我们真正需要的是工厂中定义的factory-method方法中返回的bean，而getObjectForBeanInstance就是完成这个工作的。</p><h5 id="3-原型模式的依赖检查"><a href="#3-原型模式的依赖检查" class="headerlink" title="3. 原型模式的依赖检查"></a>3. 原型模式的依赖检查</h5><p>只有在单例情况下才会尝试解决循环依赖，如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，就会产生当A还未创建完的时候，因为对B的依赖的创建再次返回创建A，造成循环依赖，也就是情况：isPrototypeCurrentlyInCreation(beanName)判断为true。</p><h5 id="4-检测parentBeanFactory-P-3"><a href="#4-检测parentBeanFactory-P-3" class="headerlink" title="4. 检测parentBeanFactory(P.3)"></a>4. 检测parentBeanFactory(P.3)</h5><p>从代码上看，如果缓存没有数据的话直接转到工厂上去加载了，这是为什么呢？可能读者忽略了一个很重要的判断条件：!constainsBeanDefinition(beanName),当前加载的XML配置文件中不包含beanName所对应的配置，就只能到parentBeanFactory去尝试下了，然后再去递归的调用getBean方法。</p><h5 id="5-将存储XML配置文件的GenericBeanDefinition转换为RootBeanDefinition。-P-4"><a href="#5-将存储XML配置文件的GenericBeanDefinition转换为RootBeanDefinition。-P-4" class="headerlink" title="5. 将存储XML配置文件的GenericBeanDefinition转换为RootBeanDefinition。(P.4)"></a>5. 将存储XML配置文件的GenericBeanDefinition转换为RootBeanDefinition。(P.4)</h5><p>因为XML配置文件中读取到的Bean信息是存储在GenericBeanDefinition中的，但是所有Bean后续处理都是针对RootBeanDefinition的，所以这里需要进行一个转换，转换的同时，如果父类bean不为空的话，则会合并父类的属性。</p><h5 id="6-寻找依赖"><a href="#6-寻找依赖" class="headerlink" title="6. 寻找依赖"></a>6. 寻找依赖</h5><p>因为bean的初始化过程很可能会用到某些属性，而某些属性很可能是动态配置的，并且配置成依赖于其他的bean，那么这个时候就有必要先加载依赖的bean，所以在spring的加载顺序中，在初始化某一个bean的时候，首先会初始化这个bean所对应的依赖</p><h5 id="7-针对不同的scope进行bean的创建-P-6"><a href="#7-针对不同的scope进行bean的创建-P-6" class="headerlink" title="7. 针对不同的scope进行bean的创建(P.6)"></a>7. 针对不同的scope进行bean的创建(P.6)</h5><p>在Spring中存在不同的scope，其中默认的是singleton,但是还有些其他的配置诸如prototype、request之类的，在这个步骤中，Spring会根据不同的配置进行不同的初始化策略。</p><h5 id="8-类型转换-P-7"><a href="#8-类型转换-P-7" class="headerlink" title="8. 类型转换(P.7)"></a>8. 类型转换(P.7)</h5><p>程序到这里返回bean已经基本结束，通常对方法调用参数requiredType是为空的，但是可能存在这种情况，返回的bean其实是个String,但是requiredType却传入Integer类型，那么这个时候，这个步骤就会起作用，它的功能是将返回的bean转换为requiredType所指定的类型。在Spring中提供了各种各样的转换器，用户也可以自己扩展转换器来满足需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Bean获取时序图&quot;&gt;&lt;a href=&quot;#1-Bean获取时序图&quot; class=&quot;headerlink&quot; title=&quot;1. Bean获取时序图&quot;&gt;&lt;/a&gt;1. Bean获取时序图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.c
      
    
    </summary>
    
      <category term="Spring" scheme="http://jianwl.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://jianwl.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>spring bean scope</title>
    <link href="http://jianwl.com/2018/08/25/spring-bean-scope/"/>
    <id>http://jianwl.com/2018/08/25/spring-bean-scope/</id>
    <published>2018-08-25T14:51:41.000Z</published>
    <updated>2018-08-25T14:52:19.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes" target="_blank" rel="noopener">Spring官方文档 bean scope</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/current/spri
      
    
    </summary>
    
      <category term="Spring" scheme="http://jianwl.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://jianwl.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>spring bean lifecycle</title>
    <link href="http://jianwl.com/2018/08/25/spring-bean-lifecycle/"/>
    <id>http://jianwl.com/2018/08/25/spring-bean-lifecycle/</id>
    <published>2018-08-25T13:08:14.000Z</published>
    <updated>2018-08-25T14:42:21.990Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>传统java对象的生命始于调用实例化对象的new运算符，并且当对象符合垃圾收集条件时调用finalize()方法。与传统的java对象相比，spring bean的生命周期不同。Spring框架提供了一下可用于控制bean生命周期的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InitializingBean和DisposableBean接口分别用于初始化Bean前和销毁Bean前调用方法。</span><br><span class="line"></span><br><span class="line">BeanNameAware、BeanFactoryAware和ApplicationContextAware用于特定行为的接口</span><br></pre></td></tr></table></figure><h3 id="生命周期流程图"><a href="#生命周期流程图" class="headerlink" title="生命周期流程图"></a>生命周期流程图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-25/58356701.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/spring-learning/blob/master/src/test/java/com/frank/springlearning/SpringLearningApplicationTests.java" target="_blank" rel="noopener">Bean生命周期测试 - 请移步源码 SpringLearningApplicationTests#test_002</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;传统java对象的生命始于调用实例化对象的new运算符，并且当对象符合垃圾收集条件时调用finalize()方法。与传统的java对象相比，
      
    
    </summary>
    
      <category term="Spring" scheme="http://jianwl.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://jianwl.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mockito入门与实战</title>
    <link href="http://jianwl.com/2018/08/23/Mockito%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <id>http://jianwl.com/2018/08/23/Mockito入门与实战/</id>
    <published>2018-08-23T15:12:52.000Z</published>
    <updated>2018-08-23T15:23:51.265Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在本地环境下，如果某个接口依赖第三方接口，在做单元测试时，如果本地环境没有第三方接口，那么该怎么办呢？这个场景下，Mock框架就非常有用了。当调用第三方接口时，直接返回模拟的数据。这样可以绕过第三方接口的阻断，实现整个流程的测试。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/spring-learning/blob/master/src/test/java/com/frank/springlearning/MockApiTest.java" target="_blank" rel="noopener">Mockito常用特性实战 - 请移步源码</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://static.javadoc.io/org.mockito/mockito-core/2.21.0/org/mockito/Mockito.html" target="_blank" rel="noopener">Mockito官方快速入门文档</a></li><li><a href="https://site.mockito.org/" target="_blank" rel="noopener">Mockito官方介绍</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在本地环境下，如果某个接口依赖第三方接口，在做单元测试时，如果本地环境没有第三方接口，那么该怎么办呢？这个场景下，Mock框架就非常有用了。
      
    
    </summary>
    
      <category term="Mock" scheme="http://jianwl.com/categories/Mock/"/>
    
    
      <category term="Mock" scheme="http://jianwl.com/tags/Mock/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot使用Converter实现类型转换</title>
    <link href="http://jianwl.com/2018/08/20/SpringBoot%E4%BD%BF%E7%94%A8Converter%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://jianwl.com/2018/08/20/SpringBoot使用Converter实现类型转换/</id>
    <published>2018-08-20T00:07:10.000Z</published>
    <updated>2018-08-20T00:26:37.146Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Spring3引入了Converter，实现从一个Object转为另外一个Object；</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="1-注册Convert实现"><a href="#1-注册Convert实现" class="headerlink" title="1. 注册Convert实现"></a>1. 注册Convert实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class StringToDateConverter implements Converter&lt;String,Date&gt;&#123;</span><br><span class="line">    private SimpleDateFormat sdf;</span><br><span class="line"></span><br><span class="line">    public StringToDateConverter() &#123;</span><br><span class="line">        sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public Date convert(String s) &#123;</span><br><span class="line">        Date date = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            date = sdf.parse(s);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-HelloController-API层"><a href="#2-HelloController-API层" class="headerlink" title="2. HelloController(API层)"></a>2. HelloController(API层)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(value = &quot;/date&quot;)</span><br><span class="line">    public String date(@RequestParam Date dateTime)&#123;</span><br><span class="line">        return &quot;hello: &quot; + dateTime.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-调用层"><a href="#3-调用层" class="headerlink" title="3. 调用层"></a>3. 调用层</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 启动SpringBoot服务，端口为1111</span><br><span class="line"></span><br><span class="line"># 使用CURL命令调用</span><br><span class="line">curl &quot;localhost:1111/date?dateTime=2018-08-10&quot;</span><br><span class="line"></span><br><span class="line"># 得到结果</span><br><span class="line">hello: 1533830400000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在Spring3引入了Converter，实现从一个Object转为另外一个Object；&lt;/p&gt;
&lt;h3 id=&quot;实战&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://jianwl.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://jianwl.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>java8之Funtion学习</title>
    <link href="http://jianwl.com/2018/08/13/java8%E4%B9%8BFuntion%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/08/13/java8之Funtion学习/</id>
    <published>2018-08-13T14:08:38.000Z</published>
    <updated>2018-08-13T14:37:36.462Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>function是java8的特性，之前零零散散接触过，但是都没怎么深入研究过这块，先来个扫盲篇，后续再好好整理。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">package functiondemo;</span><br><span class="line"></span><br><span class="line">import java.util.function.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author jianweilin</span><br><span class="line"> * @date 2018/8/13</span><br><span class="line"> */</span><br><span class="line">public class FunctionDemo &#123;</span><br><span class="line">    /**</span><br><span class="line">     * BiConsumer&lt;T,U&gt;</span><br><span class="line">     * T、U 均为入参，无返回值</span><br><span class="line">     */</span><br><span class="line">    public static void biConsumer() &#123;</span><br><span class="line">        BiConsumer&lt;String, String&gt; consumer = (x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(String.format(&quot;x = %s,y=%s&quot;, x, y));</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.accept(&quot;test01&quot;, &quot;test02&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BiFunction&lt;T,U,R&gt;</span><br><span class="line">     * T,U 为入参，R为返回值</span><br><span class="line">     */</span><br><span class="line">    public static void biFunction() &#123;</span><br><span class="line">        BiFunction&lt;String, String, String&gt; bi = (x, y) -&gt; &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(bi.apply(&quot;jian&quot;, &quot;.com&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BiPredicate&lt;T,U&gt;</span><br><span class="line">     * T，U 为入参，Boolean会返回值</span><br><span class="line">     */</span><br><span class="line">    public static void biPredicate() &#123;</span><br><span class="line">        BiPredicate&lt;Integer, Integer&gt; bi = (x, y) -&gt; x &gt; y;</span><br><span class="line">        BiPredicate&lt;Integer, Integer&gt; eq = (x, y) -&gt; x - 2 &gt; y;</span><br><span class="line"></span><br><span class="line">        System.out.println(bi.test(2, 3));</span><br><span class="line">        System.out.println(bi.and(eq).test(2, 3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BinaryOperator&lt;T&gt;</span><br><span class="line">     * 两个入参，得到一个返回值</span><br><span class="line">     */</span><br><span class="line">    public static void binaryOperator() &#123;</span><br><span class="line">        BinaryOperator&lt;Integer&gt; operator = (n1, n2) -&gt; n1 + n2;</span><br><span class="line">        System.out.println(operator.apply(3,4));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回一个boolean类型</span><br><span class="line">     */</span><br><span class="line">    public static void booleanSupplier()&#123;</span><br><span class="line">        BooleanSupplier bs = () -&gt; true;</span><br><span class="line">        System.out.println(bs.getAsBoolean());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 一个函数接受一个入参，无返回值</span><br><span class="line">     */</span><br><span class="line">    public static void consumer()&#123;</span><br><span class="line">        Consumer&lt;String&gt; c = (x) -&gt; System.out.println(x.toUpperCase());</span><br><span class="line">        c.accept(&quot;hello world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Function&lt;T,R&gt;</span><br><span class="line">     * 接受一个参数，并得到一个返回结果</span><br><span class="line">     */</span><br><span class="line">    public static void function()&#123;</span><br><span class="line">        Function&lt;Integer,String&gt; converter = (i) -&gt; Integer.toString(i);</span><br><span class="line">        System.out.println(converter.apply(3).length());</span><br><span class="line">        System.out.println(converter.apply(30).length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">Oracle Function文档</a></li><li><a href="http://www.java2s.com/Tutorials/Java_Lambda/java.util.function/" target="_blank" rel="noopener">Function实战</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;function是java8的特性，之前零零散散接触过，但是都没怎么深入研究过这块，先来个扫盲篇，后续再好好整理。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>mac终端崩溃</title>
    <link href="http://jianwl.com/2018/08/11/mac%E7%BB%88%E7%AB%AF%E5%B4%A9%E6%BA%83/"/>
    <id>http://jianwl.com/2018/08/11/mac终端崩溃/</id>
    <published>2018-08-11T06:07:15.000Z</published>
    <updated>2018-08-11T06:19:31.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>执行<code>brew update</code>，在更新过程中，手动退出更新进程，导致Mac的终端崩溃，每次打开终端时都出现以下界面：</p><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/91155821.jpg" alt=""></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-打开「自动操作」应用"><a href="#1-打开「自动操作」应用" class="headerlink" title="1. 打开「自动操作」应用"></a>1. 打开「自动操作」应用</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/91467398.jpg" alt=""></p><h4 id="2-在「自动操作」中选择：编辑-gt-新建-gt-工作流程-gt-shell脚本"><a href="#2-在「自动操作」中选择：编辑-gt-新建-gt-工作流程-gt-shell脚本" class="headerlink" title="2. 在「自动操作」中选择：编辑 -&gt; 新建 -&gt; 工作流程 -&gt; shell脚本"></a>2. 在「自动操作」中选择：编辑 -&gt; 新建 -&gt; 工作流程 -&gt; shell脚本</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/31642310.jpg" alt=""></p><h4 id="3-shell脚本，选择-bin-bash并执行以下命令"><a href="#3-shell脚本，选择-bin-bash并执行以下命令" class="headerlink" title="3. shell脚本，选择/bin/bash并执行以下命令"></a>3. shell脚本，选择<code>/bin/bash</code>并执行以下命令</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/27114106.jpg" alt=""></p><p>至此完成终端的修复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;执行&lt;code&gt;brew update&lt;/code&gt;，在更新过程中，手动退出更新进程，导致Mac的终端崩溃，每次打开终端时都出现以下界面：&lt;
      
    
    </summary>
    
      <category term="Mac" scheme="http://jianwl.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://jianwl.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>23.访问者模式</title>
    <link href="http://jianwl.com/2018/08/10/23-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/23-访问者模式/</id>
    <published>2018-08-10T00:32:45.000Z</published>
    <updated>2018-08-11T10:27:40.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>军营里，有指挥官的访问者、有中士的访问者、也有军士的访问者。</p><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义这些元素的新操作。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><p>访问者模式的目的是要把处理从数据结构分离出来。很多系统按照算法和数据结构分开，如果系统有稳定的数据结构，又有易于变化的算法，使用访问者模式比较合适。</p><h4 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h4><p>增加新的操作很容易，因为增加新的操作就以为这增加一个新的访问者。访问模式将有关的行为集中到一个访问者对象中。</p><h4 id="4-UML"><a href="#4-UML" class="headerlink" title="4. UML"></a>4. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/25786652.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/visitor" target="_blank" rel="noopener">访问者模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;军营里，有指挥官的访问者、有中士的访问者、也有军士的访问者。&lt;/p&gt;
&lt;h3 id=&quot;访问者模式&quot;&gt;&lt;a href=&quot;#访问者模式&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>22.解释器模式</title>
    <link href="http://jianwl.com/2018/08/10/22-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/22-解释器模式/</id>
    <published>2018-08-10T00:32:35.000Z</published>
    <updated>2018-08-11T10:02:57.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>实现一个计算器，实现加减法。</p><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>给定一个语言，定义它的语法的一种表示并定义一个解释器。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><ol><li>如果一个特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。</li></ol><h4 id="3-不足"><a href="#3-不足" class="headerlink" title="3. 不足"></a>3. 不足</h4><p>解释器模式为语法的每一条规则至少定义了一个类，因此包含许多规则的语法可能难以管理和维护。</p><h4 id="4-UML"><a href="#4-UML" class="headerlink" title="4. UML"></a>4. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/45885692.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/interpreter" target="_blank" rel="noopener">解释器模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;实现一个计算器，实现加减法。&lt;/p&gt;
&lt;h3 id=&quot;解释器模式&quot;&gt;&lt;a href=&quot;#解释器模式&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>21.享元模式</title>
    <link href="http://jianwl.com/2018/08/10/21-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/21-享元模式/</id>
    <published>2018-08-10T00:32:26.000Z</published>
    <updated>2018-08-11T09:57:56.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>炼金术商铺的货架上摆满了药水，每种药水都有多瓶。为了实现对象的复用，每种药水可以返回同一对象，实现对象的复用。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>运用共享技术有效地支持大量细粒度的对象</p><h4 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h4><p>如果有一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销就应该考虑使用；</p><h4 id="3-UML"><a href="#3-UML" class="headerlink" title="3. UML"></a>3. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/90836786.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/flyweight" target="_blank" rel="noopener">享元模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;炼金术商铺的货架上摆满了药水，每种药水都有多瓶。为了实现对象的复用，每种药水可以返回同一对象，实现对象的复用。&lt;/p&gt;
&lt;h3 id
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>20.中介者模式</title>
    <link href="http://jianwl.com/2018/08/10/20-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/20-中介者模式/</id>
    <published>2018-08-10T00:32:19.000Z</published>
    <updated>2018-08-11T09:50:20.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>举办一个相亲的Party，所有人并不知道有谁会参加，只知道来参加这个Party即可。</p><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><p>中介者模式一般用于一组对象以定义良好但是复杂的方式进行通信的场合。</p><h4 id="3-UML"><a href="#3-UML" class="headerlink" title="3. UML"></a>3. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/27571060.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/mediator" target="_blank" rel="noopener">中介者模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;举办一个相亲的Party，所有人并不知道有谁会参加，只知道来参加这个Party即可。&lt;/p&gt;
&lt;h3 id=&quot;中介者模式&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>19.责任链模式</title>
    <link href="http://jianwl.com/2018/08/10/19-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/19-责任链模式/</id>
    <published>2018-08-10T00:32:07.000Z</published>
    <updated>2018-08-11T09:43:41.741Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>国王发出指令：保卫城堡、释放囚犯、多征税收，这一些列的指令都会有特定的人来处理。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之前的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><ol><li>接收者和发送者都没有对方的明确信息，且链中的对象也不知道链的结构，结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需要保持它所有的候选者的引用。</li></ol><h4 id="3-UML"><a href="#3-UML" class="headerlink" title="3. UML"></a>3. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/99125541.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/chain" target="_blank" rel="noopener">责任链模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;国王发出指令：保卫城堡、释放囚犯、多征税收，这一些列的指令都会有特定的人来处理。&lt;/p&gt;
&lt;h3 id=&quot;责任链模式&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>18.命令模式</title>
    <link href="http://jianwl.com/2018/08/10/18-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/18-命令模式/</id>
    <published>2018-08-10T00:31:59.000Z</published>
    <updated>2018-08-11T09:33:18.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>巫师对妖精，使用了收缩咒和隐身咒。</p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。对请求排队或记录请求记录，以及支持可撤销的操作。</p><h4 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h4><ol><li>它能容易地设计一个命令队列</li><li>在需要的情况下，可以较容易地将命令记入日志。</li><li>允许接受请求的一方决定是否要否决请求</li><li>较为容易实现对请求的撤销或重做</li><li>由于加进新的命令模式类不影响其他类。</li></ol><h4 id="3-UML"><a href="#3-UML" class="headerlink" title="3. UML"></a>3. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/52368763.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/command" target="_blank" rel="noopener">命令模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;巫师对妖精，使用了收缩咒和隐身咒。&lt;/p&gt;
&lt;h3 id=&quot;命令模式&quot;&gt;&lt;a href=&quot;#命令模式&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>17.桥接模式</title>
    <link href="http://jianwl.com/2018/08/10/17-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/17-桥接模式/</id>
    <published>2018-08-10T00:31:51.000Z</published>
    <updated>2018-08-11T09:18:48.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>需要对武器进行附魔，武器和魔力属性是通过某种方式桥接在一起。</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>将抽象部分与它的实现部分分离，使他们都可以独立的变化。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><ol><li>使用聚合的关系，将两种对象聚合在一起形成一个整体。</li></ol><h4 id="3-UML"><a href="#3-UML" class="headerlink" title="3. UML"></a>3. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/99073982.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/bridge" target="_blank" rel="noopener">桥接模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;需要对武器进行附魔，武器和魔力属性是通过某种方式桥接在一起。&lt;/p&gt;
&lt;h3 id=&quot;桥接模式&quot;&gt;&lt;a href=&quot;#桥接模式&quot; c
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
