<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录点滴成长</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianwl.com/"/>
  <updated>2018-07-22T07:02:33.447Z</updated>
  <id>http://jianwl.com/</id>
  
  <author>
    <name>流云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>consul核心概念梳理</title>
    <link href="http://jianwl.com/2018/07/22/consul%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E6%A2%B3%E7%90%86/"/>
    <id>http://jianwl.com/2018/07/22/consul核心概念梳理/</id>
    <published>2018-07-22T06:00:30.000Z</published>
    <updated>2018-07-22T07:02:33.447Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是consul"><a href="#1-什么是consul" class="headerlink" title="1. 什么是consul"></a>1. 什么是consul</h3><p>Consul是一种服务网格(service mesh)解决方案，提供<strong>服务发现、配置和分段功能</strong>的全功能控制平面。每个功能可以单独使用，也可以一起使用以构建全服务网格。consul附带一个简单的内建代理，所以可以开箱即用，也支持第三方代理如Envoy。</p>
<h3 id="2-consul的核心特性"><a href="#2-consul的核心特性" class="headerlink" title="2. consul的核心特性"></a>2. consul的核心特性</h3><h4 id="1-服务发现"><a href="#1-服务发现" class="headerlink" title="1) 服务发现"></a>1) 服务发现</h4><p>consul客户端注册一个服务，如api或mysql，其他客户端可以使用consul发现服务提供者。使用DNS或HTTP可以很简单的找到它们依赖的服务。</p>
<h4 id="2）健康检查"><a href="#2）健康检查" class="headerlink" title="2）健康检查"></a>2）健康检查</h4><p>consul客户端提供任意数量的健康检查，这些运行检查可以与服务相关联(如服务健康检查)，也可以与本地节点相关联(如内存利用率低于90%)。使用方可以使用此信息来监控集群运行状态，服务发现组件使用此信息将流量路由远离不健康的主机。</p>
<h4 id="3-KV存储"><a href="#3-KV存储" class="headerlink" title="3) KV存储"></a>3) KV存储</h4><p>应用程序可以将consul的分层<strong>键/值存储</strong>用于任何用途，包括动态配置，功能标记，协调、领导者选举等。简单的HTTP API 使其易于使用。</p>
<h4 id="4）安全的服务通信"><a href="#4）安全的服务通信" class="headerlink" title="4）安全的服务通信"></a>4）安全的服务通信</h4><p>consul可以为服务生成和分发TLS证书，以建立互相的TLS连接。可以使用<strong>intentions</strong>来定义允许哪些服务进行通信。可以实时更改的<strong>intentions</strong>轻松管理服务分段，而不是使用复杂的网络拓扑和静态防火墙规则。</p>
<h4 id="5）多数据中心"><a href="#5）多数据中心" class="headerlink" title="5）多数据中心"></a>5）多数据中心</h4><p>consul支持开箱即用的多个数据中心，这意味着consul用户不必担心构建额外的抽象层以扩展到多个区域。</p>
<h3 id="3-consul的常用术语"><a href="#3-consul的常用术语" class="headerlink" title="3. consul的常用术语"></a>3. consul的常用术语</h3><h4 id="1）Agent"><a href="#1）Agent" class="headerlink" title="1）Agent"></a>1）Agent</h4><p>代理是consul集群的每个成员的长时间运行的守护进程，它是通过运行<code>consul agent</code>来启动的，代理能够以客户端或服务器模式运行，由于所有节点都必须运行代理，因此将节点成为客户端或服务器更简单，但代理的其他实例也是如此。所有代理都可以运行DNS或HTTP接口，并负责<strong>运行检查并保持服务同步</strong></p>
<h4 id="2）Client"><a href="#2）Client" class="headerlink" title="2）Client"></a>2）Client</h4><p>客户端是将所有RPC请求转发到服务器的代理，客户端是无状态的，客户端执行的唯一后台活动是参与局域gossip，这个活动的资源开销非常小，并且仅消耗少量的网络带宽。</p>
<h4 id="3-Server"><a href="#3-Server" class="headerlink" title="3) Server"></a>3) Server</h4><p>服务器是具有扩展责任的代理，包括参与Raft仲裁、维护集群状态，响应RPC查询，与其他数据中心交换广域gossip以及将查询转发给领导者或远程数据中心。</p>
<h4 id="4）Datacenter"><a href="#4）Datacenter" class="headerlink" title="4）Datacenter"></a>4）Datacenter</h4><p>虽然数据中心的定义似乎很明显，但必须考虑细微的细节。例如，在EC2中，多个可用区域是否被视为包含单个数据中心？我们将数据中心定义为专用、低延迟和高带宽的网络环境。这排除了通过公共互联网通信，但出于我们的目的，单个EC2区域内的多个可用区域将被视为单个数据中心的一部分。</p>
<h4 id="5）Consensus"><a href="#5）Consensus" class="headerlink" title="5）Consensus"></a>5）Consensus</h4><p>我们使用共识来表示对当选领导者的协议以及对事务顺序的协议，由于这些事务应用于有限状态机，因此我们对共识的定义意味着复制状态机的一致性。</p>
<h4 id="6）Gossip"><a href="#6）Gossip" class="headerlink" title="6）Gossip"></a>6）Gossip</h4><p>Consul建立在Serf之上，它提供了一个完整的gossip协议，可用于多种用途，Serf提供<strong>会员资格、故障检测和事件广播</strong>，gossip涉及随机节点间的通信，主要是通过UDP</p>
<h4 id="7）LAN-Gossip"><a href="#7）LAN-Gossip" class="headerlink" title="7）LAN Gossip"></a>7）LAN Gossip</h4><p>包含全部位于同一局域网或数据中心的节点</p>
<h4 id="8）WAN-Gossip"><a href="#8）WAN-Gossip" class="headerlink" title="8）WAN Gossip"></a>8）WAN Gossip</h4><p>服务器位于不同数据中心，通常通过广域网进行通信。</p>
<h4 id="9）RPC"><a href="#9）RPC" class="headerlink" title="9）RPC"></a>9）RPC</h4><p>远程过程调用，这是一种请求/响应机制，允许客户端想服务端发出请求。</p>
<h3 id="4-consul架构"><a href="#4-consul架构" class="headerlink" title="4. consul架构"></a>4. consul架构</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-7-22/94003551.jpg" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://www.consul.io/docs/internals/architecture.html" target="_blank" rel="external">Consul Guides</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-什么是consul&quot;&gt;&lt;a href=&quot;#1-什么是consul&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是consul&quot;&gt;&lt;/a&gt;1. 什么是consul&lt;/h3&gt;&lt;p&gt;Consul是一种服务网格(service mesh)解决方案，
    
    </summary>
    
      <category term="consul" scheme="http://jianwl.com/categories/consul/"/>
    
    
      <category term="consul" scheme="http://jianwl.com/tags/consul/"/>
    
  </entry>
  
  <entry>
    <title>初识zookeeper</title>
    <link href="http://jianwl.com/2018/07/05/%E5%88%9D%E8%AF%86zookeeper/"/>
    <id>http://jianwl.com/2018/07/05/初识zookeeper/</id>
    <published>2018-07-05T00:41:49.000Z</published>
    <updated>2018-07-05T00:50:01.642Z</updated>
    
    <content type="html"><![CDATA[<p>Zookeeper是一个开源的分布式协调服务，由雅虎创建，是google chubby的开源实现。zookeeper的设计目标是将哪些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p>
<h3 id="Zookeeper是什么"><a href="#Zookeeper是什么" class="headerlink" title="Zookeeper是什么"></a>Zookeeper是什么</h3><p>zookeeper是典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现如数据发布/订阅，负载均衡，命名服务，分布式协调/通知，集群管理，Master选举，分布式锁和分布式队列等功能。zookeeper可以保证如下分布式一致性特性：</p>
<p><strong>顺序一致性</strong></p>
<p>从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到Zookeeper中去。</p>
<p><strong>原子性</strong></p>
<p>所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群所有机器都成功应用了某个事务，要么都没有应用，一定不会出现集群中部分机器应用了事务，另外一部分没有应用事务。</p>
<p><strong>单一视图</strong></p>
<p>无论客户端连接的是哪个zookeeper服务器，其看到的服务端数据模型都是一致的</p>
<p><strong>可靠性</strong></p>
<p>一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</p>
<p><strong>实时性</strong></p>
<p>通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端读取到这个事务变更后的最新数据状态。这里需要注意的是，zookeeper仅仅保证在一定时间内，客户端最终一定能够从服务器上读取到最新的数据状态。</p>
<h3 id="Zookeeper的设计目标"><a href="#Zookeeper的设计目标" class="headerlink" title="Zookeeper的设计目标"></a>Zookeeper的设计目标</h3><p>zookeeper致力于提供一个高性能、高可用、且具有严格的顺序访问控制能力(主要是写操作的严格顺序性)的分布式协调服务。高性能使得zookeeper能够应用于那些对系统吞吐有明确要求的大型分布式系统中，高可用使得分布式的单点问题得到了很好的解决，而严格的顺序访问控制使得客户端能够基于Zookeeper实现一些复杂的同步原语。下面看下zk的四个设计目标。</p>
<h4 id="目标1：简单的数据模型"><a href="#目标1：简单的数据模型" class="headerlink" title="目标1：简单的数据模型"></a>目标1：简单的数据模型</h4><p>zookeeper使得分布式程序能够通过一个共享的、树形结构的名字空间来进行相互协调。这里所说的树形结构的名字空间，是指zookeeper服务器内存中的一个数据模型，是由一些列被称为znode的数据节点组成，总的来说，其数据模型类似于一个文件系统，而znode之间的层级关系，就想文件系统的目录结构一样。不过和传统的磁盘文件系统不同的是，zookeeper将全量数据存储在内存中，以此实现提高服务器吞吐，减少延迟的目的。</p>
<h4 id="目标2：可以构建集群"><a href="#目标2：可以构建集群" class="headerlink" title="目标2：可以构建集群"></a>目标2：可以构建集群</h4><p>一个zookeeper集群通常由一组机器组成，一般3 ~ 5台机器组成一个可用的zookeeper集群了，组成zookeeper集群的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都互相保持通信。值得一提的是，只要集群中存在超过一半的机器能够正常工作，那么整个集群就能够正常对外服务。</p>
<p>zookeeper的客户端程序会选择和集群中任意一台机器共同来床架一个TCP连接，而一旦客户端和某台zookeeper服务器之间的连接断开之后，客户端会自动连接到集群中的其他机器。</p>
<h4 id="目标3：顺序访问"><a href="#目标3：顺序访问" class="headerlink" title="目标3：顺序访问"></a>目标3：顺序访问</h4><p>对于来自客户端的每个更新请求，zookeeper都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序，应用程序可以使用zookeeper的这个特性来实现更高层次的同步原语。</p>
<h4 id="目标4：高性能"><a href="#目标4：高性能" class="headerlink" title="目标4：高性能"></a>目标4：高性能</h4><p>由于zookeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，因此它尤其适用于以读操作为主的应用场景。</p>
<h3 id="zookeeper的基本概念"><a href="#zookeeper的基本概念" class="headerlink" title="zookeeper的基本概念"></a>zookeeper的基本概念</h3><h4 id="1-集群角色"><a href="#1-集群角色" class="headerlink" title="1) 集群角色"></a>1) 集群角色</h4><p>通常在分布式系统中，构成一个集群的每一台机器都有自己的角色，最经典的集群模式就是Master/Slave模式(主备模式)，在这种模式中，我们把能够处理所有写操作的机器成为master机器，把所有通过异步复制方式获取最新数据，并提供读服务的机器成为Slave.</p>
<p>而在zookeeper中，这些概念被颠覆了，它没有沿用传统的Master/Slave概念，而是引入了Leader、Follower和Observe三种角色。Zookeeper集群中的所有机器通过一个Leader选举过程来选定一台机器被称为Leader的机器，Leader服务器为客户端提供读和写服务。除Leader外，其他机器包括Follower和Observer。Follower和Observer都能够提供读服务，唯一的区别在于，Observer机器不参与Leader选举过程，也不参加写操作的过半写成功策略，因此Observer可以在不影响写性能的情况下提升集群的读性能。</p>
<h4 id="2-会话-Session"><a href="#2-会话-Session" class="headerlink" title="2) 会话(Session)"></a>2) 会话(Session)</h4><p>session是指客户端会话，在讲解会话之前，我们首先来了解以下客户端连接。在zookeeper中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。zookeeper对外的服务端口默认是2181，客户端启动的时候，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个链接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向zookeeper服务器发送请求并接受响应，同时还能通过该连接接受来自服务器的Watch事件通知。Session的sessionTimeout值用来设置一个客户端会话的超时时间，当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p>
<h4 id="3-数据节点-Znode"><a href="#3-数据节点-Znode" class="headerlink" title="3) 数据节点(Znode)"></a>3) 数据节点(Znode)</h4><p>在谈到分布式的时候，我们通常说的节点是指组成集群的每一台机器。然而，在zookeeper中，节点分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点 - ZNode。zookeeper将所有数据存储在内存中，数据模型是一棵树(znode tree)，由斜杠「/」进行分割路径，就是一个znode，例如「/foo/path1」，每个znode上都会保存自己的数据内容同事还会保存一些列属性信息。</p>
<p>在zookeeper中，znode可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个znode被创建了，除非主动进行znode的移除操作，否则这个znode将一直保存在zookeeper上。而临时节点就不一样了，它的声明周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。另外，zookeeper还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，zookeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</p>
<h4 id="4）版本"><a href="#4）版本" class="headerlink" title="4）版本"></a>4）版本</h4><p>在前面我们已经提到，zookeeper的每个znode都会存储数据，对应于每个znode，zookeeper都会维护一个叫做stat的数据结构，stat中记录了这个znode的三个数据版本，分别是version(当前znode的版本)、cversion(当前znode子节点的版本)和aversion(当前znode的acl版本)</p>
<h4 id="5-watcher"><a href="#5-watcher" class="headerlink" title="5) watcher"></a>5) watcher</h4><p>watcher(事件监听器)，是zookeeper中的一个很重要的特性。zookeeper允许用户在指定节点上注册一些watcher，并且在一些特定事件触发的时候，zookeeper服务器会将事件通知到感兴趣的客户端上去，该机制是zookeeper实现分布式协调服务的重要特性。</p>
<h4 id="6-ACL"><a href="#6-ACL" class="headerlink" title="6) ACL"></a>6) ACL</h4><p>Zookeeper采用ACL(Access Control Lists)策略来进行权限控制，类似UNIX文件系统的权限控制。zookeeper定义了如下5中权限。</p>
<ul>
<li>create: 创建子节点的权限</li>
<li>read: 获取节点数据和子节点列表的权限</li>
<li>write: 更新节点数据的权限</li>
<li>delete: 删除子节点的权限</li>
<li>admin: 设置节点acl的权限</li>
</ul>
<p>其中尤其需要注意的是，create和delete这两种权限都是针对子节点的权限控制。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zookeeper是一个开源的分布式协调服务，由雅虎创建，是google chubby的开源实现。zookeeper的设计目标是将哪些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。&lt;/p&gt;
&lt;h3 id=&quot;Zoo
    
    </summary>
    
      <category term="zookeeper" scheme="http://jianwl.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://jianwl.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>使用vagrant搭建consul集群</title>
    <link href="http://jianwl.com/2018/07/04/%E4%BD%BF%E7%94%A8vagrant%E6%90%AD%E5%BB%BAconsul%E9%9B%86%E7%BE%A4/"/>
    <id>http://jianwl.com/2018/07/04/使用vagrant搭建consul集群/</id>
    <published>2018-07-04T14:58:44.000Z</published>
    <updated>2018-07-04T15:57:03.721Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-软件下载"><a href="#1-软件下载" class="headerlink" title="1. 软件下载"></a>1. 软件下载</h3><ol>
<li><a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="external">vagrant下载</a></li>
<li><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">virtualbox下载</a></li>
</ol>
<p>Vagrant是Hashi Corp公司的产品，用于创建和部署虚拟化开发环境，支持创建的操作系统。在部署虚拟开发环境需要用到virtualbox虚拟机软件，所以以上两个软件需要提前下载好。</p>
<h3 id="2-用vagrant创建虚拟机"><a href="#2-用vagrant创建虚拟机" class="headerlink" title="2. 用vagrant创建虚拟机"></a>2. 用vagrant创建虚拟机</h3><p>在安装好，virtualBox和vagrant的前提下，我们创建文件夹consul_cluster,在consul_cluster文件夹下创建一个文件<code>VagrantFile</code>,内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"># -*- mode: ruby -*-</div><div class="line"># vi: set ft=ruby :</div><div class="line"></div><div class="line">$script = &lt;&lt;SCRIPT</div><div class="line">echo &quot;Installing dependencies ...&quot;</div><div class="line"># 使用阿里云镜像</div><div class="line">sudo sed -i &apos;s/archive.ubuntu.com/mirrors.aliyun.com/g&apos; /etc/apt/sources.list</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install -y unzip curl jq</div><div class="line">SCRIPT</div><div class="line"></div><div class="line"># Specify a custom Vagrant box for the demo</div><div class="line">DEMO_BOX_NAME = &quot;ubuntu/xenial64&quot;</div><div class="line"></div><div class="line"># Vagrantfile API/syntax version.</div><div class="line"># NB: Don&apos;t touch unless you know what you&apos;re doing!</div><div class="line">VAGRANTFILE_API_VERSION = &quot;2&quot;</div><div class="line"></div><div class="line">Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|</div><div class="line">  config.vm.box = DEMO_BOX_NAME</div><div class="line"></div><div class="line">  config.vm.provision &quot;shell&quot;,</div><div class="line">                          inline: $script</div><div class="line"></div><div class="line">  config.vm.define &quot;n1&quot; do |n1|</div><div class="line">      n1.vm.hostname = &quot;n1&quot;</div><div class="line">      n1.vm.network &quot;private_network&quot;, ip: &quot;172.20.20.10&quot;</div><div class="line">  end</div><div class="line"></div><div class="line">  config.vm.define &quot;n2&quot; do |n2|</div><div class="line">      n2.vm.hostname = &quot;n2&quot;</div><div class="line">      n2.vm.network &quot;private_network&quot;, ip: &quot;172.20.20.11&quot;</div><div class="line">  end</div><div class="line"></div><div class="line">  config.vm.define &quot;n3&quot; do |n3|</div><div class="line">      n3.vm.hostname = &quot;n3&quot;</div><div class="line">      n3.vm.network &quot;private_network&quot;, ip: &quot;172.20.20.12&quot;</div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>这里我们创建了三个虚拟机，hostname为 n1，n2，n3；ip分别为 172.20.20.10，172.20.20.11，172.20.20.10，使用镜像 ubuntu/xenial64，并且将镜像更新为了阿里云，安装了一些必须的软件。</p>
<p>编辑好文件，在consul_cluster文件夹的路径下执行<code>vagrant up</code>,会下载ubuntu操作系统，并启动三台虚拟机，这个过程耗时比较长，我用了5个小时。</p>
<h3 id="3-登录3台虚拟机"><a href="#3-登录3台虚拟机" class="headerlink" title="3. 登录3台虚拟机"></a>3. 登录3台虚拟机</h3><p>在使用<code>vagrant up</code>命令初始化完成之后，在consul_cluster文件夹路径下，使用以下命令分别登录n1、n2、n3虚拟机:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 登录n1虚拟机</div><div class="line">vagrant ssh n1</div><div class="line"></div><div class="line"># 登录n2虚拟机</div><div class="line">vagrant ssh n2</div><div class="line"></div><div class="line"># 登录n3虚拟机</div><div class="line">vagrant ssh n3</div></pre></td></tr></table></figure>
<h3 id="4-搭建consul环境-三台虚拟机都需要执行一遍以下操作"><a href="#4-搭建consul环境-三台虚拟机都需要执行一遍以下操作" class="headerlink" title="4. 搭建consul环境(三台虚拟机都需要执行一遍以下操作)"></a>4. 搭建consul环境(三台虚拟机都需要执行一遍以下操作)</h3><h4 id="1-下载consul"><a href="#1-下载consul" class="headerlink" title="1. 下载consul"></a>1. 下载consul</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 下载consul</div><div class="line">wget https://releases.hashicorp.com/consul/1.2.0/consul_1.2.0_linux_amd64.zip</div><div class="line"></div><div class="line"># 解压</div><div class="line">unzip consul_1.2.0_linux_amd64.zip</div></pre></td></tr></table></figure>
<h4 id="2-创建以下两个文件夹"><a href="#2-创建以下两个文件夹" class="headerlink" title="2. 创建以下两个文件夹"></a>2. 创建以下两个文件夹</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /tmp/consul</div><div class="line"></div><div class="line">sudo mkdir /etc/consul.d</div></pre></td></tr></table></figure>
<h3 id="5-consul集群搭建"><a href="#5-consul集群搭建" class="headerlink" title="5. consul集群搭建"></a>5. consul集群搭建</h3><h4 id="1-虚拟机n1，启动consul服务"><a href="#1-虚拟机n1，启动consul服务" class="headerlink" title="1. 虚拟机n1，启动consul服务;"></a>1. 虚拟机n1，启动consul服务;</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">consul agent -server -bootstrap-expect=1 -data-dir=/tmp/consul -node=agent-one -bind=当前虚拟机IP -enable-script-checks=true -config-dir=/etc/consul.d</div></pre></td></tr></table></figure>
<h4 id="2-虚拟机n2，启动consul服务"><a href="#2-虚拟机n2，启动consul服务" class="headerlink" title="2. 虚拟机n2，启动consul服务;"></a>2. 虚拟机n2，启动consul服务;</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">consul agent -data-dir=/tmp/consul -node=agent-two -bind=当前虚拟机IP -enable-script-checks=true -config-dir=/etc/consul.d</div></pre></td></tr></table></figure>
<h4 id="3-在n1虚拟机的consul服务中，添加n2节点。"><a href="#3-在n1虚拟机的consul服务中，添加n2节点。" class="headerlink" title="3. 在n1虚拟机的consul服务中，添加n2节点。"></a>3. 在n1虚拟机的consul服务中，添加n2节点。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">consul join 虚拟机n2的IP</div></pre></td></tr></table></figure>
<h4 id="4-虚拟机n3，启动consul服务"><a href="#4-虚拟机n3，启动consul服务" class="headerlink" title="4. 虚拟机n3，启动consul服务;"></a>4. 虚拟机n3，启动consul服务;</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">consul agent -data-dir=/tmp/consul -node=agent-three -bind=当前虚拟机IP -enable-script-checks=true -config-dir=/etc/consul.d</div></pre></td></tr></table></figure>
<h4 id="5-在n1虚拟机的consul服务中，添加n3节点。"><a href="#5-在n1虚拟机的consul服务中，添加n3节点。" class="headerlink" title="5. 在n1虚拟机的consul服务中，添加n3节点。"></a>5. 在n1虚拟机的consul服务中，添加n3节点。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">consul join 虚拟机n3的IP</div></pre></td></tr></table></figure>
<h3 id="6-consul集群搭建实战"><a href="#6-consul集群搭建实战" class="headerlink" title="6. consul集群搭建实战"></a>6. consul集群搭建实战</h3><h3 id="1-登录n1虚拟机"><a href="#1-登录n1虚拟机" class="headerlink" title="1. 登录n1虚拟机"></a>1. 登录n1虚拟机</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-7-4/42241770.jpg" alt=""></p>
<h3 id="2-启动consul服务"><a href="#2-启动consul服务" class="headerlink" title="2. 启动consul服务"></a>2. 启动consul服务</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-7-4/50184269.jpg" alt=""></p>
<h3 id="3-查看n1集群状态"><a href="#3-查看n1集群状态" class="headerlink" title="3. 查看n1集群状态"></a>3. 查看n1集群状态</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-7-4/36062811.jpg" alt=""></p>
<h3 id="4-登录n2虚拟机"><a href="#4-登录n2虚拟机" class="headerlink" title="4. 登录n2虚拟机"></a>4. 登录n2虚拟机</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-7-4/68487932.jpg" alt=""></p>
<h3 id="5-启动consul服务"><a href="#5-启动consul服务" class="headerlink" title="5. 启动consul服务"></a>5. 启动consul服务</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-7-4/89679832.jpg" alt=""></p>
<h3 id="6-查看n2集群状态"><a href="#6-查看n2集群状态" class="headerlink" title="6. 查看n2集群状态"></a>6. 查看n2集群状态</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-7-4/70512094.jpg" alt=""></p>
<p>通过步骤3和步骤6的对比，我们发现，n1和n2两个节点并没有直接的关联。</p>
<h3 id="7-在n1节点中，加入节点2，节点间实现互相通信"><a href="#7-在n1节点中，加入节点2，节点间实现互相通信" class="headerlink" title="7. 在n1节点中，加入节点2，节点间实现互相通信"></a>7. 在n1节点中，加入节点2，节点间实现互相通信</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-7-4/86438059.jpg" alt=""></p>
<h3 id="8-查看集群状态"><a href="#8-查看集群状态" class="headerlink" title="8. 查看集群状态"></a>8. 查看集群状态</h3><p>n1节点查看集群状态</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-7-4/28819181.jpg" alt=""></p>
<p>n2节点查看集群状态</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-7-4/9956699.jpg" alt=""></p>
<p>由此看出n1节点和n2节点已经互相通信。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://www.consul.io/intro/getting-started/join.html" target="_blank" rel="external">Consul Cluster官方文档</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-软件下载&quot;&gt;&lt;a href=&quot;#1-软件下载&quot; class=&quot;headerlink&quot; title=&quot;1. 软件下载&quot;&gt;&lt;/a&gt;1. 软件下载&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vagrantup.com/downloads.h
    
    </summary>
    
      <category term="consul" scheme="http://jianwl.com/categories/consul/"/>
    
    
      <category term="consul" scheme="http://jianwl.com/tags/consul/"/>
    
  </entry>
  
  <entry>
    <title>Go语法概述</title>
    <link href="http://jianwl.com/2018/07/01/Go%E8%AF%AD%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    <id>http://jianwl.com/2018/07/01/Go语法概述/</id>
    <published>2018-07-01T01:19:24.000Z</published>
    <updated>2018-07-01T01:34:34.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为之前已经有编程基础了，所以在接触新语言时，会预先概览语言的语法，而后在针对每个语法深入学习。本节会描述Go常用的语法规则。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="1-编程第一个Go程序"><a href="#1-编程第一个Go程序" class="headerlink" title="1. 编程第一个Go程序"></a>1. 编程第一个Go程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">// 输出Hello world!</div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(&quot;hello world!&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-声明变量"><a href="#2-声明变量" class="headerlink" title="2. 声明变量"></a>2. 声明变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">// 方式1</div><div class="line">func defineVar1()&#123;</div><div class="line">	var x int32</div><div class="line">	var s = &quot;hello world&quot;</div><div class="line">	println(x,s)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 方式2</div><div class="line">func defineVar2()&#123;</div><div class="line">	x := 100</div><div class="line">	println(x)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 定义变量</div><div class="line">func main() &#123;</div><div class="line">	defineVar1()</div><div class="line">	defineVar2()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-1-表达式if"><a href="#3-1-表达式if" class="headerlink" title="3.1 表达式if"></a>3.1 表达式if</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">// 表达式</div><div class="line">func main() &#123;</div><div class="line">	x := 100</div><div class="line"></div><div class="line">	if x &gt; 0 &#123;</div><div class="line">		println(&quot;x&quot;)</div><div class="line">	&#125;else if x &lt; 0 &#123;</div><div class="line">		println(&quot;-x&quot;)</div><div class="line">	&#125;else&#123;</div><div class="line">		println(&quot;0&quot;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-2-表达式switch"><a href="#3-2-表达式switch" class="headerlink" title="3.2 表达式switch"></a>3.2 表达式switch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// switch</div><div class="line">func main() &#123;</div><div class="line">	x := 100</div><div class="line"></div><div class="line">	switch &#123;</div><div class="line">	case x &gt; 0:</div><div class="line">		println(&quot;x&quot;)</div><div class="line">	case x &lt; 0:</div><div class="line">		println(&quot;-x&quot;)</div><div class="line">	default:</div><div class="line">		println(&quot;0&quot;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-3-表达式for"><a href="#3-3-表达式for" class="headerlink" title="3.3 表达式for"></a>3.3 表达式for</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">func for01()&#123;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for01 &gt;&gt;&gt;&gt;&gt;&quot;)</div><div class="line">	for i:=0; i&lt;5;i++&#123;</div><div class="line">		println(i)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for i := 4; i&gt;=0;i--&#123;</div><div class="line">		println(i)</div><div class="line">	&#125;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for01 &gt;&gt;&gt;&gt;&gt;\n&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func for02()&#123;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for02 &gt;&gt;&gt;&gt;&gt;&quot;)</div><div class="line">	x := 0</div><div class="line"></div><div class="line">	for x &lt; 5&#123;</div><div class="line">		println(x)</div><div class="line">		x++</div><div class="line">	&#125;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for02 &gt;&gt;&gt;&gt;&gt;\n&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func for03()&#123;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for03 &gt;&gt;&gt;&gt;&gt;&quot;)</div><div class="line">	x := 4</div><div class="line"></div><div class="line">	for &#123;</div><div class="line">		println(x)</div><div class="line">		x--</div><div class="line"></div><div class="line">		if x&lt;0&#123;</div><div class="line">			break</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for03 &gt;&gt;&gt;&gt;&gt;\n&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func for04()&#123;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for04 &gt;&gt;&gt;&gt;&gt;&quot;)</div><div class="line"></div><div class="line">	x := []int&#123;100,101,102&#125;</div><div class="line"></div><div class="line">	for i,n :=range x&#123;</div><div class="line">		println(i,&quot;:&quot;,n)</div><div class="line">	&#125;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for04 &gt;&gt;&gt;&gt;&gt;\n&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 多种循环</div><div class="line">func main() &#123;</div><div class="line">	for01()</div><div class="line">	for02()</div><div class="line">	for03()</div><div class="line">	for04()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;errors&quot;</div><div class="line">	&quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line">// 函数: 可定义多个返回值</div><div class="line">func div(a,b int) (int,error)&#123;</div><div class="line">	if b==0&#123;</div><div class="line">		return 0,errors.New(&quot;division by zero&quot;)</div><div class="line">	&#125;</div><div class="line">	return a/b, nil</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 函数是第一类型，可作为参数或返回值</div><div class="line">func print01(x int) func()&#123;</div><div class="line">	return func()&#123;</div><div class="line">		println(x)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// defer定义延迟调用，无论函数是否出错，它都确保结束前被调用</div><div class="line">func defer01(a,b int)&#123;</div><div class="line">	defer println(&quot;dispace ...&quot;)</div><div class="line"></div><div class="line">	println(a/b)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	a,b := 10,2</div><div class="line">	c,err := div(a,b)</div><div class="line"></div><div class="line">	fmt.Println(c,err)</div><div class="line"></div><div class="line">	x := 100</div><div class="line"></div><div class="line">	f := print01(x)</div><div class="line">	f()</div><div class="line"></div><div class="line">	defer01(10,2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-切片"><a href="#5-切片" class="headerlink" title="5. 切片"></a>5. 切片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">// 切片(slice)可实现类似动态数组的功能</div><div class="line">func main() &#123;</div><div class="line">	x := make([]int, 0,5) // 创建容量为5的切片</div><div class="line"></div><div class="line">	for i:=0; i&lt;8;i++&#123;</div><div class="line">		x = append(x,i) // 追加数据，当容量超出，自动分配更大的存储空间</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Println(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-字典"><a href="#6-字典" class="headerlink" title="6. 字典"></a>6. 字典</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">// 将字典(map)类型内置，可直接从运行时层面获得性能优化</div><div class="line">func main() &#123;</div><div class="line">	m := make(map[string]int) // 创建字典对象</div><div class="line"></div><div class="line">	m[&quot;a&quot;] = 1 // 添加</div><div class="line"></div><div class="line">	x,ok := m[&quot;b&quot;] // 可知道key/value 是否存在</div><div class="line"></div><div class="line">	fmt.Println(x,ok)</div><div class="line">	delete(m,&quot;a&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-结构体"><a href="#7-结构体" class="headerlink" title="7. 结构体"></a>7. 结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">type user struct &#123; // 结构体</div><div class="line">	name string</div><div class="line">	age byte</div><div class="line">&#125;</div><div class="line"></div><div class="line">type manager struct &#123;</div><div class="line">	user // 匿名嵌入其他类型</div><div class="line">	title string</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结构体：可匿名嵌入其他类型</div><div class="line">func main() &#123;</div><div class="line">	var m manager</div><div class="line"></div><div class="line">	m.name = &quot;Tom&quot;</div><div class="line">	m.age = 29</div><div class="line">	m.title = &quot;cto&quot;</div><div class="line"></div><div class="line">	fmt.Println(m)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="8-方法"><a href="#8-方法" class="headerlink" title="8. 方法"></a>8. 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">type X int</div><div class="line"></div><div class="line">func (x *X) inc()&#123; // 名称前的参数称作receiver，作用类似python self</div><div class="line">	*x++</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 方法，可以为当前包内的任意类型定义方法</div><div class="line">func main() &#123;</div><div class="line">	var x X</div><div class="line">	x.inc()</div><div class="line">	println(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="9-接口"><a href="#9-接口" class="headerlink" title="9. 接口"></a>9. 接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">type role struct &#123;</div><div class="line">	name string</div><div class="line">	parentId int</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (r role) Print()&#123;</div><div class="line">	fmt.Printf(&quot;%+v\n&quot;,r)</div><div class="line">&#125;</div><div class="line"></div><div class="line">type Printer interface &#123;</div><div class="line">	Print()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接口采用了duck type方式，也就是说无须在实现类型上添加显式声明。</div><div class="line">// 另有空接口类型interface&#123;&#125;,用途类似OOP里的system.Object,可接受任意类型对象</div><div class="line">func main() &#123;</div><div class="line">	var r role</div><div class="line">	r.name = &quot;admin&quot;</div><div class="line">	r.parentId = 29</div><div class="line"></div><div class="line">	var p Printer = r</div><div class="line">	p.Print()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="10-并发"><a href="#10-并发" class="headerlink" title="10. 并发"></a>10. 并发</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func task(id int)&#123;</div><div class="line">	for i:=0; i&lt;5;i++&#123;</div><div class="line">		fmt.Printf(&quot;%d:%d\n&quot;,id,i)</div><div class="line">		time.Sleep(time.Second)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 整体运行时完全并发设计，凡你能看到的，几乎都在以goroutine方式运行，这是一种比普通协程或线程更加高效的并发设计，能够</div><div class="line">// 轻松创建和运行成千上万的并发任务</div><div class="line">func main() &#123;</div><div class="line">	go task(1)  // 创建goroutine</div><div class="line">	go task(2)</div><div class="line"></div><div class="line">	time.Sleep(time.Second*6)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="11-通道-channel-与-goroutine搭配"><a href="#11-通道-channel-与-goroutine搭配" class="headerlink" title="11. 通道(channel) 与 goroutine搭配"></a>11. 通道(channel) 与 goroutine搭配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">// 消费者</div><div class="line">func consumer(data chan int, done chan bool)&#123;</div><div class="line">	for x:=range data&#123;</div><div class="line">		println(&quot;recv:&quot;,x)  // 接受数据，直到通道被关闭</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	done &lt;- true // 通知main，消费结束</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 生产者</div><div class="line">func producer(data chan int)&#123;</div><div class="line">	for i :=0; i&lt;4; i++&#123;</div><div class="line">		data &lt;- i         // 发送数据</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	close(data) // 生产结束，关闭通道</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通道(channel) 与 goroutine搭配，实现用通信替代内存共享的CSP模型</div><div class="line">func main() &#123;</div><div class="line">	done := make(chan bool) // 用于接收消费结束信息</div><div class="line">	data := make(chan int)  // 数据管道</div><div class="line"></div><div class="line">	go consumer(data, done) // 启动消费者</div><div class="line">	go producer(data) // 启动生产者</div><div class="line"></div><div class="line">	&lt;-done // 阻塞，直到消费者发回结束信息</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;因为之前已经有编程基础了，所以在接触新语言时，会预先概览语言的语法，而后在针对每个语法深入学习。本节会描述Go常用的语法规则。&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="Go" scheme="http://jianwl.com/categories/Go/"/>
    
    
      <category term="Go" scheme="http://jianwl.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Git的各种撤销技巧</title>
    <link href="http://jianwl.com/2018/06/20/Git%E7%9A%84%E5%90%84%E7%A7%8D%E6%92%A4%E9%94%80%E6%8A%80%E5%B7%A7/"/>
    <id>http://jianwl.com/2018/06/20/Git的各种撤销技巧/</id>
    <published>2018-06-19T23:53:43.000Z</published>
    <updated>2018-06-19T23:57:01.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://blog.github.com/2015-06-08-how-to-undo-almost-anything-with-git/" target="_blank" rel="external">How to undo anything with Git</a></li>
<li><a href="https://tonydeng.github.io/2015/07/08/how-to-undo-almost-anything-with-git/" target="_blank" rel="external">Git的各种Undo技巧</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.github.com/2015-06-08-how-to-undo-
    
    </summary>
    
      <category term="Git" scheme="http://jianwl.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://jianwl.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Spring容器的基本实现</title>
    <link href="http://jianwl.com/2018/06/04/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jianwl.com/2018/06/04/Spring容器的基本实现/</id>
    <published>2018-06-04T00:14:01.000Z</published>
    <updated>2018-06-11T23:48:14.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这一节从实战到理论学习Spring容器的实现。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="1-核心依赖"><a href="#1-核心依赖" class="headerlink" title="1) 核心依赖"></a>1) 核心依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;parent&gt;</div><div class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;2.0.2.RELEASE&lt;/version&gt;</div><div class="line">	&lt;relativePath/&gt; </div><div class="line">&lt;/parent&gt;</div><div class="line"></div><div class="line">&lt;dependencies&gt;</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;5.0.6.RELEASE&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<h4 id="2）在容器中注册Bean-amp-获取Bean"><a href="#2）在容器中注册Bean-amp-获取Bean" class="headerlink" title="2）在容器中注册Bean &amp; 获取Bean"></a>2）在容器中注册Bean &amp; 获取Bean</h4><p>运行类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class MainBootstrap &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        BeanFactory bf = new XmlBeanFactory(new ClassPathResource(&quot;beanFactoryTest.xml&quot;));</div><div class="line">        MyTestBean bean = (MyTestBean) bf.getBean(&quot;myTestBean&quot;);</div><div class="line">        System.out.println(String.format(&quot;测试是否加载xml: %s&quot;,bean.getTestStr()));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>beanFactoryTest.xml文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">       xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">       xmlns:task=&quot;http://www.springframework.org/schema/task&quot;</div><div class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</div><div class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</div><div class="line">		http://www.springframework.org/schema/task</div><div class="line">        http://www.springframework.org/schema/task/spring-task-3.0.xsd</div><div class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;</div><div class="line">&gt;</div><div class="line">    &lt;bean id=&quot;myTestBean&quot; class=&quot;com.frank.springlearning.domain.MyTestBean&quot;/&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>以上完成了，Bean的注册和使用；</p>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>未完待续…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这一节从实战到理论学习Spring容器的实现。&lt;/p&gt;
&lt;h3 id=&quot;实战&quot;&gt;&lt;a href=&quot;#实战&quot; class=&quot;headerlin
    
    </summary>
    
      <category term="Spring源码学习专题" scheme="http://jianwl.com/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="Spring源码学习专题" scheme="http://jianwl.com/tags/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码学习计划</title>
    <link href="http://jianwl.com/2018/06/04/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://jianwl.com/2018/06/04/Spring源码学习计划/</id>
    <published>2018-06-03T23:58:32.000Z</published>
    <updated>2018-06-04T00:13:50.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>接触Spring有3年了，Spring的两大特性IOC和AOP在工作中也是常用，但是如果有人问我，Spring是如何实现这两大特性的，我一定只能模棱两可的说出。或许这个时候就是你该沉下心来，好好学习它的原理实现了，知其所以然，学习其思想。学习Spring这是一个专题，刻意学习，才能有所收获。</p>
<h3 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h3><ol>
<li>容器的基本实现；</li>
<li>AOP的基本实现；</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;接触Spring有3年了，Spring的两大特性IOC和AOP在工作中也是常用，但是如果有人问我，Spring是如何实现这两大特性的，我一定
    
    </summary>
    
      <category term="Spring源码学习专题" scheme="http://jianwl.com/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="Spring源码学习专题" scheme="http://jianwl.com/tags/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型之happens-before</title>
    <link href="http://jianwl.com/2018/05/20/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8Bhappens-before/"/>
    <id>http://jianwl.com/2018/05/20/Java内存模型之happens-before/</id>
    <published>2018-05-20T10:31:08.000Z</published>
    <updated>2018-05-20T11:01:21.079Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java语言中有一个“先行发生”的原则，它是判断数据是否存在竞争、线程是否安全的主要依据。下面是Java内存模型一些“天然”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p>
<h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><h4 id="1-程序次序规则"><a href="#1-程序次序规则" class="headerlink" title="1) 程序次序规则"></a>1) 程序次序规则</h4><p>在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p>
<h4 id="2）管程锁定规则"><a href="#2）管程锁定规则" class="headerlink" title="2）管程锁定规则"></a>2）管程锁定规则</h4><p>一个unlock操作先行发生于后面的对同一个锁的lock操作。这里必须强调是同一个锁，而“后面”同样是指时间上的先后顺序。</p>
<h4 id="3）volatile变量规则"><a href="#3）volatile变量规则" class="headerlink" title="3）volatile变量规则"></a>3）volatile变量规则</h4><p>对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</p>
<h4 id="4-线程启动规则"><a href="#4-线程启动规则" class="headerlink" title="4) 线程启动规则"></a>4) 线程启动规则</h4><p>Thread对象的start()方法先行发生于此线程的每一个动作。</p>
<h4 id="5）线程终止规则"><a href="#5）线程终止规则" class="headerlink" title="5）线程终止规则"></a>5）线程终止规则</h4><p>线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行了。</p>
<h4 id="6）线程中断规则"><a href="#6）线程中断规则" class="headerlink" title="6）线程中断规则"></a>6）线程中断规则</h4><p>对于线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过Thread.interrupted方法检测到是否有中断发生。</p>
<h4 id="7）对象终结规则"><a href="#7）对象终结规则" class="headerlink" title="7）对象终结规则"></a>7）对象终结规则</h4><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的finilize()方法的开始。</p>
<h4 id="8）传递性"><a href="#8）传递性" class="headerlink" title="8）传递性"></a>8）传递性</h4><p>如果操作A先行发生于操作B，操作B先行发生于操作C，那么就可以得出操作A先行发生于操作C。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>深入理解Java虚拟机 - P376</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Java语言中有一个“先行发生”的原则，它是判断数据是否存在竞争、线程是否安全的主要依据。下面是Java内存模型一些“天然”先行发生关系，这
    
    </summary>
    
      <category term="Java进阶" scheme="http://jianwl.com/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java进阶" scheme="http://jianwl.com/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://jianwl.com/2018/05/20/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://jianwl.com/2018/05/20/Java内存模型/</id>
    <published>2018-05-20T08:10:13.000Z</published>
    <updated>2018-05-20T10:10:15.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java内存模型有什么用？"><a href="#Java内存模型有什么用？" class="headerlink" title="Java内存模型有什么用？"></a>Java内存模型有什么用？</h3><p>JVM规范定义Java内存模型主要是为了屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各个平台下都能达到一致的内存访问效果。</p>
<p>在此之前，主流程序语言如<code>C/C++</code>直接使用物理硬件和操作系统的内存模型，因此，会由于不同内存模型的差异，有可能导致在平台A能运行，平台B却不能运行的情况。</p>
<h3 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h3><p>在多CPU的系统中，每个CPU都有多级缓存，一般分为L1、L2、L3缓存，因为这些缓存的存在，提供了数据的访问性能，也减轻了数据总线上数据传输的压力，同时也带来了很多新的挑战，比如两个CPU同时去操作同一个内存地址，会发生什么？在什么条件下，它们可以看到相同的结果？这些都是需要解决的。</p>
<p>所以在CPU的层面，内存模型定义了一个充分必要条件，保证其他CPU的写入动作对该CPU是可见的，而且该CPU的写入动作对其他CPU也是可见的，那这种可见性，应该如何实现呢？</p>
<p>有些处理器提供了强内存模型，所有CPU在任何时候都能看到内存中任意位置相同的值，这种完全是硬件提供的支持。</p>
<p>其他处理器，提供了弱内存模型，需要执行一些特殊指令(就是经常看到货听到的，Memory Barries内存屏障)，刷新CPU缓存的数据到内存中，保证这个写操作能够被其他CPU可见，或者将CPU缓存的数据设置为无效状态，保证其他CPU的写操作对本CPU可见。通过这些内存屏障的行为由底层实现，对于上层语言的程序员来说是透明的。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-20/9953164.jpg" alt=""></p>
<p>前面说到的内存屏障，除了实现CPU之外的数据可见性之外，还有一个重要的职责，可以禁止指令的重排序。</p>
<p>这里说的重排序可以发生在好几个地方：编译器、运行时、JIT等，比如编译器会觉得把一个变量的写操作放在最后更有效率，编译后，这个指令就是在最后了(前提是只要不改变程序的语义，编译器、执行器就可以这样自由的随意优化)，一旦编译器对某个变量的写操作进行优化(放到最后)，那么执行之前，另一个线程将不会看到这个执行结果。</p>
<p>当然了，写入动作可能被移到后面，那么也有可能挪到前面，这样的优化有什么影响呢？这种情况下，其他线程可能会在程序实现“发生”之前，看到这个写入动作(这里怎么理解，指令已经执行了，但是在代码层面还没执行到)，通过内存屏障的功能，我们可以禁止一些不必要、或者会带来负面影响的重排序优化，在内存模型的范围内，实现更高性能，同时保证程序的正确性。</p>
<p>下面看一个重排序的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Class Reordering &#123;</div><div class="line">  int x = 0, y = 0;</div><div class="line">  public void writer() &#123;</div><div class="line">    x = 1;</div><div class="line">    y = 2;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void reader() &#123;</div><div class="line">    int r1 = y;</div><div class="line">    int r2 = x;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设这段代码有2个线程并发执行，线程A执行writer方法，线程B执行reader方法，线程B看到y的值为2，因为把y设置成2发生在变量x的写入之后，所以能断定线程B这时看到的x就是1吗？</p>
<p>在Java内存模型中，描述了在多线程代码中，哪些行为是正确的、合法的、以及多线程之间如何进行通信，代码中变量的读写行为如何反应到内存、CPU缓存的底层细节。</p>
<p>在Java中包含了几个关键字：volatile、final和synchronized，帮助程序员把代码中的并发需求描述给编译器，Java内存模型中定义了他们的行为，确保正确同步的Java代码在所有的处理器上都能正确执行。</p>
<h3 id="synchronization可以实现什么"><a href="#synchronization可以实现什么" class="headerlink" title="synchronization可以实现什么"></a>synchronization可以实现什么</h3><p>Synchronizeation有多中语义，其中最容易理解的是互斥，对于一个monitor对象，只能够被一个线程持有，意味着一旦有线程进入了同步代码块，那么其他线程就不能进入直到第一个进入的线程退出代码块。</p>
<p>但是更多的时候，使用synchronization并非单单互斥功能，synchronization保证了线程在同步块之前或者期间写入动作，对于后续进入该代码块的线程是可见的(又是可见性，不过这里需要注意的是对同一个monitor对象而言)。在一个线程退出同步块时，线程释放monitor对象，它的作用是把CPU缓存数据(本地缓存数据)刷新到主内存中，从而实现该线程的行为可以被其他线程看到。在其他线程进入到该代码块时，需要获得monitor对象，它的作用是使CPU缓存失效，从而使变量从主内存中重新加载，然后就可以看到之前线程对该变量的修改。</p>
<p>但从缓存的角度看，似乎这个问题只会影响多处理器的机器，对于单核来说没什么问题，但是别忘了，它还有一个语义是禁止指令的重排序，对于编译器来说，同步块中的代码不会移动到获取和释放monitor外面。</p>
<p>下面这种代码，千万别写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">synchronized(new Object()) 「×」</div></pre></td></tr></table></figure>
<p>编译器完全可以删除这个同步语义，因为编译器知道没有其他线程会在同一个monitor对象上同步。</p>
<p>所以，请注意：对于两个线程来说，在相同的monitor对象上同步是很重要的，以便正确的设置happens-before关系。</p>
<h3 id="final可以影响什么"><a href="#final可以影响什么" class="headerlink" title="final可以影响什么"></a>final可以影响什么</h3><p>如果一个类包含final字段，且在构造器中初始化，那么正确的构造一个对象后，final字段被设置后对于其他线程是可见的。</p>
<p>这里所说的正确构造对象，意思是在对象的构造过程中，不允许对该对象进行引用，不然的话，可能存在其他线程在对象还没构造完成时就对该对象进行访问，造成不必要的麻烦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">final int x;</div><div class="line">  int y;</div><div class="line">  static FinalFieldExample f;</div><div class="line">  public FinalFieldExample() &#123;</div><div class="line">    x = 3;</div><div class="line">    y = 4;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  static void writer() &#123;</div><div class="line">    f = new FinalFieldExample();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  static void reader() &#123;</div><div class="line">    if (f != null) &#123;</div><div class="line">      int i = f.x;</div><div class="line">      int j = f.y;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个例子描述了应该如何使用final字段，一个线程A执行reader方法，如果f已经在线程B初始化好了，那么可以确保线程A看到x值是3，因为final它是final修饰的，而不能确保看到y的值是4.</p>
<h3 id="volatile可以做什么"><a href="#volatile可以做什么" class="headerlink" title="volatile可以做什么"></a>volatile可以做什么</h3><p>volatile字段主要用于线程之间进行通信，volatile字段的每次读行为都能看到其他线程最后一次对该字段的写行为，通过它就可以避免拿到缓存中陈旧数据。它们必须保证在被写入之后，会被刷新到主内存中，这样就可以立即对其他线程可以见。类似的，在读取volatile字段之前，缓存必须是无效的，以保证每次拿到的都是主内存的值，都是最新的值。volatile的内存语义和synchronized获取和释放monitor的实现目的差不多。</p>
<p>对于重排序，volatile也有额外的限制。</p>
<p>下面看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class VolatileExample &#123;</div><div class="line">  int x = 0;</div><div class="line">  volatile boolean v = false;</div><div class="line">  public void writer() &#123;</div><div class="line">    x = 42;</div><div class="line">    v = true;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void reader() &#123;</div><div class="line">    if (v == true) &#123;</div><div class="line">      //uses x - guaranteed to see 42.</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的，假设一个线程A执行writer，另一个线程B执行reader，writer中对变量v的写入把x的写入也刷新到主内存中。reader方法会从主内存重新获取v的值，所以如果线程B看到v的值为true，就能保证拿到的x是42.（因为把x设置成42发生在把v设置成true之前，volatile禁止这两个写入行为的重排序）</p>
<p>如果变量v不是volatile，那么以上描述就不成立了，因为执行顺序可能是v=true，x=42,或者对于线程B来说，根本看不到v被设置为true。</p>
<h3 id="double-checked-locking的问题"><a href="#double-checked-locking的问题" class="headerlink" title="double-checked locking的问题"></a>double-checked locking的问题</h3><p>臭名昭著的双重检查(单例模式的一种)，是一种延时初始化的实现技巧，避免了同步的开销，因为在早起的JVM，同步操作性能很差，所以才出现了这样的小技巧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private static Something instance = null;</div><div class="line"></div><div class="line">public Something getInstance() &#123;</div><div class="line">  if (instance == null) &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (instance == null)</div><div class="line">        instance = new Something();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个技巧看起来很聪明，避免了同步的开销，但是有一个问题，它可能不起作用，为什么呢？因为实例的初始化和实例字段的写入可能被编译器重排序，这样可能读到一个未初始化完成的对象。</p>
<p>当然，这种bug可以通过使用volatile修饰instance字段进行修复，但是我觉得这种代码格式实在太丑陋了，如果真要延时初始化，不妨使用下面这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private static class LazySomethingHolder &#123;</div><div class="line">  public static Something something = new Something();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static Something getInstance() &#123;</div><div class="line">  return LazySomethingHolder.something;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于是静态字段的初始化，可以确保对访问该类的所有线程都是可见的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java内存模型有什么用？&quot;&gt;&lt;a href=&quot;#Java内存模型有什么用？&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型有什么用？&quot;&gt;&lt;/a&gt;Java内存模型有什么用？&lt;/h3&gt;&lt;p&gt;JVM规范定义Java内存模型主要是为了屏蔽各种硬件
    
    </summary>
    
      <category term="Java进阶" scheme="http://jianwl.com/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java进阶" scheme="http://jianwl.com/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入分析CAS</title>
    <link href="http://jianwl.com/2018/05/19/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90CAS/"/>
    <id>http://jianwl.com/2018/05/19/深入分析CAS/</id>
    <published>2018-05-19T15:17:12.000Z</published>
    <updated>2018-05-20T05:19:14.727Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>CAS, Compare And Swap，即比较并交换。Doug lea大神在同步组价中大量使用CAS技术鬼斧神工地实现了Java多线程的并发操作。整个AQS同步组件、Atomic原子类操作等等都是以CAS实现的，甚至ConcurrentHashMap在1.8版本中也调整为CAS + Synchronized。可以说CAS是整个JUC的基石。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-20/58954764.jpg" alt=""></p>
<h3 id="CAS分析"><a href="#CAS分析" class="headerlink" title="CAS分析"></a>CAS分析</h3><p>在CAS中有三个参数：内存值V、旧的预期值A，要更新的值B，当前仅当内存值V的值等于旧的预期值A时才会将内存值V的值修改为B，否则什么都不干。其伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if(this.value == A)&#123;</div><div class="line">	this.value = B</div><div class="line">	return true;</div><div class="line">&#125;else&#123;</div><div class="line">	return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JUC的atomic类都是通过CAS来实现的，下面就以AtomicInteger为例阐述CAS的实现。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</div><div class="line">private static final long valueOffset;</div><div class="line"></div><div class="line">static &#123;</div><div class="line">    try &#123;</div><div class="line">        valueOffset = unsafe.objectFieldOffset</div><div class="line">            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</div><div class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private volatile int value;</div></pre></td></tr></table></figure>
<p>Unsafe是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地(native)方法来访问。不过尽管如此，JVM还是开了一个后门，Unsafe，它提供了<strong>硬件级别</strong>的原子操作。</p>
<p><code>valueOffset</code>为变量值在内存中的偏移地址，unsafe就是通过偏移地址来得到数据的原值的。</p>
<p><code>value</code>当前值，使用volatile修饰，保证多线程环境下看见的是同一个。</p>
<p>我们就以AtomicInteger的addAndGet()方法来说明，先看源代码；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   public final int addAndGet(int delta) &#123;</div><div class="line">       return unsafe.getAndAddInt(this, valueOffset, delta) + delta;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public final int getAndAddInt(Object var1, long var2, int var4) &#123;</div><div class="line">       int var5;</div><div class="line">       do &#123;</div><div class="line">           var5 = this.getIntVolatile(var1, var2);</div><div class="line">       &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</div><div class="line">       return var5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部调用unsafe的getAndAddInt方法，在getAndAddInt方法中主要看compareAndSwapInt方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</div></pre></td></tr></table></figure>
<p>该方法为本地方法，有4个参数，分表代表：对象、对象的地址、预期值、修改值，该方法的实现这里就不做详细介绍了，有兴趣的伙伴可以看看<code>openjdk</code>的源码。</p>
<p>CAS可以保证一次的读-写-改操作是原子操作，在单处理器上该操作容易实现，但是在多处理器上实现就有点复杂了。</p>
<p>CPU提供了两种方法来实现多处理器的原子操作：总线加锁或缓存加锁。</p>
<h4 id="总线加锁"><a href="#总线加锁" class="headerlink" title="总线加锁"></a>总线加锁</h4><p>总线加锁就是使用处理器提供一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占使用共享内存。但是这种处理方式显得有点霸道，它把CPU和内存之间的通信锁住了，在锁定期间，其他处理器都不能访问内存地址的数据，其开销有点大。所以就有了缓存加锁。</p>
<h4 id="缓存加锁"><a href="#缓存加锁" class="headerlink" title="缓存加锁"></a>缓存加锁</h4><p>其实针对上面那种情况我们只需要保证在同一时刻对某个内存地址的操作是原子性的即可。缓存加锁就是缓存在内存区域的数据如果在加锁期间，当它执行操作写回内存时，处理器不在输出LOCK#信号，而是修改内存的内存地址，利用缓存一致性协议来保证原子性。缓存一致性机制可以保证同一个内存区域的数据仅能被一个处理器修改，也就是说当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。</p>
<h3 id="CAS缺陷"><a href="#CAS缺陷" class="headerlink" title="CAS缺陷"></a>CAS缺陷</h3><p>CAS虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面：循环时间太长、只能保证一个共性变量原子操作、ABA问题。</p>
<h5 id="1-循环时间太长"><a href="#1-循环时间太长" class="headerlink" title="1) 循环时间太长"></a>1) 循环时间太长</h5><p>如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC有些地方就限制了CAS自旋的次数，例如BlockQueue的SynchronousQueue。</p>
<h5 id="2-只能保证一个共享变量原子操作"><a href="#2-只能保证一个共享变量原子操作" class="headerlink" title="2) 只能保证一个共享变量原子操作"></a>2) 只能保证一个共享变量原子操作</h5><p>看了CAS的实现就知道它只能针对一个共享变量，如果是多个共享变量就只能使用锁了。当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高位</p>
<h5 id="3-ABA问题"><a href="#3-ABA问题" class="headerlink" title="3) ABA问题"></a>3) ABA问题</h5><p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A -&gt; B -&gt; A，变成1A -&gt; 2B -&gt; 3A。</p>
<h5 id="ABA解决方案"><a href="#ABA解决方案" class="headerlink" title="ABA解决方案"></a>ABA解决方案</h5><p>CAS的ABA隐患问题，解决方案则是加上版本号，Java提供了AtomicStampedReference来解决。AtomicStampedReference通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题。</p>
<p>AtomicStampedReference的compareAndSet()方法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public boolean compareAndSet(V   expectedReference,</div><div class="line">                             V   newReference,</div><div class="line">                             int expectedStamp,</div><div class="line">                             int newStamp) &#123;</div><div class="line">    Pair&lt;V&gt; current = pair;</div><div class="line">    return</div><div class="line">        expectedReference == current.reference &amp;&amp;</div><div class="line">        expectedStamp == current.stamp &amp;&amp;</div><div class="line">        ((newReference == current.reference &amp;&amp;</div><div class="line">          newStamp == current.stamp) ||</div><div class="line">         casPair(current, Pair.of(newReference, newStamp)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>compareAndSet有四个参数，分别表示：预期引用、更新后的引用、预期标志、更新后的标志。如果更新后的引用和标志和当前引用和标志相等则直接返回true，否则通过Pair生成一个新的pair对象与当前pair CAS替换。Pair为AtomicStampedReference的内部类，主要用于记录引用和版本戳信息，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private static class Pair&lt;T&gt; &#123;</div><div class="line">    final T reference;</div><div class="line">    final int stamp;</div><div class="line">    private Pair(T reference, int stamp) &#123;</div><div class="line">        this.reference = reference;</div><div class="line">        this.stamp = stamp;</div><div class="line">    &#125;</div><div class="line">    static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;</div><div class="line">        return new Pair&lt;T&gt;(reference, stamp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Pair记录着对象的引用和版本戳，版本戳为int型，保持自增，同时Pair是一个不可变对象，其所有属性定义都为final，对外提供一个of方法，该方法返回一个新建的Pair对象，pair对象定义为volatile，保证多线程环境下的可见性。在AtomicStampedReference中，大多方法都是通过调用Pair的of方法来产生一个新的Pair对象，然后赋予给变量pair。如set方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void set(V newReference, int newStamp) &#123;</div><div class="line">    Pair&lt;V&gt; current = pair;</div><div class="line">    if (newReference != current.reference || newStamp != current.stamp)</div><div class="line">        this.pair = Pair.of(newReference, newStamp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h5><p>下面我们将通过一个例子可以看到AtomicStampedReference和AtomicInteger的区别。我们定义两个线程，线程1负责将100 -&gt; 110 -&gt; 100，线程2执行100 -&gt; 120，看看两者之间的区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">public class AtomicDemo2 &#123;</div><div class="line">    private static AtomicInteger atomicInteger = new AtomicInteger(100);</div><div class="line">    private static AtomicStampedReference atomicStampedReference = new AtomicStampedReference(100,1);</div><div class="line"></div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        // AtomicInteger</div><div class="line">        Thread at1 = new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                atomicInteger.compareAndSet(100,110);</div><div class="line">                atomicInteger.compareAndSet(110,100);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread at2 = new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(2); // at1，执行完</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(&quot;AtomicInteger: &quot; + atomicInteger.compareAndSet(100,120));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        at1.start();</div><div class="line">        at2.start();</div><div class="line">        at1.join();</div><div class="line">        at2.join();</div><div class="line"></div><div class="line">        // AtomicStampedReference</div><div class="line">        Thread tsf1 = new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    // 让tsf2先获取stamp，导致预期时间戳不一致</div><div class="line">                    TimeUnit.SECONDS.sleep(2);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // 预期引用：100， 更新后的引用110，预期表示getStamp(), 更新后表示：getStamp() + 1</div><div class="line">                atomicStampedReference.compareAndSet(100,110,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() +1);</div><div class="line">                System.out.println(&quot;100 -&gt; 110: &quot; + atomicStampedReference.getStamp());</div><div class="line">                atomicStampedReference.compareAndSet(110,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() +1);</div><div class="line">                System.out.println(&quot;110 -&gt; 100: &quot; + atomicStampedReference.getStamp());</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread tsf2 = new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                int stamp = atomicStampedReference.getStamp();</div><div class="line">                System.out.println(&quot;100 -&gt; 120: &quot; + stamp);</div><div class="line">                </div><div class="line">                // 此处线程休眠，是为了让线程tsf1执行，从而改变版本戳，最后导致atomicStampedReference.compareAndSet()因版本对不上而更新失败；</div><div class="line">                try &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(5);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(&quot;AtomicStampedReference: &quot; + atomicStampedReference.compareAndSet(100,120,stamp,stamp+1));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        tsf1.start();</div><div class="line">        tsf2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AtomicInteger: true</div><div class="line">100 -&gt; 120: 1</div><div class="line">100 -&gt; 110: 2</div><div class="line">110 -&gt; 100: 3</div><div class="line">AtomicStampedReference: false</div></pre></td></tr></table></figure>
<p>运行结果充分展示了AtomicInteger的ABA问题和AtomicStampedReference解决ABA问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;CAS, Compare And Swap，即比较并交换。Doug lea大神在同步组价中大量使用CAS技术鬼斧神工地实现了Java多线程的
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码学习</title>
    <link href="http://jianwl.com/2018/05/16/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/05/16/ConcurrentHashMap源码学习/</id>
    <published>2018-05-16T00:12:00.000Z</published>
    <updated>2018-05-18T00:41:43.555Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>HashMap是我们平时开发过程中用的比较多的集合，它是非线程安全的，涉及到多线程并发的情况，进行get操作有可能会引起死循环「JDK1.8以前」，导致CPU利用率接近100%。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test_001()&#123;</div><div class="line">    final Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</div><div class="line">    IntStream.range(0,1000).forEach(num -&gt; new Thread(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            map.put(UUID.randomUUID().toString(),&quot;&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;).start()</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决方案有HashTable和Collections.synchronizedMap(hashMap),不过两个方案基本上是对读写进行加锁操作，一个线程在读写元素，其余线程必须等待，性能可想而知。</p>
<p>所以，Doug Lea给我们带来了并发安全的CocurrentHashMap,它的实现是依赖于Java内存模型，本文源码是JDK8的版本，与之前的版本有较大差异。</p>
<h3 id="JDK1-7分析"><a href="#JDK1-7分析" class="headerlink" title="JDK1.7分析"></a>JDK1.7分析</h3><p>ConcurrentHashMap采用分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构。其包含两个核心静态内部类Segment和HashEntry。</p>
<ol>
<li>Segment继承ReentrantLock用来充当锁的角色，每个Segment对象守护每个散列映射表的若干个桶。</li>
<li>HashEntry用来封装映射表的键/值对；</li>
<li>每个桶是由若干个HashEntry对象链接起来的链表</li>
</ol>
<p>一个ConcurrentHashMap实例中包含由若干个Segment对象组成的数组。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-16/36278984.jpg" alt=""></p>
<h3 id="JDK1-8-分析"><a href="#JDK1-8-分析" class="headerlink" title="JDK1.8 分析"></a>JDK1.8 分析</h3><p>1.8的实现已经抛弃了Segment分段锁机制，利用CAS + Synchronized来保证并发更新的安全，底层采用数组 + 链表 + 红黑树的存储结构。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-18/3990408.jpg" alt=""></p>
<h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><p>在开始之前，有些重要的概念需要介绍一下：</p>
<p>1、 <code>table</code>: 默认为null,初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方。</p>
<p>2、<code>nextTable</code>: 默认为null,扩容时新生成的数组，其大小为原数组的两倍。</p>
<p>3 、<code>sizeCtl</code>: 默认为0， 用来控制table的初始化和扩容操作，具体应用在后续会体现出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-1 代表table正在初始化</div><div class="line">-N 表示有N-1个线程正在进行扩容操作</div><div class="line">其他情况：</div><div class="line">1. 如果table未初始化，表示table需要初始化的大小；</div><div class="line">2. 如果table初始化完成，表示table的容量，默认是table大小的0.75倍</div></pre></td></tr></table></figure>
<p>4、 Node: 保存key，value及key的hash值的数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">    final int hash;</div><div class="line">    final K key;</div><div class="line">    volatile V val;</div><div class="line">    volatile Node&lt;K,V&gt; next;</div><div class="line">    ... 省略部分代码</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中value和next都用volatile修饰，保证并发的可见性。</p>
<p>5、<code>ForwardingNode:</code> 一个特殊的Node节点，hash值为-1，其中存储nextTable的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</div><div class="line">    final Node&lt;K,V&gt;[] nextTable;</div><div class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</div><div class="line">        super(MOVED, null, null, null);</div><div class="line">        this.nextTable = tab;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有table发生扩容的时候，ForwardingNode才会发生作用，作为一个占位符放在table中表示当前节点为null或已经被移动。</p>
<h4 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h4><p>实例化CocurrentHashMap时带参数时，会根据参数调整table的大小，假设参数为100，最终会调整成256，确保table的大小总是2的幂次方，算法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ConcurrentHashMap&lt;String, String&gt; hashMap = new ConcurrentHashMap&lt;&gt;(100);</div><div class="line">private static final int tableSizeFor(int c) &#123;</div><div class="line">    int n = c - 1;</div><div class="line">    n |= n &gt;&gt;&gt; 1;</div><div class="line">    n |= n &gt;&gt;&gt; 2;</div><div class="line">    n |= n &gt;&gt;&gt; 4;</div><div class="line">    n |= n &gt;&gt;&gt; 8;</div><div class="line">    n |= n &gt;&gt;&gt; 16;</div><div class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，ConcurrentHashMap在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。</p>
<h4 id="table初始化"><a href="#table初始化" class="headerlink" title="table初始化"></a>table初始化</h4><p>前面已经提到过，table初始化操作会延缓到第一次put行为，但是put是可以并发执行的，DougLea是如何实现table只初始化一次的？让我们来看看源码的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; int sc;</div><div class="line">    while ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">//如果一个线程发现sizeCtl&lt;0，意味着另外的线程执行CAS操作成功，当前线程只需要让出cpu时间片</div><div class="line">        if ((sc = sizeCtl) &lt; 0) </div><div class="line">            Thread.yield(); // lost initialization race; just spin</div><div class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</div><div class="line">            try &#123;</div><div class="line">                if ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">                    sc = n - (n &gt;&gt;&gt; 2);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                sizeCtl = sc;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return tab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sizeCtl默认为0，如果ConcurrentHashMap实例化时有传参数，sizeCtl会是一个2的幂次方的值。所以执行第一次put操作的线程会执行<code>Unsafe.compareAndSwapInt</code>方法修改sizeCtl为-1，有且只有一个线程能够修改成功，其他线程通过Thread.yield()让出CPU时间片等待初始化完成。</p>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>假设table已经初始化完成，put操作采用CAS + synchronized实现并发插入或更新操作，具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class="line">    if (key == null || value == null) throw new NullPointerException();</div><div class="line">    int hash = spread(key.hashCode());</div><div class="line">    int binCount = 0;</div><div class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; int n, i, fh;</div><div class="line">        if (tab == null || (n = tab.length) == 0)</div><div class="line">            tab = initTable();</div><div class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class="line">            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class="line">                break;                   // no lock when adding to empty bin</div><div class="line">        &#125;</div><div class="line">        else if ((fh = f.hash) == MOVED)</div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        ...省略部分代码</div><div class="line">    &#125;</div><div class="line">    addCount(1L, binCount);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1、 hash算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static final int spread(int h) &#123;return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;&#125;</div></pre></td></tr></table></figure>
<p>2、table中定位索引位置，n是table的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int index = (n - 1) &amp; hash</div></pre></td></tr></table></figure>
<p>3、获取table中对应索引的元素f。</p>
<p>Doug Lea采用Unsafe.getObjectVolatile来获取，也许有人质疑，直接talbe[index]不可以么，为什么要这么复杂？</p>
<p>在java内存模型中，我们已经知道每个线程都有一个工作内存，里面存储这table的副本，虽然table是volatile修饰的，但是不能保证线程每次都拿到table中的最新元素，Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。</p>
<p>4、如果f为null，说明table中这个位置第一次元素，利用Unsafe.compareAndSwapObject方法插入Node节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">如果CAS成功，说明Node节点已经插入，随后addCount(1L,binCount)方法会检查当前容量是否需要进行扩容。</div><div class="line"></div><div class="line">如果CAS失败，说明有其他线程提前插入了节点，自旋重新尝试在这个位置插入节点。</div></pre></td></tr></table></figure>
<p>5、如果f的hash值为-1，说明当前f是ForwardingNode节点，意味有其他线程正在扩容，则一起进行扩容操作。</p>
<p>6、其余情况把新的Node节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">synchronized (f) &#123;</div><div class="line">    if (tabAt(tab, i) == f) &#123;</div><div class="line">        if (fh &gt;= 0) &#123;</div><div class="line">            binCount = 1;</div><div class="line">            for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                K ek;</div><div class="line">                if (e.hash == hash &amp;&amp;</div><div class="line">                    ((ek = e.key) == key ||</div><div class="line">                     (ek != null &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                    oldVal = e.val;</div><div class="line">                    if (!onlyIfAbsent)</div><div class="line">                        e.val = value;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                Node&lt;K,V&gt; pred = e;</div><div class="line">                if ((e = e.next) == null) &#123;</div><div class="line">                    pred.next = new Node&lt;K,V&gt;(hash, key,</div><div class="line">                                              value, null);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else if (f instanceof TreeBin) &#123;</div><div class="line">            Node&lt;K,V&gt; p;</div><div class="line">            binCount = 2;</div><div class="line">            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                           value)) != null) &#123;</div><div class="line">                oldVal = p.val;</div><div class="line">                if (!onlyIfAbsent)</div><div class="line">                    p.val = value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在节点f上进行同步，节点插入之前，再次利用tabAt(tab,i) == f判断，防止被其他线程修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1、如果f.hash &gt;= 0，说明f是链表结构的头结点，遍历链表，如果找到对应的node节点，则修改value，否则在链表尾部加入节点。</div><div class="line"></div><div class="line">2、如果f是TreeBin类型节点，说明f是红黑树跟节点，则在树结构上遍历元素，更新或增加节点。</div><div class="line"></div><div class="line">3、如果链表中节点数binCount &gt;= TREEIFY_THRESHOLD(默认是8)，则把链表转化为红黑树结构。</div></pre></td></tr></table></figure>
<h4 id="table扩容"><a href="#table扩容" class="headerlink" title="table扩容"></a>table扩容</h4><p>当table容量不足的时候，即table的元素数量达到容量阈值sizeCtl,需要对table进行扩容。</p>
<blockquote>
<p>整个扩容分为两部分：</p>
<p>1、构建一个nextTable，大小为table的两倍</p>
<p>2、把table的数据复制到nextTable中</p>
</blockquote>
<p>这两个过程在单线程实现很简单，但是ConcurrentHashMap是支持并发插入的，扩容操作自然也会有并发的出现，这种情况下，第二步可以支持节点的并发复制，这样性能自然提升不少，但是实现的复杂度也上升了一个台阶。</p>
<p>先看第一步，构建nextTable，毫无疑问，这个过程只能单个线程进行nextTable的初始化，具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private final void addCount(long x, int check) &#123;</div><div class="line">    ... 省略部分代码</div><div class="line">    if (check &gt;= 0) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab, nt; int n, sc;</div><div class="line">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</div><div class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class="line">            int rs = resizeStamp(n);</div><div class="line">            if (sc &lt; 0) &#123;</div><div class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</div><div class="line">                    transferIndex &lt;= 0)</div><div class="line">                    break;</div><div class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</div><div class="line">                    transfer(tab, nt);</div><div class="line">            &#125;</div><div class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</div><div class="line">                transfer(tab, null);</div><div class="line">            s = sumCount();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable,扩容后的数组长度为原来的两倍，但是容量是原来的1.5。</p>
<p>节点是从table移动nextTable，大体思路是遍历、复制的过程。</p>
<p>1、首先根据运算得到遍历的次数i，利用tabAt方法获得i位置的元素f，初始化一个forwardNode实例fwd。</p>
<p>2、如果f == null，则在table中的i位置放入fwd,这个过程是采用Unsafe.compareAndSwapObject方法实现的，很巧妙的实现了节点的并发移动。</p>
<p>3、如果f是链表的头节点，就构造一个反序列链表，把他们分别放在nextTable的i和i+n的位置上，移动完成，采用Unsafe.putObjectVolatile方法给table原位置复制fwd。</p>
<p>4、如果f是TreeBin节点，也做了一个反序处理，并判断是否需要untreeify,把处理的结果分别放在nextTable的i和i+n的位置上，移动完成，同样采用Unsafe.putObjectVolatile方法给table原位置复制fwd。</p>
<p>遍历过所有的节点以后就完成了复制工作，把table指向nextTable，并更新sizeCtl为新数组大小的0.75倍，扩容完成。</p>
<h4 id="红黑树构造"><a href="#红黑树构造" class="headerlink" title="红黑树构造"></a>红黑树构造</h4><p>注意: 如果链表结构中元素超过TREEIFY_THRESHOLD阈值，默认为8个，则把链表转化为红黑树，提高遍历查询效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (binCount != 0) &#123;</div><div class="line">    if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">        treeifyBin(tab, i);</div><div class="line">    if (oldVal != null)</div><div class="line">        return oldVal;</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们看看如何构造树结构，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</div><div class="line">    Node&lt;K,V&gt; b; int n, sc;</div><div class="line">    if (tab != null) &#123;</div><div class="line">        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</div><div class="line">            tryPresize(n &lt;&lt; 1);</div><div class="line">        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123;</div><div class="line">            synchronized (b) &#123;</div><div class="line">                if (tabAt(tab, index) == b) &#123;</div><div class="line">                    TreeNode&lt;K,V&gt; hd = null, tl = null;</div><div class="line">                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123;</div><div class="line">                        TreeNode&lt;K,V&gt; p =</div><div class="line">                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</div><div class="line">                                              null, null);</div><div class="line">                        if ((p.prev = tl) == null)</div><div class="line">                            hd = p;</div><div class="line">                        else</div><div class="line">                            tl.next = p;</div><div class="line">                        tl = p;</div><div class="line">                    &#125;</div><div class="line">                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，生成树节点的代码块是同步的，进入同步代码块之后，再次验证table中index位置元素是否被修改过。</p>
<p>1、根据table中index位置Node链表，重新生成一个hd为头结点的TreeNode链表</p>
<p>2、 根据hd头结点，生成TreeBin树结构，并把树结构的root节点写到table的index位置的内存中，具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</div><div class="line">    super(TREEBIN, null, null, null);</div><div class="line">    this.first = b;</div><div class="line">    TreeNode&lt;K,V&gt; r = null;</div><div class="line">    for (TreeNode&lt;K,V&gt; x = b, next; x != null; x = next) &#123;</div><div class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</div><div class="line">        x.left = x.right = null;</div><div class="line">        if (r == null) &#123;</div><div class="line">            x.parent = null;</div><div class="line">            x.red = false;</div><div class="line">            r = x;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            K k = x.key;</div><div class="line">            int h = x.hash;</div><div class="line">            Class&lt;?&gt; kc = null;</div><div class="line">            for (TreeNode&lt;K,V&gt; p = r;;) &#123;</div><div class="line">                int dir, ph;</div><div class="line">                K pk = p.key;</div><div class="line">                if ((ph = p.hash) &gt; h)</div><div class="line">                    dir = -1;</div><div class="line">                else if (ph &lt; h)</div><div class="line">                    dir = 1;</div><div class="line">                else if ((kc == null &amp;&amp;</div><div class="line">                          (kc = comparableClassFor(k)) == null) ||</div><div class="line">                         (dir = compareComparables(kc, k, pk)) == 0)</div><div class="line">                    dir = tieBreakOrder(k, pk);</div><div class="line">                    TreeNode&lt;K,V&gt; xp = p;</div><div class="line">                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</div><div class="line">                    x.parent = xp;</div><div class="line">                    if (dir &lt;= 0)</div><div class="line">                        xp.left = x;</div><div class="line">                    else</div><div class="line">                        xp.right = x;</div><div class="line">                    r = balanceInsertion(r, x);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    this.root = r;</div><div class="line">    assert checkInvariants(root);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要根据Node节点的hash值大小构建二叉树，这个红黑树的构造过程实在有点复杂，感兴趣的同学可以看看源码。</p>
<h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><p>get操作和put操作相比，显得简单了许多</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</div><div class="line">    int h = spread(key.hashCode());</div><div class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</div><div class="line">        if ((eh = e.hash) == h) &#123;</div><div class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</div><div class="line">                return e.val;</div><div class="line">        &#125;</div><div class="line">        else if (eh &lt; 0)</div><div class="line">            return (p = e.find(h, key)) != null ? p.val : null;</div><div class="line">        while ((e = e.next) != null) &#123;</div><div class="line">            if (e.hash == h &amp;&amp;</div><div class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</div><div class="line">                return e.val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1、判断table是否为空，如果为空，直接返回null<br>2、计算key的hash值，并获取指定table中指定位置的Node节点，通过遍历链表或树结构找到对应节点，返回value值。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ConcurrentHashMap是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相当于HashTable和同步包装器包装的HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一个时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化。</p>
<p>1.6中采用ReentrantLock分段锁的方式，是多个线程在不同的segment上进行写操作，不会发现阻塞行为；1.8中采用内置锁synchronized，难道是因为1.8的虚拟机内置锁已经优化足够快了？</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;HashMap是我们平时开发过程中用的比较多的集合，它是非线程安全的，涉及到多线程并发的情况，进行get操作有可能会引起死循环「JDK1.8
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于「数据库架构」和「查询优化」的分享</title>
    <link href="http://jianwl.com/2018/05/15/%E5%85%B3%E4%BA%8E%E3%80%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E3%80%8D%E5%92%8C%E3%80%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E3%80%8D%E7%9A%84%E5%88%86%E4%BA%AB/"/>
    <id>http://jianwl.com/2018/05/15/关于「数据库架构」和「查询优化」的分享/</id>
    <published>2018-05-14T23:58:14.000Z</published>
    <updated>2018-05-15T13:55:53.491Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>部门技术分享，选了个数据库专题，做完KeyNote，顺便整理成文，方便后续查阅和补充；本次分享囊括数据库架构、存储引擎功能对比、常用InnoDB日志以及InnoDB逻辑储存结构、索引相关和模拟线上并发问题；</p>
<h3 id="1-MySQL体系结构"><a href="#1-MySQL体系结构" class="headerlink" title="1. MySQL体系结构"></a>1. MySQL体系结构</h3><p> <img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/89852452.jpg" alt=""></p>
<p> MySQL由以下几部分组成： 连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、优化器组件、缓冲组件、插件式存储引擎、物理文件。</p>
<p> MySQL数据库与其他数据库不一样的地方，最重要的一点就是其「插件式的表存储引擎」。特别注意，存储引擎是基于表的，而不是数据库。</p>
<h3 id="2-存储引擎功能对比"><a href="#2-存储引擎功能对比" class="headerlink" title="2. 存储引擎功能对比"></a>2. 存储引擎功能对比</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/94396221.jpg" alt=""></p>
<h4 id="2-1-MyISAM"><a href="#2-1-MyISAM" class="headerlink" title="2-1 MyISAM"></a>2-1 MyISAM</h4><p>不支持事务、表锁设计、支持全文索引，主要面向线上分析处理(OLAP)数据库应用。MyISAM另一个与众不同的地方是它的缓冲池只缓存「索引文件」，而不缓存「数据文件」。</p>
<h4 id="2-2-InnoDB"><a href="#2-2-InnoDB" class="headerlink" title="2-2 InnoDB"></a>2-2 InnoDB</h4><p>支持数据、行锁设计、支持B+树索引、哈希索引、全文索引、支持外键，设计目标主要面向在线事务处理(OLTP)应用。InnoDB通过多版本并发控制(MVCC)来获得并发，并且实现SQL标准的4个隔离级别。默认隔离级别是「REPEATABLE-READ」</p>
<h4 id="2-3-NDB"><a href="#2-3-NDB" class="headerlink" title="2-3 NDB"></a>2-3 NDB</h4><p>NDB是个「集群式」存储引擎，其将数据全部放在内存中(MySQL5.1版本开始，可以将索引数据放在磁盘上)，因此通过主键查询速度极快，且通过增加NDB数据存储节点，可以线性提高数据库性能。</p>
<p>有个问题值得注意：NDB存储引擎的连接操作是在MySQL数据库层完成，而不是在存储引擎层完成。这意味着，复杂的连接操作需要巨大的网络开销。</p>
<h4 id="2-4-Memory"><a href="#2-4-Memory" class="headerlink" title="2-4 Memory"></a>2-4 Memory</h4><p>将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据将消失。它非常使用于存储临时数据的临时表。默认使用「哈希索引」</p>
<h4 id="2-5-Archive"><a href="#2-5-Archive" class="headerlink" title="2-5 Archive"></a>2-5 Archive</h4><p>只持此INSERT和SELECT操作，从MySQL5.1开始支持索引。Archive存储引擎使用zlib算法将数据行进行压缩后存储，应用场景主要是「存储归档数据」。</p>
<h4 id="2-6-Federated"><a href="#2-6-Federated" class="headerlink" title="2-6 Federated"></a>2-6 Federated</h4><p>表不存放数据，它只是指向一台远程MySQL数据库服务器上的表。</p>
<h4 id="2-7-Maria"><a href="#2-7-Maria" class="headerlink" title="2-7 Maria"></a>2-7 Maria</h4><p>Maria是新开发的引擎，设计目标是取代原有的MyISAM存储引擎。其特点是: 支持缓存数据和索引文件，应用行锁设计，提供MVCC功能，支持事务和非事务的安全选项，以及更好的BLOB字符类型的处理性能。</p>
<h3 id="3-InnoDB"><a href="#3-InnoDB" class="headerlink" title="3. InnoDB"></a>3. InnoDB</h3><h4 id="3-1-日志文件"><a href="#3-1-日志文件" class="headerlink" title="3-1 日志文件"></a>3-1 日志文件</h4><p>用来记录MySQL实例对某种条件做出响应时写入的文件，如错误日志文件、二进制文件、慢查询日志。</p>
<h5 id="1）错误日志文件"><a href="#1）错误日志文件" class="headerlink" title="1）错误日志文件"></a>1）错误日志文件</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/248741.jpg" alt=""></p>
<p>可以得到错误日志文件在本地存储的位置；</p>
<h5 id="2）慢查询日志文件"><a href="#2）慢查询日志文件" class="headerlink" title="2）慢查询日志文件"></a>2）慢查询日志文件</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/83986237.jpg" alt=""></p>
<p>默认情况下，慢查询日志不是开启的，通过slow_query_log查看，如果未开启，需要通过以下命令开启。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set global slow_query_log = ON</div></pre></td></tr></table></figure>
<p>long_query_time是查询时间超过这个值，就认为是慢查询；slow_query_log_file是慢查询在本地存储的位置。</p>
<h5 id="3）二进制文件"><a href="#3）二进制文件" class="headerlink" title="3）二进制文件"></a>3）二进制文件</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/8138280.jpg" alt=""></p>
<p>二进制文件记录了MySQL数据库执行更改的所有操作，不包括SELECT 和 SHOW这类操作，因为这类操作对数据本身没有修改。</p>
<h4 id="3-2-逻辑存储结构"><a href="#3-2-逻辑存储结构" class="headerlink" title="3-2 逻辑存储结构"></a>3-2 逻辑存储结构</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/22066716.jpg" alt=""></p>
<p>存储引擎是基于表，所有数据都被逻辑存放在一个空间，称为表空间(tableSpace)。表空间又由段(segment)、区(extent)和页(page)组成。</p>
<h5 id="1-表空间"><a href="#1-表空间" class="headerlink" title="1) 表空间"></a>1) 表空间</h5><p>用于存放数据、索引和插入缓冲页；</p>
<h5 id="2-段"><a href="#2-段" class="headerlink" title="2) 段"></a>2) 段</h5><p>表空间由各个段组成，常见的段有数据段、索引段、回滚段；</p>
<h5 id="3）区"><a href="#3）区" class="headerlink" title="3）区"></a>3）区</h5><p>区是由连续页组成，在任何情况下每个区的大小都是1MB。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4 ~ 5个区，在默认情况下, 页的大小为16K，即一个区有64个连续的页。</p>
<h4 id="3-3-由慢查询引发的思考"><a href="#3-3-由慢查询引发的思考" class="headerlink" title="3-3 由慢查询引发的思考"></a>3-3 由慢查询引发的思考</h4><h5 id="1-什么是慢查询？"><a href="#1-什么是慢查询？" class="headerlink" title="1) 什么是慢查询？"></a>1) 什么是慢查询？</h5><p>Innodb会设置<code>long_query_time</code>参数，查询时间超过这个数值，则判定这个查询为慢查询；</p>
<h5 id="2）如何解决慢查询？"><a href="#2）如何解决慢查询？" class="headerlink" title="2）如何解决慢查询？"></a>2）如何解决慢查询？</h5><p>从三个层面上解决，① 优化查询本身；② 调优表包括增加索引； ③ 调优服务器</p>
<h6 id="优化查询本身"><a href="#优化查询本身" class="headerlink" title="优化查询本身"></a>优化查询本身</h6><p> ① 是否向数据请求了不需要的数据；② 大查询切分为小查询；③ 分解关联查询，可增加缓存命中概率；</p>
<h6 id="优化表"><a href="#优化表" class="headerlink" title="优化表"></a>优化表</h6><p>① 创建表时字段够用就好，越小越好；② 字段不能为空, 字段加索引需要额外空间，含NULL的复合索引无效；③ 加索引，后文会详细接受；</p>
<h6 id="调优服务器"><a href="#调优服务器" class="headerlink" title="调优服务器"></a>调优服务器</h6><p>调节缓冲区参数；</p>
<h5 id="3）联合索引"><a href="#3）联合索引" class="headerlink" title="3）联合索引"></a>3）联合索引</h5><h6 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h6><p>① 联合索引，最左匹配原则；</p>
<h6 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h6><p>① <code>=</code>可以向后传递 ② <code>in</code>如果后面是<code>=</code>或<code>in</code>可以传递 ③ <code>&gt;</code>、<code>&lt;</code>、<code>GROUP BY</code>、<code>ORDER BY</code>、<code>LIKE</code>不向后传递；</p>
<h5 id="4）索引原理"><a href="#4）索引原理" class="headerlink" title="4）索引原理"></a>4）索引原理</h5><p>索引是用B+树的数据结构；B+树包含「索引页」和「数据页」；索引页为非叶子节点，不存数据，只存指向；数据页为叶子节点，只存数据；B+树有一些特性：① 左树小于中间数；② 右树大于中间数；③ 数据页之间是通过双向链表连接的；</p>
<h6 id="B-树插入3种情况"><a href="#B-树插入3种情况" class="headerlink" title="B+树插入3种情况"></a>B+树插入3种情况</h6><p>① 叶子节点(数据页)和非叶子节点(索引页)都未满，插入数据直接插入到叶子节点；（插入28）</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/77745979.jpg" alt=""></p>
<p>② 非叶子节点未满，叶子节点满了；拆分叶子节点，将中间的节点放入Index Page中，小于中间节点的记录放左边，大于或等于中间节点的记录放右边；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/66912616.jpg" alt=""></p>
<p>③ 叶子节点和非叶子节点都满了；拆分叶子节点，小于中间节点的记录放左边，大于或等于中间节点的记录放右边，拆分Index Page，小于中间节点的记录放左边，大于中间节点的记录放右边，中间节点放上一层Index Page。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/30209172.jpg" alt=""></p>
<h4 id="3-4-模拟并发问题"><a href="#3-4-模拟并发问题" class="headerlink" title="3-4 模拟并发问题"></a>3-4 模拟并发问题</h4><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `parent` (</div><div class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</div><div class="line">  PRIMARY KEY (`id`)</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=67 DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure>
<h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><p>1) 客户端1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">insert into parent values(2);</div><div class="line"></div><div class="line">select * from parent;</div><div class="line"></div><div class="line">update parent set id = sleep(30) where id = 2;</div></pre></td></tr></table></figure>
<p>2) 客户端2</p>
<p>因为行锁，以下SQL耗时27.55秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update parent set id = 22 where id = 2;</div></pre></td></tr></table></figure>
<p>3) 客户端3</p>
<p>查看当前执行的线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show processlist \G;</div></pre></td></tr></table></figure>
<h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>1）客户端1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">insert into parent values(3);</div><div class="line"></div><div class="line">begin;</div><div class="line"></div><div class="line">update parent set id = 33 where id = 3;</div></pre></td></tr></table></figure>
<p>2) 客户端2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select * from parent;</div><div class="line"></div><div class="line">begin;</div><div class="line"></div><div class="line">update parent set id = 333 where id = 3;</div></pre></td></tr></table></figure>
<p>3) 客户端3</p>
<p>查看事务情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show engine innodb status \G;</div></pre></td></tr></table></figure>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>1) 客户端1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">begin; // 步骤1</div><div class="line">insert into parent values(4); // 步骤2</div><div class="line">update parent set id = 5 where id = 4; // 步骤5</div></pre></td></tr></table></figure>
<p>2) 客户端2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">begin；// 步骤3</div><div class="line">insert into parent values(5); // 步骤4</div><div class="line">update parent set id = 4 where id = 5; // 步骤6</div></pre></td></tr></table></figure>
<p>3) 客户端</p>
<p>查看死锁情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show engine innodb status \G;</div></pre></td></tr></table></figure>
<h3 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h3><ol>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" target="_blank" rel="external">执行计划explain各个参数含义</a></li>
<li>MySQL排查指南</li>
<li>InnoDB存储引擎</li>
<li>高性能MySQL</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;部门技术分享，选了个数据库专题，做完KeyNote，顺便整理成文，方便后续查阅和补充；本次分享囊括数据库架构、存储引擎功能对比、常用Inno
    
    </summary>
    
      <category term="MYSQL" scheme="http://jianwl.com/categories/MYSQL/"/>
    
    
      <category term="MYSQL" scheme="http://jianwl.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>Thread源码学习</title>
    <link href="http://jianwl.com/2018/05/04/Thread%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/05/04/Thread源码学习/</id>
    <published>2018-05-03T22:47:52.000Z</published>
    <updated>2018-05-04T00:19:01.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Thread内部有个State枚举，表示线程的状态"><a href="#1、Thread内部有个State枚举，表示线程的状态" class="headerlink" title="1、Thread内部有个State枚举，表示线程的状态"></a>1、Thread内部有个State枚举，表示线程的状态</h3><ul>
<li>NEW, 新建未开始</li>
<li>RUNNABLE，可执行，但他可能处于等待系统资源状态，因为CPU此时别其他线程占用；</li>
<li>BLOCKED，阻塞状态，等待一个monitor lock，在调用wait方法后，进入synchronized同步块或方法</li>
<li>WAITING, 等待状态，调用以下方法导致进入等待状态，object.wait()、Thread.join()、LockSupport.park()</li>
<li>TIMED_WAITING, 带超时时间的等待，调用以下方法会处于这个状态 Thread.sleep()、Object.wait()、Thread.join()、LockSupport.parkNanos()、LockSupport.parkUntil()</li>
<li>TERMINATED, 终止状态</li>
</ul>
<p>2、接着看下Thread的构造函数及其他几个相关的成员变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">/* 带目标run对象. */</div><div class="line">   private Runnable target;</div><div class="line"></div><div class="line">   /* 线程组 */</div><div class="line">   private ThreadGroup group;</div><div class="line">   </div><div class="line">   /* 此线程的类加载器 */</div><div class="line">   private ClassLoader contextClassLoader;</div><div class="line">   </div><div class="line">   /* 想要的栈大小，为0时此参数被忽略，且有VM不支持此参数 */</div><div class="line">    private long stackSize;</div><div class="line">    </div><div class="line">   /* 状态标识，0代表新建未开始*/</div><div class="line">   private volatile int threadStatus = 0;</div><div class="line">   </div><div class="line">   /* 静态native方法，返回当前线程*/</div><div class="line">   public static native Thread currentThread();</div><div class="line"></div><div class="line"></div><div class="line">   public Thread() &#123;</div><div class="line">       init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</div><div class="line">   &#125;</div><div class="line">   public Thread(Runnable target) &#123;</div><div class="line">       init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);</div><div class="line">   &#125;</div><div class="line">    Thread(Runnable target, AccessControlContext acc) &#123;</div><div class="line">       init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0, acc);</div><div class="line">   &#125;</div><div class="line">    public Thread(ThreadGroup group, Runnable target) &#123;</div><div class="line">       init(group, target, &quot;Thread-&quot; + nextThreadNum(), 0);</div><div class="line">   &#125;</div><div class="line">    public Thread(String name) &#123;</div><div class="line">       init(null, null, name, 0);</div><div class="line">   &#125;</div><div class="line">   public Thread(ThreadGroup group, String name) &#123;</div><div class="line">       init(group, null, name, 0);</div><div class="line">   &#125;</div><div class="line">   public Thread(Runnable target, String name) &#123;</div><div class="line">       init(null, target, name, 0);</div><div class="line">   &#125;</div><div class="line">   public Thread(ThreadGroup group, Runnable target, String name) &#123;</div><div class="line">       init(group, target, name, 0);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   /**</div><div class="line">    * Initializes a Thread.</div><div class="line">    *</div><div class="line">    * @param g 线程组</div><div class="line">    * @param target 要执行的带run的目标对象</div><div class="line">    * @param name 线程名</div><div class="line">    * @param stackSize 新线程的栈大小，等于0时可忽略此参数</div><div class="line">    * @param acc 接入控制上下文</div><div class="line">    */</div><div class="line">   private void init(ThreadGroup g, Runnable target, String name,</div><div class="line">                     long stackSize, AccessControlContext acc) &#123;</div><div class="line">       if (name == null) &#123;</div><div class="line">           throw new NullPointerException(&quot;name cannot be null&quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       this.name = name;</div><div class="line"></div><div class="line">       Thread parent = currentThread();</div><div class="line">       SecurityManager security = System.getSecurityManager();</div><div class="line">       //获取线程组</div><div class="line">       if (g == null) &#123;</div><div class="line"></div><div class="line">           /* 从SecurityManager拿线程组  */</div><div class="line">           if (security != null) &#123;</div><div class="line">               g = security.getThreadGroup();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           /* 如果还没拿到从当前线程拿*/</div><div class="line">           if (g == null) &#123;</div><div class="line">               g = parent.getThreadGroup();</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /* 检查是否可获取 */</div><div class="line">       g.checkAccess();</div><div class="line"></div><div class="line">       /*</div><div class="line">        * 还是权限控制检查</div><div class="line">        */</div><div class="line">       if (security != null) &#123;</div><div class="line">           if (isCCLOverridden(getClass())) &#123;</div><div class="line">               security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       g.addUnstarted();</div><div class="line"></div><div class="line">       this.group = g;</div><div class="line">       this.daemon = parent.isDaemon();</div><div class="line">       this.priority = parent.getPriority();</div><div class="line">       if (security == null || isCCLOverridden(parent.getClass()))</div><div class="line">           this.contextClassLoader = parent.getContextClassLoader();</div><div class="line">       else</div><div class="line">           this.contextClassLoader = parent.contextClassLoader;</div><div class="line">       this.inheritedAccessControlContext =</div><div class="line">               acc != null ? acc : AccessController.getContext();</div><div class="line">       this.target = target;</div><div class="line">       setPriority(priority);</div><div class="line">       //从父线程继承可继承的ThreadLocal</div><div class="line">       if (parent.inheritableThreadLocals != null)</div><div class="line">           this.inheritableThreadLocals =</div><div class="line">               ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</div><div class="line">     </div><div class="line">       this.stackSize = stackSize;</div><div class="line"></div><div class="line">       /* 设置线程ID */</div><div class="line">       tid = nextThreadID();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>不同的构造函数很多，最终都调init方法，init主要实现的就是把相应的参数放入成员变量里，线程ID为自增长方式；</p>
<h3 id="3、调用线程执行的主方法start与run方法"><a href="#3、调用线程执行的主方法start与run方法" class="headerlink" title="3、调用线程执行的主方法start与run方法"></a>3、调用线程执行的主方法start与run方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/* 线程启动方法 */</div><div class="line"> public synchronized void start() &#123;</div><div class="line">        /**</div><div class="line">         * 如果线程不是NEW状态，则抛异常</div><div class="line">         */</div><div class="line">        if (threadStatus != 0)</div><div class="line">            throw new IllegalThreadStateException();</div><div class="line"></div><div class="line">        /*</div><div class="line">        通知线程组此线程准备运行里，所以它可以加入到线程组列表中，线程组的未开始数量可以减少了 */</div><div class="line">        group.add(this);</div><div class="line"></div><div class="line">        boolean started = false;</div><div class="line">        try &#123;</div><div class="line">            start0();</div><div class="line">            started = true;</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (!started) &#123;</div><div class="line">                    group.threadStartFailed(this);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">                /*什么都不做，如果start0排除一个异常，它已经可以被调用栈知道 */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private native void start0();</div></pre></td></tr></table></figure>
<p>特别注意：start方法会创建一个新的线程，之后在执行run方法里的逻辑；而run方法只会在当前线程中执行逻辑；</p>
<h3 id="4、join方法-等待线程挂掉的方法"><a href="#4、join方法-等待线程挂掉的方法" class="headerlink" title="4、join方法, 等待线程挂掉的方法"></a>4、join方法, 等待线程挂掉的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/*如果这个线程还活着就一直等待*/</div><div class="line"> public final void join() throws InterruptedException &#123;</div><div class="line">        join(0);</div><div class="line">    &#125;</div><div class="line">/*如果这个线程还活着就一直等待millis时间*/</div><div class="line">public final synchronized void join(long millis)</div><div class="line">    throws InterruptedException &#123;</div><div class="line">        long base = System.currentTimeMillis();</div><div class="line">        long now = 0;</div><div class="line"></div><div class="line">        if (millis &lt; 0) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (millis == 0) &#123;</div><div class="line">            while (isAlive()) &#123;</div><div class="line">                wait(0);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            while (isAlive()) &#123;</div><div class="line">                long delay = millis - now;</div><div class="line">                if (delay &lt;= 0) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                wait(delay);</div><div class="line">                now = System.currentTimeMillis() - base;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过自旋方法检验线程是否活着，如果活着，则wait释放锁；</p>
<h3 id="5、sleep方法，native实现，会抛出InterruptedException"><a href="#5、sleep方法，native实现，会抛出InterruptedException" class="headerlink" title="5、sleep方法，native实现，会抛出InterruptedException"></a>5、sleep方法，native实现，会抛出InterruptedException</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* 睡眠指定毫秒，并不释放monitor*/</div><div class="line">public static native void sleep(long millis) throws InterruptedException;</div></pre></td></tr></table></figure>
<h3 id="6、yield方法"><a href="#6、yield方法" class="headerlink" title="6、yield方法"></a>6、yield方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/*使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了*/</div><div class="line">public static native void yield();</div></pre></td></tr></table></figure>
<h3 id="7、interrupted-方法与isInterrupted方法的区别？"><a href="#7、interrupted-方法与isInterrupted方法的区别？" class="headerlink" title="7、interrupted()方法与isInterrupted方法的区别？"></a>7、interrupted()方法与isInterrupted方法的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static boolean interrupted() &#123;</div><div class="line">    return currentThread().isInterrupted(true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean isInterrupted() &#123;</div><div class="line">    return isInterrupted(false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码上看，这两个方法都是调用<code>isInterrupted(boolean ClearInterrupted)</code>,只不过一个带的参数是true，另一个带的参数是false;</p>
<p>所以他们之间的区别是：</p>
<p>1、<code>interrupted</code>方法会清除中断标识符，<code>isInterrupted</code>方法不会清除中断标识符；</p>
<p>2、<code>interrupted</code>测试的是当前线程的中断状态，<code>isInterrupted</code>测试的是调用该方法对象所表示的线程。</p>
<p>3、<code>interrupted</code>为静态方法，Thread对象调用，<code>isInterrupted</code>为普通方法，Thread实例化对象调用</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、Thread内部有个State枚举，表示线程的状态&quot;&gt;&lt;a href=&quot;#1、Thread内部有个State枚举，表示线程的状态&quot; class=&quot;headerlink&quot; title=&quot;1、Thread内部有个State枚举，表示线程的状态&quot;&gt;&lt;/a&gt;1、Thr
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL索引原理</title>
    <link href="http://jianwl.com/2018/04/24/MYSQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
    <id>http://jianwl.com/2018/04/24/MYSQL索引原理/</id>
    <published>2018-04-24T09:51:23.000Z</published>
    <updated>2018-04-24T15:27:55.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-索引目的"><a href="#1-索引目的" class="headerlink" title="1. 索引目的"></a>1. 索引目的</h3><p>索引的目的在于提高查询效率，可以类比字典，如果要查<code>mysql</code>这个单词，我们肯定需要定位到m字母，然后从往下找到y字母，再找到剩下的sql。如果没有索引，那么你很可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p>
<h3 id="2-索引原理"><a href="#2-索引原理" class="headerlink" title="2. 索引原理"></a>2. 索引原理</h3><p>除了字典，生活中随处可见索引的例子，如火车站的车次表，图书的目录等，他们的原理都是一样的，通过不断的缩小想要获得的范围来筛选出最终想要的结果，同时把随机事件变成顺序的时间，也就是我们总是通过同一种查找方式来锁定数据。</p>
<p>数据库也是一样，但显然要复杂许多，因为不仅面临这等值查询、还有范围查询(<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>in</code>)、模糊查询(like)、并集查询(or)等。数据库应该选择怎么样的方式来应对所有问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段、201到300分成第三段…这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但是如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN,具有不错的查询性能。但这里我们忽略一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p>
<h3 id="3-磁盘IO和预读"><a href="#3-磁盘IO和预读" class="headerlink" title="3. 磁盘IO和预读"></a>3. 磁盘IO和预读</h3><p>前面提高了访问磁盘，那么这里先简单介绍一些磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分、寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们常说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是1秒转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错，但要知道一台500 - MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万数据，每次9毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图，供大家参考；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-24/44660032.jpg" alt=""></p>
<p>考虑到磁盘IO是非常高昂的操作计算机操作系统做了一些优化，当一次IO是，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<h3 id="4-索引的数据结构"><a href="#4-索引的数据结构" class="headerlink" title="4. 索引的数据结构"></a>4. 索引的数据结构</h3><p>前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有他的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足要求呢？就这样，b+树应运而生。</p>
<h3 id="5-详解B-树"><a href="#5-详解B-树" class="headerlink" title="5. 详解B+树"></a>5. 详解B+树</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-24/6850674.jpg" alt=""></p>
<p>如上图，是一颗B+树，这里只说一些重点，浅蓝色的块我们称之为磁盘块，可以看到每个磁盘块包含几个数据项(深蓝色所示)和指针(黄色所示)，如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示17和35之间的磁盘块，P3表示大于35的磁盘块，真实的数据存于<strong>叶子节点</strong>即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<h4 id="B-树的查找过程"><a href="#B-树的查找过程" class="headerlink" title="B+树的查找过程"></a>B+树的查找过程</h4><p>如图所示，如果要查找数据项是29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分法查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短(相比磁盘的IO)可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘块8加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的B+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总计共需要百万次IO，显然成本非常高。</p>
<h4 id="B-树性质"><a href="#B-树性质" class="headerlink" title="B+树性质"></a>B+树性质</h4><p>1、通过上面的分析，我们知道IO次数取决于B+数的高度H，假设当前数据表的数据为N，每个磁盘块的数据项的数据是m，则有h=log(m+1)N,当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段尽量要小，比如int占4字节，要比bigint8字节少一半，这也是为什么B+树要求吧真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时，会将退化成线性表。</p>
<p>2、 当B+树的数据项是符合的数据，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三，20，F)这样的数据来检索的时候，B+树会优先比较name来确定下一步的搜索方向，如果name相同再一次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，B+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才知道下一步去哪里查询。比如当(张三，F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后在匹配性别F的数据了，这个是非常重要的性质，即索引最左匹配特性。</p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>1、 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a、b、c、d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<p>2、 = 和 in 可以乱序，比如 a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>
<p>3、 尽量寻找区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录越少，唯一键的区分度是1，而一些状态，性别字段可能在大数据面前区分度就是0，一般需要join的字段我们要求是0.1以上，平均1条扫描10条记录</p>
<p>4、 索引项不能参与计算，保持干净列，比如 from_unixtime(create_time) = ‘2018-04-20’就不能使用索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(‘2018-04-20’)</p>
<p>5、 尽量的扩展索引，不要新建索引，比如表中已经有a的索引，现在要加(a,b)索引，那么只需要修改原来的索引即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-索引目的&quot;&gt;&lt;a href=&quot;#1-索引目的&quot; class=&quot;headerlink&quot; title=&quot;1. 索引目的&quot;&gt;&lt;/a&gt;1. 索引目的&lt;/h3&gt;&lt;p&gt;索引的目的在于提高查询效率，可以类比字典，如果要查&lt;code&gt;mysql&lt;/code&gt;这个单词，我们肯定
    
    </summary>
    
      <category term="MYSQL" scheme="http://jianwl.com/categories/MYSQL/"/>
    
    
      <category term="MYSQL" scheme="http://jianwl.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码学习</title>
    <link href="http://jianwl.com/2018/04/19/ThreadLocal%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/19/ThreadLocal源码学习/</id>
    <published>2018-04-18T22:44:09.000Z</published>
    <updated>2018-04-22T23:00:00.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段"><a href="#常用方法-amp-字段" class="headerlink" title="常用方法 &amp; 字段"></a>常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-19/34870755.jpg" alt=""></p>
<h3 id="1、使用ThreadLocal的好处"><a href="#1、使用ThreadLocal的好处" class="headerlink" title="1、使用ThreadLocal的好处"></a>1、使用ThreadLocal的好处</h3><p>可以实现多线程，变量间互不干扰；举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class ThreadLocalDemo &#123;</div><div class="line">    public static class MyTask implements Runnable&#123;</div><div class="line">        private ThreadLocal&lt;Double&gt; threadLocal = new ThreadLocal&lt;&gt;();</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            threadLocal.set(Math.random());</div><div class="line">            System.out.println(String.format(&quot;thread name : %s, threadlocal: %.2f&quot;,Thread.currentThread().getName(), threadLocal.get()));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MyTask task = new MyTask();</div><div class="line">        new Thread(task,&quot;测试线程1&quot;).start();</div><div class="line">        new Thread(task,&quot;测试线程2&quot;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">thread name : 测试线程2, threadlocal: 0.38</div><div class="line">thread name : 测试线程1, threadlocal: 0.85</div></pre></td></tr></table></figure>
<p>由结果可以看出，每个线程的变量是独立互不干扰的，如果把<code>ThreadLocal</code>换成Double等其他对象，每个线程的变量结果应该是一样的。</p>
<h3 id="2、提出问题"><a href="#2、提出问题" class="headerlink" title="2、提出问题"></a>2、提出问题</h3><ol>
<li>ThreadLocal为多线程共享变量，如何实现变量在多线程中互不干扰的？set()，get()</li>
<li>每个线程变量的存储方式，ThreadLocalMap</li>
<li>ThreadLocalMap是如何解决Hash冲突的；</li>
<li>ThreadLocal放置在Entry数组的索引位置，如何确定；</li>
<li>什么场景下会发生内存泄露，如何防止内存泄露；</li>
<li>为什么ThreadLocalMap是一个Entry数组的数据结构？明明一个threadlocal在一个线程中只能存入一个值；</li>
</ol>
<h4 id="1）如何实现变量在多线程中互不干扰的"><a href="#1）如何实现变量在多线程中互不干扰的" class="headerlink" title="1）如何实现变量在多线程中互不干扰的"></a>1）如何实现变量在多线程中互不干扰的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public void set(T value) &#123;</div><div class="line">    Thread t = Thread.currentThread(); // 获取当前线程</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value); </div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ThreadLocalMap getMap(Thread t) &#123;</div><div class="line">    return t.threadLocals;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public T get() &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">        if (e != null) &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            T result = (T)e.value;</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，每个线程中都有一个<code>ThreadLocalMap</code>数据结构，当执行set方法时，其值是保存在当前线程的<code>threadLocals</code>变量中，当执行get方法时，是从当前线程的<code>threadLocals</code>变量获取的，所以线程1中set的值，对线程2来说是拿不到的，而且在线程2中重新set的话，也不会影响到线程1中的值，保证了线程之间不会相互干扰；</p>
<p>那每个线程中的<code>ThreadLocalMap</code>究竟是什么？</p>
<h4 id="2）-每个线程变量的存储方式，ThreadLocalMap"><a href="#2）-每个线程变量的存储方式，ThreadLocalMap" class="headerlink" title="2） 每个线程变量的存储方式，ThreadLocalMap"></a>2） 每个线程变量的存储方式，ThreadLocalMap</h4><p>从名字上看，可以猜到它也是一个类似<code>HashMap</code>的数据结构，但是在ThreadLocal中，并没实现Map接口。</p>
<p>在ThreadLocalMap中，也是初始化一个大小16的Entry数组，Entry对象用来保存每一个key-value键值对，只不过这里的key永远都是ThreadLocal对象，通过ThreadLocal的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLocalMap中。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-23/56990974.jpg" alt=""></p>
<p>这里需要注意的是，ThreadLocalMap的Entry继承WeakReference和HashMap很大的区别是，Entry中没有next字段，所以就不存在链表的情况；</p>
<h4 id="3）Hash冲突"><a href="#3）Hash冲突" class="headerlink" title="3）Hash冲突"></a>3）Hash冲突</h4><p>没有链表结构，那发生Hash冲突了怎么办？</p>
<p>先看看ThreadLocalMap中插入一个key-value的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</div><div class="line">   Entry[] tab = table;</div><div class="line">   int len = tab.length;</div><div class="line">   int i = key.threadLocalHashCode &amp; (len-1);</div><div class="line"></div><div class="line">   for (Entry e = tab[i];</div><div class="line">         e != null;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">         ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">         if (k == key) &#123;</div><div class="line">             e.value = value;</div><div class="line">             return;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          if (k == null) &#123;</div><div class="line">              replaceStaleEntry(key, value, i);</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tab[i] = new Entry(key, value);</div><div class="line">    int sz = ++size;</div><div class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">          rehash();</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>每个ThreadLocal对象都有一个hash值<code>threadLocalHashCode</code>, <strong>每初始化一个ThreadLocal对象，hash值就增加一个固定的大小0x61c88647</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private final int threadLocalHashCode = nextHashCode();</div><div class="line"></div><div class="line">private static AtomicInteger nextHashCode =</div><div class="line">    new AtomicInteger();</div><div class="line">    </div><div class="line">private static final int HASH_INCREMENT = 0x61c88647;</div><div class="line"></div><div class="line">private static int nextHashCode() &#123;</div><div class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-ThreadLocal如何定位到Entry数组的索引位的"><a href="#4-ThreadLocal如何定位到Entry数组的索引位的" class="headerlink" title="4) ThreadLocal如何定位到Entry数组的索引位的"></a>4) ThreadLocal如何定位到Entry数组的索引位的</h4><p>在插入过程中，根据ThreadLocal对象的Hash值，定位到table中的位置i，过程如下：</p>
<p>1、如果当前位置是空的，那么正好，就初始化一个Entry对象放置位置i上，位置i通过threadlocal的hashcode与table的长度的取余得到；</p>
<p>2、不巧，位置i已经有Entry对象了，如果这个Entry对象的key正好是即将设置的key，那么重新设置Entry中的value；</p>
<p>3、很不巧，位置i的Entry对象和即将设置的key没有关系，那么只能找到下一个空位置；</p>
<p>这样的话，在get的时候，也会根据ThreadLocal对象的hash值，定位table中的位置，然后判断位置Entry中的key是否和get的key一致，如果不一致，就判断下一个位置。</p>
<p>可以发现，set和get如果冲突严重的话，效率很低，因为ThreadLocalMap是Thread的一个属性，所以即使在自己的代码中控制了设置的元素个数，但还是不能控制其代码的行为；</p>
<h4 id="5）内存泄露"><a href="#5）内存泄露" class="headerlink" title="5）内存泄露"></a>5）内存泄露</h4><p>ThreadLocal可能导致内存泄露，为什么？</p>
<p>先看看Entry的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;     Object value;</div><div class="line">     Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">         super(k);</div><div class="line">         value = v;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过之前的分析已经知道，当使用ThreadLocal保存一个value时，会在ThreadLocalMap中的数组插入一个Entry对象，按理说key-value都应该以强引用保存在Entry对象中，但在ThreadLocalMap的实现中，key被保存到了WeakReference对象中。</p>
<p>这就导致了一个问题，ThreadLocal在没有外部强引用是，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露；</p>
<h5 id="如何避免内存泄露"><a href="#如何避免内存泄露" class="headerlink" title="如何避免内存泄露"></a>如何避免内存泄露</h5><p>既然已经发现有内存泄露的隐患，自然有应对的策略，在调用ThreadLocal的get()、set()可能会清楚ThreadLocalMap中key为null的Entry对象，这样对应的value就没有GC Roots可达了，下次GC的时候就可以被回收，当然如果调用remove方法，肯定会删除对应的Entry对象；</p>
<p>如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test_002()&#123;</div><div class="line">    ThreadLocal&lt;String&gt; hello = new ThreadLocal&lt;&gt;();</div><div class="line">    try &#123;</div><div class="line">        hello.set(&quot;Hello World!&quot;);</div><div class="line">    &#125;finally &#123;</div><div class="line">        hello.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-为什么ThreadLocalMap是一个Entry数组的数据结构？"><a href="#6-为什么ThreadLocalMap是一个Entry数组的数据结构？" class="headerlink" title="6. 为什么ThreadLocalMap是一个Entry数组的数据结构？"></a>6. 为什么ThreadLocalMap是一个Entry数组的数据结构？</h4><p>我们知道，每个线程都有一个ThreadLocalMap；之前一直困扰为什么它的数据结构是Entry数组，而不是Entry对象呢？</p>
<p>因为同一个线程中，可以设置多个ThreadLocal，每个threadLocal都会存入到线程的ThreadLocalMap对象中，所以是Entry数组的数据结构；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor线程池源码学习</title>
    <link href="http://jianwl.com/2018/04/18/ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/18/ThreadPoolExecutor线程池源码学习/</id>
    <published>2018-04-18T00:24:37.000Z</published>
    <updated>2018-04-18T01:10:06.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-使用线程池的好处"><a href="#1-使用线程池的好处" class="headerlink" title="1. 使用线程池的好处"></a>1. 使用线程池的好处</h3><p>合理利用线程池能够带来三个好处。</p>
<p>① 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</p>
<p>② 提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
<p>③ 提高线程的可管理性。线程时稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h3 id="2-线程池的工作原理"><a href="#2-线程池的工作原理" class="headerlink" title="2. 线程池的工作原理"></a>2. 线程池的工作原理</h3><p>首先我们看下当一个新的任务提交到线程池之后，线程池是如何处理的；</p>
<p>① 线程池判断核心线程池里的线程是否都在执行任务；如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步；</p>
<p>② 线程池判断工作队列是否已经满。如果工作队列已经满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步；</p>
<p>③ 线程池判断线程池的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务</p>
<h4 id="线程池饱和策略"><a href="#线程池饱和策略" class="headerlink" title="线程池饱和策略"></a>线程池饱和策略</h4><p>这里提到了线程池的饱和策略，那我们就简单介绍下有哪些饱和策略</p>
<table>
<thead>
<tr>
<th style="text-align:center">策略类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AbortPolicy</td>
<td style="text-align:center">直接抛出异常，线程池默认处理策略；切记ThreadPoolExecutor.execute需要try catch，否则程序会直接退出</td>
</tr>
<tr>
<td style="text-align:center">DiscardPolicy</td>
<td style="text-align:center">不处理，丢弃掉</td>
</tr>
<tr>
<td style="text-align:center">DiscardOldestPolicy</td>
<td style="text-align:center">丢弃队里里最近一个任务，并执行当前任务</td>
</tr>
<tr>
<td style="text-align:center">CallerRusPolicy</td>
<td style="text-align:center">只用调用者所在线程来运行任务</td>
</tr>
<tr>
<td style="text-align:center">自定义策略</td>
<td style="text-align:center">可以根据引用场景需要来实现RejectedExecutionHandler接口自定义策略，如记录日志或持久化不能处理的任务</td>
</tr>
</tbody>
</table>
<h3 id="3-线程池工作流程图"><a href="#3-线程池工作流程图" class="headerlink" title="3. 线程池工作流程图"></a>3. 线程池工作流程图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-12/20324843.jpg" alt=""></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-12/82099386.jpg" alt=""></p>
<p>① 如果当前运行的线程小于corePoolSize,则创建新线程来执行任务（注意执行这一步需要获取全局锁）</p>
<p>② 如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue；</p>
<p>③ 如果BlockingQueue队列已满，则在非corePool中创建新的线程来处理任务（注意执行这一步需要获取全局锁）</p>
<p>④ 如果创建新线程将使当前运行的线程超出maximumPoolSize,任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</p>
<h3 id="4-线程池的使用"><a href="#4-线程池的使用" class="headerlink" title="4. 线程池的使用"></a>4. 线程池的使用</h3><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><p>我们可以通过ThreadPoolExecutor来创建一个线程池；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds, runnableTaskQueue,threadFactory, handler);</div></pre></td></tr></table></figure>
<p>创建一个线程池需要输入几个参数：</p>
<h5 id="1）corePoolSize（线程池的基本大小）"><a href="#1）corePoolSize（线程池的基本大小）" class="headerlink" title="1）corePoolSize（线程池的基本大小）"></a>1）corePoolSize（线程池的基本大小）</h5><p>当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程池</p>
<h5 id="2）runnableTaskQueue（任务队列）"><a href="#2）runnableTaskQueue（任务队列）" class="headerlink" title="2）runnableTaskQueue（任务队列）"></a>2）runnableTaskQueue（任务队列）</h5><p>用于保存等待执行的任务的阻塞队列，可以选择一下几个阻塞队列</p>
<p>① ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO(先进先出)原则对元素进行排序；</p>
<p>② LinkedBlockingQueue: 一个基于链表结构的阻塞队列，此队列按FIFO(先进先出)排序元素，吞吐量通常高于ArrayBlockingQueue，静态工厂方法Executors.newFixedThreadPool()使用这个队列</p>
<p>③ SyschronousQueue: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常高于LinkedBlockingQueue，静态工作方法 Executors.newCachedThreadPool使用这个队列；</p>
<p>④ PriorityBlockingQueue： 一个具有优先级的无限阻塞队列；</p>
<h5 id="3）maxmumPoolSize（线程池最大大小）"><a href="#3）maxmumPoolSize（线程池最大大小）" class="headerlink" title="3）maxmumPoolSize（线程池最大大小）"></a>3）maxmumPoolSize（线程池最大大小）</h5><p>线程池允许创建的最大线程数，如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的队列这个参数就没有效果了；</p>
<h5 id="4-ThreadFactory"><a href="#4-ThreadFactory" class="headerlink" title="4) ThreadFactory"></a>4) ThreadFactory</h5><p>用于设置创建线程工厂，可以通过线程工厂给创建出来的线程设置有语义的名字</p>
<h5 id="5）RejectedExecutionHandler（饱和策略）"><a href="#5）RejectedExecutionHandler（饱和策略）" class="headerlink" title="5）RejectedExecutionHandler（饱和策略）"></a>5）RejectedExecutionHandler（饱和策略）</h5><p>参考上述步骤2中的，饱和策略分析</p>
<h5 id="6）keepAliveTime（线程活动保持时间）"><a href="#6）keepAliveTime（线程活动保持时间）" class="headerlink" title="6）keepAliveTime（线程活动保持时间）"></a>6）keepAliveTime（线程活动保持时间）</h5><p>大于corePool(线程池基本大小)的空闲工作线程，保持存活的时间<strong>(在存活时间内，如果没有接受新任务，就会被销毁)</strong>。如果任务很多，每个任务执行的时间比较短，可以调整这个时间，提高线程的利用率；</p>
<h5 id="7）TimeUnit（线程活动保持时间的单位）"><a href="#7）TimeUnit（线程活动保持时间的单位）" class="headerlink" title="7）TimeUnit（线程活动保持时间的单位）"></a>7）TimeUnit（线程活动保持时间的单位）</h5><p>可选单位有天(DAYS)、小时(HOURS)、分钟(MINUTES)、毫秒(MILLISECONDS)、微秒(MICROSECONDS)</p>
<h3 id="5-源码分析"><a href="#5-源码分析" class="headerlink" title="5. 源码分析"></a>5. 源码分析</h3><h4 id="1）提问"><a href="#1）提问" class="headerlink" title="1）提问"></a>1）提问</h4><p>1、线程池新增任务的流程；execute(Runnable command)</p>
<p>2、线程池如何实现，在RUNING状态下，接受新任务，且处理队列里的任务；在SHUTDOWN状态下，不接受新任务，但处理新任务的 ;以及在STOP、TIDYING和TERMINATE状态下的处理方式；</p>
<p>3、线程池如何处理新增任务时，出现异常的；addWorkerFailed(Worker w)</p>
<p>4、线程池如何实现关闭的；</p>
<h5 id="1-1-execute-Runnable-command"><a href="#1-1-execute-Runnable-command" class="headerlink" title="1-1) execute(Runnable command)"></a>1-1) execute(Runnable command)</h5><p><code>execute</code>方法三个主要步骤：① 活动线程小于<code>corePoolSize</code>的时候创建新的线程；②活动线程大于<code>corePoolSize</code>先加入到任务队列当中；③ 任务队列满了再去启动新的线程，如果线程数达到最大值就拒绝任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void execute(Runnable command) &#123; </div><div class="line">    if (command == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">  </div><div class="line">    int c = ctl.get();</div><div class="line"></div><div class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        if (addWorker(command, true))</div><div class="line">            return;</div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        int recheck = ctl.get();</div><div class="line"></div><div class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line"></div><div class="line">        else if (workerCountOf(recheck) == 0)</div><div class="line">            addWorker(null, false);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    else if (!addWorker(command, false))</div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第 5 行：ctl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</div></pre></td></tr></table></figure>
<p><code>ThreadPoolExecutor</code>用这一变量保存了两个内容：① 所有有效线程数量「workerCount」② 线程池运行状态「runState」; 低29位存<code>workerCounter</code>，高3位存<code>runState</code>, 这样<code>runState</code>有5个值；</p>
<ul>
<li>RUNNING: -1 &lt;&lt; 29</li>
<li>SHOTDOWN: 0 &lt;&lt; 29</li>
<li>STOP: 1 &lt;&lt; 29</li>
<li>TIDYING: 2 &lt;&lt; 29</li>
<li>TERMINATED: 3 &lt;&lt; 29</li>
</ul>
<p>线程池各状态转换比较复杂，记住下面内容就可以了：</p>
<ul>
<li>RUNNING状态：线程池正常运行，可以接受新的任务并处理队列中的任务；</li>
<li>SHUTDOWN状态：不再接受新的任务，但是会执行队列中的任务；</li>
<li>STOP状态：不再接受新任务，不处理队列中的任务，中断正在进行中的任务；</li>
<li>TIDYING: 所有任务都已关闭，有效线程数为0，将运行<code>terminated()</code>钩子方法；</li>
<li>TERMINATED: <code>terminated()</code>方法执行完毕；</li>
</ul>
<p>第 7 行：当有效线程数 小于 核心线程数时；</p>
<p><code>workerCountOf(ctl.get())</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private static final int COUNT_BITS = 29;</div><div class="line"></div><div class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</div><div class="line"></div><div class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</div></pre></td></tr></table></figure>
<p>ctl的低29位存着有效线程数，通过 <code>c &amp; 00011111111111111111111111111</code>的方式得到<code>有效线程数</code></p>
<p>第 8 行：线程池有效线程数小于核心线程数时，新增任务成功，则退出；</p>
<p>源码中：<code>Worker类</code>、<code>addWorkerFailed()方法</code>在后文继续分析</p>
<p><code>addWorker(command,true)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</div><div class="line">    retry:</div><div class="line">    for (;;) &#123;</div><div class="line">        int c = ctl.get();</div><div class="line">        int rs = runStateOf(c); // 当前线程池状态</div><div class="line"></div><div class="line">        // 线程池状态为：SHUTDOWN STOP TIDYING TERMINATED 均不在接受新任务；</div><div class="line">        // 但是当状态为SHUTDOWN时，若此时队列不为空，为了保证队列中的任务能够被执行完；</div><div class="line">        // SHUTDOWN时通过addWoker(null,false)方法,新增有效线程数；「执行addWorker(null,false)，此时workerCounter == 0」</div><div class="line">        // 所以当线程池的状态为SHUTDOWN，firstTask == null，队列不为空时，将继续往下执行；</div><div class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">            ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">               firstTask == null &amp;&amp;</div><div class="line">               ! workQueue.isEmpty()))</div><div class="line">            return false;</div><div class="line"></div><div class="line">        for (;;) &#123;</div><div class="line">            int wc = workerCountOf(c); // 有效线程数</div><div class="line"></div><div class="line">            if (wc &gt;= CAPACITY ||</div><div class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                return false;</div><div class="line"></div><div class="line">            if (compareAndIncrementWorkerCount(c)) // 原子操作递增workerCount</div><div class="line">                break retry; // 操作成功跳出重试循环</div><div class="line">            c = ctl.get();  // Re-read ctl</div><div class="line">            if (runStateOf(c) != rs) // 如果线程池的状态发生变化则重试</div><div class="line">                continue retry;</div><div class="line">            // else CAS failed due to workerCount change; retry inner loop</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // workerCount递增成功</div><div class="line">    boolean workerStarted = false;</div><div class="line">    boolean workerAdded = false;</div><div class="line">    Worker w = null;</div><div class="line">    try &#123;</div><div class="line">        w = new Worker(firstTask);</div><div class="line">        final Thread t = w.thread;</div><div class="line">        if (t != null) &#123;</div><div class="line">            final ReentrantLock mainLock = this.mainLock;</div><div class="line">            // 并发的访问线程池workers对象必须加锁</div><div class="line">            mainLock.lock();</div><div class="line">            try &#123;</div><div class="line">                // Recheck while holding lock.</div><div class="line">                // Back out on ThreadFactory failure or if</div><div class="line">                // shut down before lock acquired.</div><div class="line">                int rs = runStateOf(ctl.get());</div><div class="line"></div><div class="line">                // RUNNING 状态 || SHUTDOWN状态下清理队列中剩余的任务</div><div class="line">                if (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</div><div class="line">                    if (t.isAlive()) // precheck that t is startable</div><div class="line">                        throw new IllegalThreadStateException();</div><div class="line">                    // 将线程放到线程列表中</div><div class="line">                    workers.add(w);</div><div class="line">                    int s = workers.size();</div><div class="line">                    if (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = true;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            // 启动新添加的线程，这个线程首先执行firstTask，然后不停的从队列中取任务执行；</div><div class="line">            if (workerAdded) &#123;</div><div class="line">                t.start(); // 最终执行的是ThreadPoolExecutor的runWorker方法</div><div class="line">                workerStarted = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        // 线程启动失败，则从workers中移除w并递减workerCount</div><div class="line">        if (! workerStarted)</div><div class="line">            // 递减workerCount会触发tryTerminate方法</div><div class="line">            addWorkerFailed(w);</div><div class="line">    &#125;</div><div class="line">    return workerStarted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第13 ~ 21行：</p>
<p><code>runState</code>为RUNNING状态且队列未满，双重检查，再次获取线程池ctl，判断当前线程池状态；若线程池为非RUNNING状态，则从workQueue中移除任务，并执行线程池拒绝任务策略；若当前有效线程数为0，则添加一个空任务到队列里；「理由是：当线程池状态为SHUTDOWN时，若队列不为空，有效线程数为0，需要通过添加空任务的方法，增加有效线程数」</p>
<p>第 23 ~ 25行：</p>
<p>① 线程池非RUNNING状态，拒绝新任务，执行拒绝策略 ② 队列满了且当且有效线程数大于最大线程数时，执行拒绝策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final void reject(Runnable command) &#123;</div><div class="line">    handler.rejectedExecution(command, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-2-Worker"><a href="#1-2-Worker" class="headerlink" title="1-2 Worker"></a>1-2 Worker</h5><p>任务添加成功后，实际执行的是runWorker(this)的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">private final class Worker</div><div class="line">    extends AbstractQueuedSynchronizer</div><div class="line">    implements Runnable</div><div class="line">&#123;</div><div class="line">    private static final long serialVersionUID = 6138294804551838833L;</div><div class="line"></div><div class="line">    final Thread thread;</div><div class="line"></div><div class="line">    Runnable firstTask;</div><div class="line"></div><div class="line">    volatile long completedTasks;</div><div class="line"></div><div class="line">    Worker(Runnable firstTask) &#123;</div><div class="line">        setState(-1); // inhibit interrupts until runWorker</div><div class="line">        this.firstTask = firstTask;</div><div class="line">        this.thread = getThreadFactory().newThread(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void run() &#123;</div><div class="line">        runWorker(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean isHeldExclusively() &#123;</div><div class="line">        return getState() != 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean tryAcquire(int unused) &#123;</div><div class="line">        if (compareAndSetState(0, 1)) &#123;</div><div class="line">            setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean tryRelease(int unused) &#123;</div><div class="line">        setExclusiveOwnerThread(null);</div><div class="line">        setState(0);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void lock()        &#123; acquire(1); &#125;</div><div class="line">    public boolean tryLock()  &#123; return tryAcquire(1); &#125;</div><div class="line">    public void unlock()      &#123; release(1); &#125;</div><div class="line">    public boolean isLocked() &#123; return isHeldExclusively(); &#125;</div><div class="line"></div><div class="line">    void interruptIfStarted() &#123;</div><div class="line">        Thread t;</div><div class="line">        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;</div><div class="line">            try &#123;</div><div class="line">                t.interrupt();</div><div class="line">            &#125; catch (SecurityException ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第 20 行：runWorker简单来说做了两件事：</p>
<p>① 第一次启动会执行传进来的任务firstTask;</p>
<p>② 如果firstTask为空，则从workQueue中取任务，如果队列为空则等待<code>keepAliveTime</code>这么长的时间；</p>
<p>runWorker的核心代码为第10行代码中的<code>getTask()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">final void runWorker(Worker w) &#123;</div><div class="line">        Thread wt = Thread.currentThread();</div><div class="line">        Runnable task = w.firstTask;</div><div class="line">        w.firstTask = null;</div><div class="line">        // 任务被锁住了，需要解锁才能被中断？「这个解释需要验证」</div><div class="line">        w.unlock(); // allow interrupts</div><div class="line">        boolean completedAbruptly = true;</div><div class="line">        try &#123;</div><div class="line">            // 先执行firstTask，若firstTask为空，则从队列里取任务执行；</div><div class="line">            while (task != null || (task = getTask()) != null) &#123;</div><div class="line">                w.lock();</div><div class="line">                if ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                     (Thread.interrupted() &amp;&amp;</div><div class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                    !wt.isInterrupted())</div><div class="line">                    wt.interrupt();</div><div class="line">                try &#123;</div><div class="line">                    // 任务执行前可以插入一些处理、子类重载该方法</div><div class="line">                    beforeExecute(wt, task);</div><div class="line">                    Throwable thrown = null;</div><div class="line">                    try &#123;</div><div class="line">                        task.run(); // 执行用户任务</div><div class="line">                    &#125; catch (RuntimeException x) &#123;</div><div class="line">                        thrown = x; throw x;</div><div class="line">                    &#125; catch (Error x) &#123;</div><div class="line">                        thrown = x; throw x;</div><div class="line">                    &#125; catch (Throwable x) &#123;</div><div class="line">                        thrown = x; throw new Error(x);</div><div class="line">                    &#125; finally &#123;</div><div class="line">                        // 和beforeExecute一样，留给子类去重载；</div><div class="line">                        afterExecute(task, thrown);</div><div class="line">                    &#125;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    task = null;</div><div class="line">                    w.completedTasks++;</div><div class="line">                    w.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            completedAbruptly = false;</div><div class="line">        &#125; finally &#123;</div><div class="line">            // 结束线程的一些清理工作</div><div class="line">            processWorkerExit(w, completedAbruptly);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="1-3-runWorker-中的getTask-方法"><a href="#1-3-runWorker-中的getTask-方法" class="headerlink" title="1-3 runWorker()中的getTask()方法"></a>1-3 runWorker()中的getTask()方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private Runnable getTask() &#123;</div><div class="line">    boolean timedOut = false; // Did the last poll() time out?</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line">        int c = ctl.get();</div><div class="line">        int rs = runStateOf(c);</div><div class="line"></div><div class="line">        // SHUTDOWN状态：队列不为空，不接受新任务，但有队列中的任务需要执行；</div><div class="line">        // Check if queue empty only if necessary.</div><div class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">            decrementWorkerCount();</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int wc = workerCountOf(c);</div><div class="line"></div><div class="line">        // Are workers subject to culling?</div><div class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">        // timed == false 不允许核心线程超时，即使核心线程处于闲置装填也不会被回收；</div><div class="line">        // timed == true 允许核心线程超时,只要核心线程处于闲置状态就会被回收;</div><div class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</div><div class="line">            if (compareAndDecrementWorkerCount(c))</div><div class="line">                return null;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            Runnable r = timed ?</div><div class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                workQueue.take();</div><div class="line">            if (r != null)</div><div class="line">                return r;</div><div class="line">            timedOut = true;</div><div class="line">        &#125; catch (InterruptedException retry) &#123;</div><div class="line">            timedOut = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-4-addWorkerFailed"><a href="#1-4-addWorkerFailed" class="headerlink" title="1-4 addWorkerFailed"></a>1-4 addWorkerFailed</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private void addWorkerFailed(Worker w) &#123;</div><div class="line">    final ReentrantLock mainLock = this.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    try &#123;</div><div class="line">        if (w != null)</div><div class="line">            workers.remove(w); // 移除任务</div><div class="line">        decrementWorkerCount(); // 递减workerCount</div><div class="line">        tryTerminate();</div><div class="line">    &#125; finally &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在addWorker时，出现异常时，需要做回滚操作，① 将任务从队列中移除； ② 将有效线程数减1 ③ 因为有效线程数发生变化了，所有需要尝试调用<code>tryTerminate</code>来终止线程池;</p>
<p><code>tryTerminate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">final void tryTerminate() &#123;</div><div class="line">    for (;;) &#123;</div><div class="line">        int c = ctl.get();</div><div class="line">        // 以下状态直接返回</div><div class="line">        // 1. 线程池还处于RUNNING状态</div><div class="line">        // 2. runState &gt;= TIDYING 线程池已经停止了或正在停止了</div><div class="line">        // 3. SHUTDOWN状态但队列非空</div><div class="line">        if (isRunning(c) ||</div><div class="line">            runStateAtLeast(c, TIDYING) ||</div><div class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</div><div class="line">            return;</div><div class="line"></div><div class="line">        // workerCount不为0，则还不能停止线程池，</div><div class="line">        if (workerCountOf(c) != 0) &#123; // Eligible to terminate</div><div class="line">            // ONLY_ONE: 只需中断1个线程去处理shutdown信号就可以了；</div><div class="line">            interruptIdleWorkers(ONLY_ONE);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final ReentrantLock mainLock = this.mainLock;</div><div class="line">        mainLock.lock();</div><div class="line">        try &#123;</div><div class="line">            // 进入TIDYING状态</div><div class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</div><div class="line">                try &#123;</div><div class="line">                    // 子类重载：一些资源清理工作</div><div class="line">                    terminated();</div><div class="line">                &#125; finally &#123;</div><div class="line">                    // TERMINATED状态</div><div class="line">                    ctl.set(ctlOf(TERMINATED, 0));</div><div class="line">                    // 进行awaitTermination</div><div class="line">                    termination.signalAll();</div><div class="line">                &#125;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line">        // else retry on failed CAS</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-5-关闭线程池shutdown"><a href="#1-5-关闭线程池shutdown" class="headerlink" title="1-5 关闭线程池shutdown"></a>1-5 关闭线程池shutdown</h5><p>shutdown这个方法会将<code>runState</code>置为SHUTDOWN，会终止所有空闲的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void shutdown() &#123;</div><div class="line">    final ReentrantLock mainLock = this.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    try &#123;</div><div class="line">        checkShutdownAccess();</div><div class="line">        // 线程池状态设为SHUTDOWN，如果已经至少是这个状态那么则直接返回</div><div class="line">        advanceRunState(SHUTDOWN);</div><div class="line">        // 注意这里是中断所有空闲的线程：runWorker中等待的线程被中断 → 进入processWorkerExit →</div><div class="line">        // tryTerminate方法中会保证队列中剩余的任务得到执行。</div><div class="line">        interruptIdleWorkers();</div><div class="line">        onShutdown(); // hook for ScheduledThreadPoolExecutor</div><div class="line">    &#125; finally &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">    tryTerminate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-使用线程池的好处&quot;&gt;&lt;a href=&quot;#1-使用线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;1. 使用线程池的好处&quot;&gt;&lt;/a&gt;1. 使用线程池的好处&lt;/h3&gt;&lt;p&gt;合理利用线程池能够带来三个好处。&lt;/p&gt;
&lt;p&gt;① 降低资源消耗。通过重
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>StringBuilder源码学习</title>
    <link href="http://jianwl.com/2018/04/02/StringBuilder%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/02/StringBuilder源码学习/</id>
    <published>2018-04-02T14:06:55.000Z</published>
    <updated>2018-04-04T00:39:36.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段"><a href="#常用方法-amp-字段" class="headerlink" title="常用方法 &amp; 字段"></a>常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-3/88149991.jpg" alt=""></p>
<p>StringBuilder常用于单线程字符串的拼接，可以减小堆内存的开销；</p>
<p>StringBuilder继承<code>AbstractStringBuilder</code>抽象类，且实现了<code>CharSequence</code>、<code>Serializable</code>接口</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>通过append方法拼接字符串，为什么能够减少内存的开销呢，append();</li>
<li>StringBuffer和StringBuilder有什么区别？</li>
</ol>
<h4 id="1-如何拼接字符串"><a href="#1-如何拼接字符串" class="headerlink" title="1) 如何拼接字符串"></a>1) 如何拼接字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">    @Override</div><div class="line">    public StringBuilder append(String str) &#123;</div><div class="line">        super.append(str);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// AbstractStringBuilder类   </div><div class="line">    public AbstractStringBuilder append(String str) &#123;</div><div class="line">        if (str == null)</div><div class="line">            return appendNull();</div><div class="line">        int len = str.length();</div><div class="line">        ensureCapacityInternal(count + len);</div><div class="line">        str.getChars(0, len, value, count);</div><div class="line">        count += len;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private AbstractStringBuilder appendNull() &#123;</div><div class="line">        int c = count;</div><div class="line">        ensureCapacityInternal(c + 4);</div><div class="line">        final char[] value = this.value;</div><div class="line">        value[c++] = &apos;n&apos;;</div><div class="line">        value[c++] = &apos;u&apos;;</div><div class="line">        value[c++] = &apos;l&apos;;</div><div class="line">        value[c++] = &apos;l&apos;;</div><div class="line">        count = c;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line">      </div><div class="line">    private void ensureCapacityInternal(int minimumCapacity) &#123;</div><div class="line">        // overflow-conscious code</div><div class="line">        if (minimumCapacity - value.length &gt; 0)</div><div class="line">            expandCapacity(minimumCapacity);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void expandCapacity(int minimumCapacity) &#123;</div><div class="line">        int newCapacity = value.length * 2 + 2;</div><div class="line">        if (newCapacity - minimumCapacity &lt; 0)</div><div class="line">            newCapacity = minimumCapacity;</div><div class="line">        if (newCapacity &lt; 0) &#123;</div><div class="line">            if (minimumCapacity &lt; 0) // overflow</div><div class="line">                throw new OutOfMemoryError();</div><div class="line">            newCapacity = Integer.MAX_VALUE;</div><div class="line">        &#125;</div><div class="line">        value = Arrays.copyOf(value, newCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// Arrays类</div><div class="line">    public static char[] copyOf(char[] original, int newLength) &#123;</div><div class="line">        char[] copy = new char[newLength];</div><div class="line">        System.arraycopy(original, 0, copy, 0,</div><div class="line">                         Math.min(original.length, newLength));</div><div class="line">        return copy;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">// String类</div><div class="line">    public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123;</div><div class="line">        if (srcBegin &lt; 0) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcBegin);</div><div class="line">        &#125;</div><div class="line">        if (srcEnd &gt; value.length) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd);</div><div class="line">        &#125;</div><div class="line">        if (srcBegin &gt; srcEnd) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</div><div class="line">        &#125;</div><div class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="1、拼接元素为null"><a href="#1、拼接元素为null" class="headerlink" title="1、拼接元素为null"></a>1、拼接元素为null</h5><p>第 9 ~ 10 行：如果拼接字符串为<code>null值</code>，则拼接<code>null</code>字符串；</p>
<p>第 20 行：确保当前字符数组数量加4，小于字符数组长度，否则扩容；</p>
<p>第 36 ~ 45行: 执行扩容；新容量为当前字符数组长度的2倍 + 2；如果新容量仍然小于，实际字符数量，则新容量等于实际字符数量；如果新容量溢出，则新容量赋值为Integer.MAX_VALUE;将原字符数组，赋值到扩容后的数组中；</p>
<p>第 49 ~ 53行：新建容量为扩容后的长度的字符数组，将原数组元素赋值到新数组中;</p>
<h5 id="2-新增元素不为null"><a href="#2-新增元素不为null" class="headerlink" title="2 新增元素不为null"></a>2 新增元素不为null</h5><p>第 11 ~12行: 获取新增字符串的长度，确保当前字符数量 + 新增字符串长度，在字符数组容量范围内，否则执行扩容；</p>
<p>第 13行: 将新增字符串转为字符数组，将其赋值到当前字符数组中实际元素的尾部，具体如图所示；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-4/53045816.jpg" alt=""></p>
<h5 id="3-为什么可以减少堆内存的开销？"><a href="#3-为什么可以减少堆内存的开销？" class="headerlink" title="3 为什么可以减少堆内存的开销？"></a>3 为什么可以减少堆内存的开销？</h5><p>因为字符串是不可变类，每次通过new的方式创建一个不同的字符串，都会在堆内存开辟一个空间；而通过StringBuilder的append方式拼接字符串，只会开辟一个字符数组内存空间，拼接的字符串将添加到字符数组中；从而减少了堆内存的开销；</p>
<h4 id="2）StringBuffer和StringBuilder有什么区别"><a href="#2）StringBuffer和StringBuilder有什么区别" class="headerlink" title="2）StringBuffer和StringBuilder有什么区别"></a>2）StringBuffer和StringBuilder有什么区别</h4><p>StringBuffer是线程安全的，在拼接元素方法中添加了同步锁；其他实现方式与StringBuilder一致；这里就不再赘述了；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">    @Override</div><div class="line">    public synchronized StringBuffer append(String str) &#123;</div><div class="line">        toStringCache = null;</div><div class="line">        super.append(str);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">// AbstractStringBuilder类</div><div class="line">    public AbstractStringBuilder append(String str) &#123;</div><div class="line">        if (str == null)</div><div class="line">            return appendNull();</div><div class="line">        int len = str.length();</div><div class="line">        ensureCapacityInternal(count + len);</div><div class="line">        str.getChars(0, len, value, count);</div><div class="line">        count += len;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void ensureCapacityInternal(int minimumCapacity) &#123;</div><div class="line">        // overflow-conscious code</div><div class="line">        if (minimumCapacity - value.length &gt; 0)</div><div class="line">            expandCapacity(minimumCapacity);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void expandCapacity(int minimumCapacity) &#123;</div><div class="line">        int newCapacity = value.length * 2 + 2;</div><div class="line">        if (newCapacity - minimumCapacity &lt; 0)</div><div class="line">            newCapacity = minimumCapacity;</div><div class="line">        if (newCapacity &lt; 0) &#123;</div><div class="line">            if (minimumCapacity &lt; 0) // overflow</div><div class="line">                throw new OutOfMemoryError();</div><div class="line">            newCapacity = Integer.MAX_VALUE;</div><div class="line">        &#125;</div><div class="line">        value = Arrays.copyOf(value, newCapacity);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line"> // String类</div><div class="line">     public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123;</div><div class="line">        if (srcBegin &lt; 0) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcBegin);</div><div class="line">        &#125;</div><div class="line">        if (srcEnd &gt; value.length) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd);</div><div class="line">        &#125;</div><div class="line">        if (srcBegin &gt; srcEnd) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</div><div class="line">        &#125;</div><div class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>String源码学习</title>
    <link href="http://jianwl.com/2018/04/01/String%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/01/String源码学习/</id>
    <published>2018-04-01T04:32:28.000Z</published>
    <updated>2018-04-01T05:59:09.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>从一段代码说起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void stringTest()&#123;</div><div class="line">    String str1 = &quot;a&quot; + &quot;b&quot; + 1;</div><div class="line">    String str2 = &quot;ab1&quot;;</div><div class="line">    System.out.println(str1 == str2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大家猜猜结果如何？如果你的结论是<code>true</code>，再来一段代码；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void stringTest2()&#123;</div><div class="line">    String str1 = new String(&quot;ab1&quot;);</div><div class="line">    String str2 = &quot;ab1&quot;;</div><div class="line">    System.out.println(str1 == str2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如何呢？正确答案是false。</p>
<p>让我们看看经过编译器编译后的代码如何：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 第一段代码</div><div class="line">    public static void stringTest()&#123;</div><div class="line">        String str1 = &quot;ab1&quot;;</div><div class="line">        String str2 = &quot;ab1&quot;;</div><div class="line">        System.out.println(str1 == str2);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">// 第二段代码  </div><div class="line">    public static void stringTest2()&#123;</div><div class="line">        String str1 = new String(&quot;ab1&quot;);</div><div class="line">        String str2 = &quot;ab1&quot;;</div><div class="line">        System.out.println(str1 == str2);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>也就是说第一段代码经过了编译器优化，原因是编译器发现”a”+”b”+1和”ab1”的效果一样，都是不可变量组成，但是为什么他们的内存地址会相同呢？如果你对此还有兴趣，那就一起来看看String类源码；</p>
<h3 id="1-String类"><a href="#1-String类" class="headerlink" title="1 String类"></a>1 String类</h3><p>String类被<code>final</code>所修饰，也就是说String对象是不可变类。String类实现了<code>Serializable</code>、<code>Comparable&lt;String&gt;</code>、<code>CharSequence</code>接口。</p>
<p>Comparable接口有compareTo(String s)方法，CharSequence接口有lengh()、chatAt(int index)、subSequence(int start,int end)方法。</p>
<h3 id="2-String属性"><a href="#2-String属性" class="headerlink" title="2 String属性"></a>2 String属性</h3><p>String类中包含一个不可变的char数组来存放字符串，一个int型的变量hash用来存放计算后的哈希值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/** The value is used for character storage. */</div><div class="line">private final char value[];</div><div class="line"></div><div class="line">/** Cache the hash code for the string */</div><div class="line">private int hash; // Default to 0</div></pre></td></tr></table></figure>
<h3 id="3-String构造函数"><a href="#3-String构造函数" class="headerlink" title="3 String构造函数"></a>3 String构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//不含参数的构造函数，一般没什么用，因为value是不可变量</div><div class="line">    public String() &#123;</div><div class="line">        this.value = &quot;&quot;.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> </div><div class="line">//参数为String类型</div><div class="line">    public String(String original) &#123;</div><div class="line">        this.value = original.value;</div><div class="line">        this.hash = original.hash;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// 声明编码类型    </div><div class="line">    public String(byte bytes[], Charset charset) &#123;</div><div class="line">        this(bytes, 0, bytes.length, charset);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">//参数为char数组，使用java.utils包中的Arrays类复制</div><div class="line">    public String(char value[]) &#123;</div><div class="line">        this.value = Arrays.copyOf(value, value.length);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">//从bytes数组中的offset位置开始，将长度为length的字节，以charsetName格式编码，拷贝到value</div><div class="line">    public String(byte bytes[], int offset, int length, Charset charset) &#123;</div><div class="line">        if (charset == null)</div><div class="line">            throw new NullPointerException(&quot;charset&quot;);</div><div class="line">        checkBounds(bytes, offset, length);</div><div class="line">        this.value =  StringCoding.decode(charset, bytes, offset, length);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="4-String-常用方法"><a href="#4-String-常用方法" class="headerlink" title="4 String 常用方法"></a>4 String 常用方法</h3><h4 id="1-equals"><a href="#1-equals" class="headerlink" title="1) equals()"></a>1) equals()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object anObject) &#123;</div><div class="line">    // 如果引用的是同一个对象，则为真</div><div class="line">    if (this == anObject) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (anObject instanceof String) &#123;</div><div class="line">        String anotherString = (String)anObject;</div><div class="line">        int n = value.length;</div><div class="line">        if (n == anotherString.value.length) &#123;</div><div class="line">            char v1[] = value;</div><div class="line">            char v2[] = anotherString.value;</div><div class="line">            int i = 0;</div><div class="line">            // 比较每一个字符是否相等</div><div class="line">            while (n-- != 0) &#123;</div><div class="line">                if (v1[i] != v2[i])</div><div class="line">                    return false;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>equals方法经常用得到，它用来判断两个对象内容是否相等，String对象判断流程：</p>
<blockquote>
<p>内存地址相同，则为真</p>
<p>如果对象类型不是String类型，则为假；否则继续判断</p>
<p>如果对象长度不相等，则为假，否则继续判断。</p>
<p>从后往前，判断String类中的char数组value的单个字符是否相等，有不相等则为假，如果一直相等直到一个数，则返回真。</p>
<p>由此可以看出，如果对两个超长的字符进行比较还是比较费时间的。</p>
</blockquote>
<h4 id="2-compareTo"><a href="#2-compareTo" class="headerlink" title="2) compareTo"></a>2) compareTo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public int compareTo(String anotherString) &#123;</div><div class="line">    // 自身字符串的长度</div><div class="line">    int len1 = value.length;</div><div class="line"></div><div class="line">    // 比较字符串的长度</div><div class="line">    int len2 = anotherString.value.length;</div><div class="line"></div><div class="line">    // 获取两个字符串的最小长度</div><div class="line">    int lim = Math.min(len1, len2);</div><div class="line">    char v1[] = value;</div><div class="line">    char v2[] = anotherString.value;</div><div class="line"></div><div class="line">    // 从头往后遍历，如果相同位置的字符不相等，则进行比较字符大小；</div><div class="line">    int k = 0;</div><div class="line">    while (k &lt; lim) &#123;</div><div class="line">        char c1 = v1[k];</div><div class="line">        char c2 = v2[k];</div><div class="line">        if (c1 != c2) &#123;</div><div class="line">            return c1 - c2;</div><div class="line">        &#125;</div><div class="line">        k++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 如果前面都相等，就等于当前字符长度 减去 比较字符长度</div><div class="line">    return len1 - len2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法写的很巧妙，先从0开始判断字符大小，如果两个对象能比较字符的地方比较完了还相等，就直接返回自身长度减比较对象长度，如果两个字符串长度相同，则返回0，巧妙地判断了三种情况。</p>
<h4 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3) hashCode()"></a>3) hashCode()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public int hashCode() &#123;</div><div class="line">    int h = hash;</div><div class="line">    if (h == 0 &amp;&amp; value.length &gt; 0) &#123;</div><div class="line">        char val[] = value;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</div><div class="line">            h = 31 * h + val[i];</div><div class="line">        &#125;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div><div class="line">    return h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>String类重写了hashCode方法，Object中的hashCode方法是一个Native调动。String类的hash采用多项式计算。不同的字符串，hashcode是有可能相同的。</p>
<h4 id="4-intern"><a href="#4-intern" class="headerlink" title="4) intern()"></a>4) intern()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public native String intern();</div></pre></td></tr></table></figure>
<p>intern方法是Native调用，它的作用是在方法区中的常量池里通过equals方法寻找字面值相等的对象，如果没有找到则在常量池中开辟一片空间存放字符串并返回字符串引用，否则直接返回常量池中已存在String对象的引用。</p>
<p>将引言中第二段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// String a = new String(&quot;ab1&quot;);</div><div class="line">// 改为</div><div class="line">String a = new String(&quot;ab1&quot;).intern();</div></pre></td></tr></table></figure>
<p>则结果为<code>true</code>，原因在于a所指向的地址来源于常量池，而b所指向的字符串默认会调用这个方法，所以a和b都指向同一个地址。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;从一段代码说起&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hashtable源码学习</title>
    <link href="http://jianwl.com/2018/03/29/Hashtable%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/29/Hashtable源码学习/</id>
    <published>2018-03-28T22:55:24.000Z</published>
    <updated>2018-03-29T23:37:47.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段"><a href="#常用方法-amp-字段" class="headerlink" title="常用方法 &amp; 字段"></a>常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-30/94194717.jpg" alt=""></p>
<p>Hashtable底层是一个数组 + 链表的数据结构，与HashMap的区别在于，其是线程安全、插入的键值对均不能为空、插入元素时，若发生哈希碰撞，Hashtable是从头结点插入，而HashMap1.8版本是从尾部插入；</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><ol>
<li>新增元素时，如何保证线程安全, put()</li>
<li>扩容与数据迁移机制，rehash()</li>
</ol>
<h4 id="1-新增元素时，如何保证线程安全"><a href="#1-新增元素时，如何保证线程安全" class="headerlink" title="1) 新增元素时，如何保证线程安全"></a>1) 新增元素时，如何保证线程安全</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public synchronized V put(K key, V value) &#123;</div><div class="line">    // Make sure the value is not null</div><div class="line">    if (value == null) &#123;</div><div class="line">        throw new NullPointerException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Makes sure the key is not already in the hashtable.</div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    int hash = key.hashCode();</div><div class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</div><div class="line">    for(; entry != null ; entry = entry.next) &#123;</div><div class="line">        if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</div><div class="line">            V old = entry.value;</div><div class="line">            entry.value = value;</div><div class="line">            return old;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addEntry(hash, key, value, index);</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void addEntry(int hash, K key, V value, int index) &#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    if (count &gt;= threshold) &#123;</div><div class="line">        // Rehash the table if the threshold is exceeded</div><div class="line">        rehash();</div><div class="line"></div><div class="line">        tab = table;</div><div class="line">        hash = key.hashCode();</div><div class="line">        index = (hash &amp; 0x7FFFFFFF) % tab.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Creates the new entry.</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</div><div class="line">    tab[index] = new Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    count++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第1行：<code>synchronized</code>关键字用于普通方法时，获取到对象实例的锁才能执行，所以在多线程环境下是线程安全的；</p>
<p>第3 ~ 9行：保证插入的键值对，key和value均不为空，否则抛出空指针异常；</p>
<p>第10行：获取插入元素，在数组中的索引位置；</p>
<p>第11 ~ 19行：获取索引位置的元素(元素为链表头结点)，遍历链表，若新增元素的key，在链表中已存在，则替换键值；</p>
<p>第28 ~ 36行: 如果当前的容量(count) 大于 扩容阈值(threshold),则进行扩容（rehash），得到插入元素在扩容后数组的索引位置；</p>
<p>第39 ~ 42行：获取索引位置的元素(链表头结点)，在头结点之前插入元素，容量 + 1；</p>
<h4 id="2-扩容与数据迁移机制"><a href="#2-扩容与数据迁移机制" class="headerlink" title="2) 扩容与数据迁移机制"></a>2) 扩容与数据迁移机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"> @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line"> protected void rehash() &#123;</div><div class="line"> 	  // ① 当前数组容量</div><div class="line">     int oldCapacity = table.length;</div><div class="line">     Entry&lt;?,?&gt;[] oldMap = table;</div><div class="line"></div><div class="line">     // overflow-conscious code ② 数组扩容为原数组的2倍 + 1</div><div class="line">     int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</div><div class="line">     // ③ 判断新容量是否溢出</div><div class="line">     if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; </div><div class="line">         if (oldCapacity == MAX_ARRAY_SIZE)</div><div class="line">             // Keep running with MAX_ARRAY_SIZE buckets</div><div class="line">             return;</div><div class="line">         newCapacity = MAX_ARRAY_SIZE;</div><div class="line">     &#125;</div><div class="line">     Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];</div><div class="line"></div><div class="line">     modCount++;</div><div class="line">     // ④ 计算出新的扩容阈值</div><div class="line">     threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</div><div class="line">     table = newMap;</div><div class="line">// ⑤ 遍历数组，将数据迁移到新数组中</div><div class="line">     for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;</div><div class="line">         for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123;</div><div class="line">             Entry&lt;K,V&gt; e = old;</div><div class="line">             old = old.next;</div><div class="line"></div><div class="line">             int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</div><div class="line">             e.next = (Entry&lt;K,V&gt;)newMap[index];</div><div class="line">             newMap[index] = e;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>第23 ~ 31行：从后往前遍历数组，得到链表首结点；若首结点不为空，继续遍历链表，将链表中的元素迁移到新容器，发生哈希碰撞时，采用从头结点插入的方式；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HashSet源码学习</title>
    <link href="http://jianwl.com/2018/03/27/HashSet%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/27/HashSet源码学习/</id>
    <published>2018-03-27T00:52:55.000Z</published>
    <updated>2018-03-28T22:51:10.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-29/4636358.jpg" alt=""></p>
<p>HashSet是以HashMap为基础类封装的对象，在新增元素E时，往HashMap中插入(E,Object)的键值对，因为在HashMap中Key是不存在重复的，所以保证了HashSet的唯一性。</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><ol>
<li>如何保证唯一性；</li>
</ol>
<h4 id="如何保证唯一性"><a href="#如何保证唯一性" class="headerlink" title="如何保证唯一性"></a>如何保证唯一性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public HashSet() &#123;</div><div class="line">    map = new HashMap&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean add(E e) &#123;</div><div class="line">    return map.put(e, PRESENT)==null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化HashSet时，会初始化HashMap对象；新增元素时，通过HashMap新增(E,Object)的键值对，从而保证了Key的唯一性；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法&quot;&gt;&lt;a href=&quot;#常用方法&quot; class=&quot;headerlink&quot; title=&quot;常用方法&quot;&gt;&lt;/a&gt;常用方法&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.clouddn.com/18-3-29/4636358.jpg
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
</feed>
