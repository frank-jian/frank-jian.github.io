<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录点滴成长</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianwl.com/"/>
  <updated>2017-09-20T17:52:08.000Z</updated>
  <id>http://jianwl.com/</id>
  
  <author>
    <name>流云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java问题排查工具箱</title>
    <link href="http://jianwl.com/2017/09/21/Java%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7%E7%AE%B1/"/>
    <id>http://jianwl.com/2017/09/21/Java问题排查工具箱/</id>
    <published>2017-09-20T16:44:29.000Z</published>
    <updated>2017-09-20T17:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在长期排查线上问题的过程中，总结了一些工具的用法和排查问题的思路，首先讲讲工具，JVM自带的一些工具是必须掌握的，例如jstack、jmap、jstat等，它可以帮我们去深入了解JVM正在做的事情，主要的使用领取有这些：</p>
<h3 id="1、jstack"><a href="#1、jstack" class="headerlink" title="1、jstack"></a>1、jstack</h3><blockquote>
<p>jstack可以告诉你当前所有JVM线程正在做什么，包括用户线程和虚拟机线程，你可以用它来查看线程，并且结合Lock信息来检测是否发生了死锁和死锁的线程。</p>
</blockquote>
<p>举个例子：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-21/88774560.jpg" alt=""></p>
<h3 id="2、jstat"><a href="#2、jstat" class="headerlink" title="2、jstat"></a>2、jstat</h3><blockquote>
<p>stat,顾明思义就是提供一些统计信息，它可以告诉你当前的GC情况，包括GC次数、时间、具体的GC还可以结合gc.log文件去分析。</p>
<p>一般来说，我们用jstat去查看GC情况，判断是否存在YGC或FGC频繁的情况，再去看gc.log和jamp dump内存，MAT分析来定位问题(后面会有一个case针对这种场景)</p>
<p>常用的用法是jstat -gcutil pid time_interval</p>
</blockquote>
<p>举个例子：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-21/72875924.jpg" alt=""></p>
<h3 id="3、jmap"><a href="#3、jmap" class="headerlink" title="3、jmap"></a>3、jmap</h3><blockquote>
<p>排查GC问题必然会用到的工具，jmap可以告诉你当前JVM内存堆中的对象分布及其关系，当你dump堆之后可以用MAT分析，看看有哪些大对象，或者哪些类的实例特别多。</p>
<p>常用用法：</p>
<p>强制FGC: -histo:live</p>
<p>dump堆:-dump:[live],format=b,file=dump.bin</p>
<p>查看各代内存占用情况: -heap</p>
</blockquote>
<p>举个例子：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-21/33702309.jpg" alt=""></p>
<p>然后我们来介绍一些开源的工具，来增强JVM工具本身的作用：</p>
<h3 id="1、MAT-Eclipse-Memory-Analyzer"><a href="#1、MAT-Eclipse-Memory-Analyzer" class="headerlink" title="1、MAT(Eclipse Memory Analyzer)"></a>1、MAT(Eclipse Memory Analyzer)</h3><blockquote>
<p>GC必备分析，用于分析jmap或OOM时dump出来的内存快照，可以看到对象和引用关系；</p>
<p>官方地址：<a href="http://www.eclipse.org/mat" target="_blank" rel="external">http://www.eclipse.org/mat</a></p>
</blockquote>
<h3 id="2、top"><a href="#2、top" class="headerlink" title="2、top"></a>2、top</h3><blockquote>
<p>这个是Linux自带的命令，查看系统资源消耗情况，可以看到CPU、内存、SWAP、I/O的消耗情况，需要特别注意有几个值：</p>
<p>ni,这个值如果特别高说明线程上下文切换开销较大，看看是不是开了太多的线程导致的</p>
<p>res，这个代表了进程实际占用的内存</p>
<p>swap，内存不足就是占用swap空间，这个时候一般应用的性能会急剧下降，需要特别关注；</p>
</blockquote>
<h3 id="3、HouseMD"><a href="#3、HouseMD" class="headerlink" title="3、HouseMD"></a>3、HouseMD</h3><blockquote>
<p>一个类似于BTrace的小工具，用于对JVM运行时的状态进行追踪和诊断，作者是中间件团队的聚石。</p>
<p>通常我们排查问题很多时候都在代码中加个日志，看看方法的参数、返回值是不是我们期望的，然后编译打包部署重启应用，十几分钟过去了。HouseMD可以直接让你可以追踪到方法的返回值和参数，以及调用次数、调用平均rt、调用栈，甚至是类的成员变量的值、Class加载的路径、对应的ClassLoader都可以用一行命令给你展现出来，堪称神器。</p>
</blockquote>
<h3 id="4、TBJMap"><a href="#4、TBJMap" class="headerlink" title="4、TBJMap"></a>4、TBJMap</h3><blockquote>
<p>通过jmap和MAT我们可以知道整个JVM堆的对象分布情况，但是有时候我们需要知道young/old/perm区分别有哪些对象的时候，就要用到TBJMap这个神器了。</p>
<p>它可以告诉你各个分代区各个Class的实例数、占用的空间、以及DirectMemory占用的空间等。</p>
</blockquote>
<h3 id="5、tsar"><a href="#5、tsar" class="headerlink" title="5、tsar"></a>5、tsar</h3><blockquote>
<p>sar是淘宝的采集工具，主要用来收集服务器的系统信息（如cpu，io，mem，tcp等）以及应用数据（如squid haproxy nginx等），tsar支持t实时查看和历史查看，方便了解应用和服务器的信息。</p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://hellojava.info/?p=517" target="_blank" rel="external">Java问题排查工具箱 - 毕玄</a></li>
<li><a href="http://colobu.com/2016/08/10/Java-Flame-Graphs/" target="_blank" rel="external">火焰图</a></li>
<li><a href="http://blog.csdn.net/fenglibing/article/details/6411951" target="_blank" rel="external">JDK内置工具使用</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在长期排查线上问题的过程中，总结了一些工具的用法和排查问题的思路，首先讲讲工具，JVM自带的一些工具是必须掌握的，例如jstack、jmap
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中文乱码排查</title>
    <link href="http://jianwl.com/2017/09/20/MySQL%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E6%8E%92%E6%9F%A5/"/>
    <id>http://jianwl.com/2017/09/20/MySQL中文乱码排查/</id>
    <published>2017-09-20T06:17:39.000Z</published>
    <updated>2017-09-22T04:36:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Github上看到别人用JAVA写了个文章管理工具，git clone到本地看看；按照教程将SQL导入MYSQL中，并启动SpringBoot项目。项目启动之后长这样：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-20/54860156.jpg" alt=""></p>
<p>1、新建文章(未保存)</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-20/43647701.jpg" alt=""></p>
<p>2、保存文章后</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-20/45523456.jpg" alt=""></p>
<h3 id="出现问题的反应"><a href="#出现问题的反应" class="headerlink" title="出现问题的反应"></a>出现问题的反应</h3><p>因为是git clone别人的代码，下意识认为代码层面是没有问题的。第一反应是浏览器编码的问题，尝试了Chrome、Safari、Firefox三个浏览器都是乱码；将编码设置为UTF8之后仍是乱码；于是开始调试代码；</p>
<p>保存文章的流程：① 新建文章 ② 点击保存文章 ③ 后端接收前端传过来的内容 ④ 后端将数据存入数据库，在步骤③打印日志，发现后端接收到的内容是正常的，非乱码，但存入数据库却是乱码的；将问题定位到数据库；</p>
<h3 id="解决数据库中文乱码"><a href="#解决数据库中文乱码" class="headerlink" title="解决数据库中文乱码"></a>解决数据库中文乱码</h3><p>1、根据以下这条命令查询MYSQL的字符集</p>
<blockquote>
<p>show variables like ‘character%’</p>
</blockquote>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-20/65176549.jpg" alt=""></p>
<p>如图可知，服务端的编码非”UTF8”，而存入的中文编码是”UTF8”，因为编码不一致导致乱码；</p>
<p>2、修改数据库my.cnf配置文件加个配置：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-20/68228133.jpg" alt=""></p>
<p>3、重启MYSQL服务器</p>
<h3 id="中文乱码Fixed"><a href="#中文乱码Fixed" class="headerlink" title="中文乱码Fixed"></a>中文乱码Fixed</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-20/6735572.jpg" alt=""></p>
<h3 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h3><p>临时改变编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set character_set_server = utf8</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在Github上看到别人用JAVA写了个文章管理工具，git clone到本地看看；按照教程将SQL导入MYSQL中，并启动SpringBo
    
    </summary>
    
      <category term="MYSQL" scheme="http://jianwl.com/categories/MYSQL/"/>
    
    
      <category term="MYSQL" scheme="http://jianwl.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域学习</title>
    <link href="http://jianwl.com/2017/09/19/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2017/09/19/Java内存区域学习/</id>
    <published>2017-09-19T14:25:57.000Z</published>
    <updated>2017-09-20T09:04:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-20/5113112.jpg" alt=""></p>
<p>JVM内存模型分为两部分私有内存和共享内存；如图所示，堆和方法区是所有线程共有的，而虚拟栈、本地方法栈、程序计数器则是线程私有的。接下来我们来一一分析不同区域的作用。</p>
<h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>堆内存是所有线程共有的，可分为两部分：年轻代和老年代。下图中的Perm代表的永久代，但是永久代并不属于堆内存中的一部分，同时JDK1.8之后永久代被移除了。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-20/12946482.jpg" alt=""></p>
<p>GC(垃圾回收器)对年轻中的对象进行回收被称为Minor GC,用通俗一点的话说年轻代就是用来存放年轻的对象，年轻对象是什么意思呢?年轻对象可以简单的理解为没有经历多次垃圾回收的对象，如果一个对象经历过一定次数的Minor GC,JVM一般就会将这个对象放入到年轻代，而JVM对年老代对象回收则成为Major GC。</p>
<p>如上图所示，年轻代中还可以细分为三个部分，我们需要重点关注这几点:</p>
<p>1、 大部分对象刚创建的时候，JVM将其分布到Eden区域。</p>
<p>2、当Eden区域中的对象达到一定的数目的时候，就会进行Minor GC，经历这次垃圾回收后所有存活的对象都会进入两个 Suvivor Place中的一个。</p>
<p>3、同一时刻两个Suvivor Place,即S0和S1中总有一个总是空的。</p>
<p>4、年轻代中的对象经历过了多次的垃圾回收就会转移到年老代中。</p>
<p>5、当申请不到空间时会抛出OutOfMemoryError.下面我们简单模拟一个内存溢出的情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class HeapOOM &#123;</div><div class="line">    static  class  OOMObject&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;();</div><div class="line">        while (true) &#123;</div><div class="line">            list.add(new OOMObject());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是执行的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</div><div class="line">	at java.util.Arrays.copyOf(Arrays.java:3210)</div><div class="line">	at java.util.Arrays.copyOf(Arrays.java:3181)</div><div class="line">	at java.util.ArrayList.grow(ArrayList.java:261)</div><div class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)</div><div class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)</div><div class="line">	at java.util.ArrayList.add(ArrayList.java:458)</div><div class="line">	at jvm.HeapOOM.main(HeapOOM.java:17)</div></pre></td></tr></table></figure>
<p>堆内存是我们平时在生产环境中进行性能调优中一个非常重要的部分，以下拓展补充几个常见的性能调优参数：</p>
<ul>
<li>PretenureSizeThreshold:直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代中分配。</li>
<li>MaxTenuringThreshold:晋升到老年代的对象年龄，每个对象在坚持过一次Minor GC之后，年龄会加1，当超过这个参数值时就进入老年代。</li>
<li>UseAdaptiveSizePolicy:动态调整Java堆中各个区域的大小以及进入年老代的年龄。</li>
<li>SurivorRatio:新生代Eden区域与Survivor区域的容量比例，默认为8，代表Eden: Suvivor = 8:1。</li>
<li>NewRatio:设置新生代(包括Eden和两个Survivor区)与老年代的比值(除去持久代)，设置为3，则新生代与年老代所占比值为1：3，新生代占整个堆栈的1/4</li>
<li>Xmx:设置JVM堆最大内存</li>
<li>Xms:设置JVM堆初始化内存</li>
<li>Xmn:参数设置年轻代内存</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与Java堆一样，是所有线程共享的区域，它用于存储已被虚拟机加载的类信息、常量、静态常量，即时编译(JIT)后的代码等数据。</p>
<p>对于JDK1.8之前的HotSpot虚拟机而言，很多人经常将方法区称为我们上图中所描述的永久代，实际上两者并不等价，因为这仅仅是HotSpot的设计团队选择利用永久代来实现方法区而言。同时对于其他虚拟机比如IBM J9是不存在永久代概念的。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>JVM中程序计数器和计算机组成原理中提到的程序计数器PC概念类似，线程私有，用来记录执行的字节码位置。CPU的占有时间是以分片的形式分配给每个不同线程的，从操作系统的角度讲，在不同线程之间切换的时候就是依赖程序计数器来记录上一次线程所执行到具体的代码的行数，在JVM就是字节码。</p>
<h3 id="JAVA虚拟机栈"><a href="#JAVA虚拟机栈" class="headerlink" title="JAVA虚拟机栈"></a>JAVA虚拟机栈</h3><p>与程序计数器一样，JAVA虚拟机栈也是线程私有的，用通俗的话将它就是我们常常听到堆栈中的那个“栈”内存。虚拟机栈描述的是JAVA方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧(Stack Frame)用于存储局部变量表（局部变量表需要的内存，在编译期间就确定所在方法运行期间不会改变大小），操作数栈、动态链接、方法出口等信息。每一个方法从调用至出栈的过程，就是栈帧在虚拟机中从入栈到出栈的过程。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈和JAVA虚拟机栈类似，只不过是为JVM执行Native方法服务。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>深入理解JAVA虚拟机</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.clouddn.com/17-9-20/5113112.jpg&quot; alt=&quot;&quot;
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Java8之HashMap源码学习</title>
    <link href="http://jianwl.com/2017/09/01/Java8%E4%B9%8BHashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2017/09/01/Java8之HashMap源码学习/</id>
    <published>2017-09-01T07:20:01.000Z</published>
    <updated>2017-09-01T13:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>随着JDK的更新，JDK1.8对HashMap底层的实现进行了优化，本文想深入探讨HashMap的结构实现和功能原理。</p>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-1/39063824.jpg" alt=""></p>
<p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口有四个常用的实现类，分别为HashMap、LinkedHashMap和TreeMap，类继承关系如图；以下针对各个实现类的特定做了一些说明；</p>
<p>(1) HashMap: 它根据键的hashCode值存储数据，大多数情况可以直接定位到它的值，因而具有很快的访问速度，但遍历速度却是不确定的。HashMap最多只允许一条记录键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻多个线程同时写HashMap，可能会导致数据的不一致，如果要满足线程安全可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或使用ConcurrentHashMap。</p>
<p>(2) Hashtable: Hashtable是遗留类，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable,并发性不如ConcurrentHashMap,因为ConcurrentHashMap引入了分段锁。Hashtable不允许键或值为null；</p>
<p>(3) LinkedHashMap: LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序;</p>
<p>(4) TreeMap: TreeMap实现了SortedMap接口，能够把它的记录根据键排序，默认按键值的升序排序，也可以指定排序的比较器；</p>
<p>上述四种Map类型的类，要求映射的key是<strong>不可变类</strong>，不可变类是该对象在创建后它的哈希值不会被改变。如果对象的哈希值改变了，Map对象很可能就定位不到映射的位置了。</p>
<h3 id="存储结构-字段"><a href="#存储结构-字段" class="headerlink" title="存储结构 - 字段"></a>存储结构 - 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-1/44470980.jpg" alt=""></p>
<p>这里需要讲明白两个问题，数据底层具体存储的是什么？这样的存储方式有什么优点？</p>
<p>1、什么是Node?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">        final int hash; // 定位数组的索引位置</div><div class="line">        final K key;</div><div class="line">        V value;</div><div class="line">        Node&lt;K,V&gt; next; // 链表的下一个Node</div><div class="line"></div><div class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</div><div class="line"></div><div class="line">        public final K getKey()        &#123; ... &#125;</div><div class="line">        public final V getValue()      &#123; ... &#125;</div><div class="line">        public final String toString() &#123; ... &#125;</div><div class="line"></div><div class="line">        public final int hashCode() &#123; ... &#125;</div><div class="line"></div><div class="line">        public final V setValue(V newValue) &#123; ... &#125;</div><div class="line"></div><div class="line">        public final boolean equals(Object o) &#123; ... &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Node是HashMap的内部类，实现了Map.Entry接口，本质上Node是一个链表；</p>
<p>2、如何确认哈希桶索引位置?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">方法一：</div><div class="line">static final int hash(Object key) &#123;   //jdk1.8 &amp; jdk1.7</div><div class="line">     int h;</div><div class="line">     // h = key.hashCode() 为第一步 取hashCode值</div><div class="line">     // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</div><div class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div><div class="line">方法二：</div><div class="line">static int indexFor(int h, int length) &#123;  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</div><div class="line">     return h &amp; (length-1);  //第三步 取模运算</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的Hash算法本质上就三步：取key的hashCode值、高位运算、取模运算；举例说明：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-1/79939676.jpg" alt=""></p>
<p>这样就可以通过key来定位数组的索引位置了；</p>
<p>3、如何解决哈希冲突？</p>
<p>采用链地址法，简单来说就是数组加链表的结合，在每个数组元素上都是一个链表结构，当数据Hash后，得到数组下标，都把数据放在对应下标元素的链表上。</p>
<p>4、关于哈希冲突的调优？</p>
<p>两个Key定位到相同的位置，表示发生了哈希冲突。通过什么方式可来控制Map是的哈希碰撞概率小，哈希桶数组占用空间又小呢？有几个参数需要重点注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int threshold // 扩容的阈值 -- 数组length * loadFactor</div><div class="line">final float loadFactor; // 负载因子 -- 默认0.75</div><div class="line">int modCount;</div><div class="line">int size;</div></pre></td></tr></table></figure>
<p>默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<h3 id="分析HashMap的put方法"><a href="#分析HashMap的put方法" class="headerlink" title="分析HashMap的put方法"></a>分析HashMap的put方法</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-1/13730914.jpg" alt=""></p>
<h3 id="JDK1-8-VS-JDK1-7-性能测试"><a href="#JDK1-8-VS-JDK1-7-性能测试" class="headerlink" title="JDK1.8 VS JDK1.7 性能测试"></a>JDK1.8 VS JDK1.7 性能测试</h3><p>1、哈希较均匀的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class Keys &#123;</div><div class="line">    public static final int MAX_KEY = 1_000_000;</div><div class="line">    private static final Key[] KEYS_CACHE = new Key[MAX_KEY];</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        for (int i = 0; i &lt; MAX_KEY; ++i) &#123;</div><div class="line">            KEYS_CACHE[i] = new Key(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Key of(int value) &#123;</div><div class="line">        return KEYS_CACHE[value];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static void test(int mapSize) &#123;</div><div class="line">        HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key, Integer&gt;(mapSize);</div><div class="line">        for (int i = 0; i &lt; mapSize; i++) &#123;</div><div class="line">            map.put(Keys.of(i), i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        long beginTime = System.nanoTime();</div><div class="line">        for (int i = 0; i &lt; mapSize; i++) &#123;</div><div class="line">            map.get(Keys.of(i));</div><div class="line">        &#125;</div><div class="line">        long endTime = System.nanoTime();</div><div class="line">        System.out.println(&quot;mapSize =&gt; &quot; + mapSize + &quot; time =&gt; &quot; + (endTime - beginTime));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        for (int i = 10; i &lt;= MAX_KEY; i *= 10) &#123;</div><div class="line">            test(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Key implements Comparable&lt;Key&gt; &#123;</div><div class="line">    private final int value;</div><div class="line"></div><div class="line">    public Key(int value) &#123;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int compareTo(Key o) &#123;</div><div class="line">        return Integer.compare(this.value, o.value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean equals(Object o) &#123;</div><div class="line">        if (this == o) return true;</div><div class="line">        if (o == null || getClass() != o.getClass())</div><div class="line">            return false;</div><div class="line">        Key key = (Key) o;</div><div class="line">        return value == key.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        return value; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-1/1545958.jpg" alt=""></p>
<p>从图上可看到JDK1.8的效率远远高于JDK1.7</p>
<p>2、哈希不均匀测试</p>
<p>修改了HashCode的值，其余不变；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Key implements Comparable&lt;Key&gt; &#123;</div><div class="line">    </div><div class="line">    ....</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-1/48441366.jpg" alt=""></p>
<p>由图中结果可知，随着size的变大，JDK1.7花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并呈现对数增长稳定，当一个链表太长是，HashMap会动态将它替换为红黑树，这将时间复杂度从O(N)将为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同。</p>
<p>3、JDK1.8 哈希均匀 VS 哈希不均匀</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-9-1/40579970.jpg" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;随着JDK的更新，JDK1.8对HashMap底层的实现进行了优化，本文想深入探讨HashMap的结构实现和功能原理。&lt;/p&gt;
&lt;h3 id
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>java基础-异常</title>
    <link href="http://jianwl.com/2017/08/27/java%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/"/>
    <id>http://jianwl.com/2017/08/27/java基础-异常/</id>
    <published>2017-08-27T14:12:18.000Z</published>
    <updated>2017-08-27T15:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-异常类图"><a href="#1-异常类图" class="headerlink" title="1. 异常类图"></a>1. 异常类图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/72172724.jpg" alt=""></p>
<h3 id="2-受检异常-VS-非受检异常"><a href="#2-受检异常-VS-非受检异常" class="headerlink" title="2. 受检异常 VS 非受检异常"></a>2. 受检异常 VS 非受检异常</h3><blockquote>
<p>受检异常：继承Exception的子类，需要明确去处理异常；</p>
<p>非受检异常：继承RuntimeException的子类，不需要明确去处理异常；</p>
</blockquote>
<p>非受检异常：继承RuntimeException的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class UncheckedException extends RuntimeException &#123;</div><div class="line">    public UncheckedException() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public UncheckedException(String message) &#123;</div><div class="line">        super(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public UncheckedException(String message, Throwable cause) &#123;</div><div class="line">        super(message, cause);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>受检异常：继承Exception的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class CheckedException extends Exception&#123;</div><div class="line">    public CheckedException() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CheckedException(String message) &#123;</div><div class="line">        super(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CheckedException(String message, Throwable cause) &#123;</div><div class="line">        super(message, cause);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举个例子：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/70188955.jpg" alt=""></p>
<p>如图可知，受检异常必须要处理，否则会报错；非受检异常，可以不处理；</p>
<h3 id="3-StackOverFlowError-VS-OutOfMemoryError"><a href="#3-StackOverFlowError-VS-OutOfMemoryError" class="headerlink" title="3. StackOverFlowError VS OutOfMemoryError"></a>3. StackOverFlowError VS OutOfMemoryError</h3><blockquote>
<p>stackOverFlowError: 与栈相关，所有本地变量和方法调用都存于栈，每次方法的调用都会创建栈空间，一旦方法执行完毕栈空间将回收；</p>
<p>outOfMemoryError:与堆相关，创建的对象引用存于堆中，当JVM尝试给新对象分配内存时，没有足够的堆内存，将抛出OOM。</p>
</blockquote>
<p>stackOverFlowError举例：无限递归方法</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/23183251.jpg" alt=""></p>
<p>outOfMemoryError举例：创建超大对象</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/80401561.jpg" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://stackoverflow.com/questions/11435613/whats-the-difference-between-stackoverflowerror-and-outofmemoryerror" target="_blank" rel="external">What’s the difference between StackOverflowError and OutOfMemoryError</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-异常类图&quot;&gt;&lt;a href=&quot;#1-异常类图&quot; class=&quot;headerlink&quot; title=&quot;1. 异常类图&quot;&gt;&lt;/a&gt;1. 异常类图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.clouddn.com/17-8-27/7
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>java基础-集合梳理</title>
    <link href="http://jianwl.com/2017/08/27/java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%E6%A2%B3%E7%90%86/"/>
    <id>http://jianwl.com/2017/08/27/java基础-集合梳理/</id>
    <published>2017-08-27T06:58:37.000Z</published>
    <updated>2017-08-27T08:53:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Map类图-不包含java-util-concurrent包的类"><a href="#1-Map类图-不包含java-util-concurrent包的类" class="headerlink" title="1. Map类图(不包含java.util.concurrent包的类)"></a>1. Map类图(不包含java.util.concurrent包的类)</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/64952891.jpg" alt=""></p>
<h3 id="2-List类图-整理部分常用"><a href="#2-List类图-整理部分常用" class="headerlink" title="2. List类图(整理部分常用)"></a>2. List类图(整理部分常用)</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/83565321.jpg" alt=""></p>
<h3 id="3-Set类图整理-不包含java-util-concurrent包的类"><a href="#3-Set类图整理-不包含java-util-concurrent包的类" class="headerlink" title="3. Set类图整理(不包含java.util.concurrent包的类)"></a>3. Set类图整理(不包含java.util.concurrent包的类)</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/89594162.jpg" alt=""></p>
<h3 id="4-集合类图整理"><a href="#4-集合类图整理" class="headerlink" title="4. 集合类图整理"></a>4. 集合类图整理</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/57993384.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Map类图-不包含java-util-concurrent包的类&quot;&gt;&lt;a href=&quot;#1-Map类图-不包含java-util-concurrent包的类&quot; class=&quot;headerlink&quot; title=&quot;1. Map类图(不包含java.util.co
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>泛型中extends和super的区别?</title>
    <link href="http://jianwl.com/2017/08/27/%E6%B3%9B%E5%9E%8B%E4%B8%ADextends%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://jianwl.com/2017/08/27/泛型中extends和super的区别/</id>
    <published>2017-08-27T05:10:19.000Z</published>
    <updated>2017-08-27T05:11:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://itimetraveler.github.io/2016/12/27/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B%E4%B8%AD%20extends%20%E5%92%8C%20super%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/" target="_blank" rel="external">【Java】泛型中 extends 和 super 的区别？</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://itimetraveler.github.io/2016/12/27/%E3%
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>高效实用Python字典的清单</title>
    <link href="http://jianwl.com/2017/08/22/%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8Python%E5%AD%97%E5%85%B8%E7%9A%84%E6%B8%85%E5%8D%95/"/>
    <id>http://jianwl.com/2017/08/22/高效实用Python字典的清单/</id>
    <published>2017-08-22T14:22:12.000Z</published>
    <updated>2017-08-22T15:07:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>字典(dict)对象是Python最常用的数据结构，这里整理了几个关于高效实用字典的清单，希望Python开发者可以在日常应用开发中合理利用，让代码更加Pythonic。</p>
<h3 id="1、用in关键字检查key是否存在"><a href="#1、用in关键字检查key是否存在" class="headerlink" title="1、用in关键字检查key是否存在"></a>1、用in关键字检查key是否存在</h3><p>Python之禅中有一句开发哲学是:</p>
<blockquote>
<p>There should be one – and perferably only one –obvious way to do it.</p>
</blockquote>
<p>尽量找一种，最好是唯一一种显而易见的解决方案。Python2中判断某个key是否存在字典中可使用<code>has_key</code>方法，另外一种方式是使用<code>in</code>关键字。但强烈推荐后者，因为in的处理速度更快，另外一个原因是<code>has_key</code>这个方法在Python3被移除了。</p>
<p>bad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">info = dict(name=&apos;zhangsan&apos;,age=23)</div><div class="line">if info.has_key(&apos;name&apos;):</div><div class="line">   pass</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">info = dict(name=&apos;zhangsan&apos;,age=23)</div><div class="line">if &apos;name&apos; in info:</div><div class="line">   pass</div></pre></td></tr></table></figure>
<h3 id="2、用get获取字典中的值"><a href="#2、用get获取字典中的值" class="headerlink" title="2、用get获取字典中的值"></a>2、用get获取字典中的值</h3><p>关于获取字典的值，一种简单的方式就是用d[x]访问元素，但是这种情况在key不存在的情况下会报KeyError错误，当然你可以先用in操作检查key是否在字典中在获取，不过这种方式不符合Python之禅中说的：</p>
<blockquote>
<p>Simple is better then complex<br>Flat is better than nested.</p>
</blockquote>
<p>好的代码应该是简单易懂的，扁平的代码结构更加可读。所以我们可以使用get方法来替代if … else.</p>
<p>bad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">d = dict(name=&apos;python&apos;)</div><div class="line">if &apos;name&apos; in d:</div><div class="line">    print d[&apos;hello&apos;]</div><div class="line">else:</div><div class="line">	 print &apos;default&apos;</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print d.get(&apos;name&apos;,&apos;default&apos;)</div></pre></td></tr></table></figure>
<h3 id="3、用setdefault为字典中不存在的key设置缺省值"><a href="#3、用setdefault为字典中不存在的key设置缺省值" class="headerlink" title="3、用setdefault为字典中不存在的key设置缺省值"></a>3、用setdefault为字典中不存在的key设置缺省值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data = [(&apos;animal&apos;,&apos;bear&apos;),(&apos;animal,&apos;duck&apos;),(&apos;plant&apos;,&apos;catus&apos;),(&apos;vehicle&apos;,&apos;speed boat&apos;),(&apos;vehicle&apos;,&apos;school bus&apos;)]</div></pre></td></tr></table></figure>
<p>在做分类统计时，希望把同一类型的数据归到字典中的某种类型中，比如上面代码，把相同类型的事物用列表形式重新组装，得到新字典。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data = dict(animal=[&apos;bear&apos;,&apos;duck&apos;],plant=[&apos;cacuts&apos;],vehicle=[&apos;speed boat&apos;,&apos;school bus&apos;])</div></pre></td></tr></table></figure>
<p>普通的方式就是先判断key是否存在，如果不存在则要先用列表对象进行初始化，在执行后续操作。而更好的方式就是使用字典中的setdefault方法。</p>
<p>bad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">groups = &#123;&#125;</div><div class="line">for (key,value) in data:</div><div class="line">    if key in groups:</div><div class="line">       groups[key].append(value)</div><div class="line">    else:</div><div class="line">       groups[key] = [value]</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">groups = &#123;&#125;</div><div class="line">for (key,value) in data:</div><div class="line">    groups.setdefault(key,[]).append(value)</div></pre></td></tr></table></figure>
<p><code>setdefault</code>的作用是：</p>
<ol>
<li>如果key存在与字典中，那么直接返回对应的值，等效于get</li>
<li>如果key不存在字典中，则会用setdefault中的第二个参数作为该key的值，在返回该值。</li>
</ol>
<h3 id="4、用字典实现swith-…-case语句"><a href="#4、用字典实现swith-…-case语句" class="headerlink" title="4、用字典实现swith … case语句"></a>4、用字典实现swith … case语句</h3><p>Python中没有switch…case语句，这个问题Python之父龟叔表示这个语法过去没有，现在没有，以后也不会有。因为Python简洁的语法完全可以用if…elif实现。如果有太多的分支判断，还可以使用字典来代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if arg == 0:</div><div class="line">  return &apos;zero&apos;</div><div class="line">elif arg == 1:</div><div class="line">  return &apos;one&apos;</div><div class="line">elif arg == 2:</div><div class="line">  return &apos;two&apos;</div><div class="line">elif arg == 3:</div><div class="line">  return &apos;three&apos;</div><div class="line">else:</div><div class="line">  return &apos;nothing&apos;</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = dict(0=&apos;zero&apos;,1=&apos;one&apos;,2=&apos;two&apos;,3=&apos;three&apos;)</div><div class="line">data.get(arg,&quot;nothing&quot;)</div></pre></td></tr></table></figure>
<h3 id="5、使用items迭代字典中的元素"><a href="#5、使用items迭代字典中的元素" class="headerlink" title="5、使用items迭代字典中的元素"></a>5、使用items迭代字典中的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data = dict(0=&apos;zero&apos;,1=&apos;one&apos;,2=&apos;two&apos;,3=&apos;three&apos;)</div><div class="line">for k,v in data.items():</div><div class="line">  print k,v</div></pre></td></tr></table></figure>
<h3 id="6、使用字典推导式"><a href="#6、使用字典推导式" class="headerlink" title="6、使用字典推导式"></a>6、使用字典推导式</h3><p>推导式是个绝妙的东西，列表推导式一出，map、filter等函数黯然失色，至python2.7以后的版本，此特性扩展到了字典和集合身上，构建字典对象无需调用dict方法。</p>
<p>bad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">numbers = [1,2,3]</div><div class="line">d = dict([(number,number*2) for number in numbers])</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">numbers = [1,2,3]</div><div class="line">d = &#123;number: number * 2 for number in numbers&#125;</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://juejin.im/post/599c03e751882511264e7428" target="_blank" rel="external">高效使用Python字典</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;字典(dict)对象是Python最常用的数据结构，这里整理了几个关于高效实用字典的清单，希望Python开发者可以在日常应用开发中合理利用
    
    </summary>
    
      <category term="Python" scheme="http://jianwl.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jianwl.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>cp -r without hidden files</title>
    <link href="http://jianwl.com/2017/08/16/cp-r-without-hidden-files/"/>
    <id>http://jianwl.com/2017/08/16/cp-r-without-hidden-files/</id>
    <published>2017-08-16T03:56:14.000Z</published>
    <updated>2017-08-16T03:57:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><a href="https://stackoverflow.com/questions/11557114/cp-r-without-hidden-files" target="_blank" rel="external">cp-r-without-hidden-files</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/11557114/cp
    
    </summary>
    
      <category term="Linux" scheme="http://jianwl.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://jianwl.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Webpack入门篇</title>
    <link href="http://jianwl.com/2017/08/15/Webpack%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://jianwl.com/2017/08/15/Webpack入门篇/</id>
    <published>2017-08-15T09:16:19.000Z</published>
    <updated>2017-08-15T09:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><a href="http://www.jianshu.com/p/42e11515c10f" target="_blank" rel="external">入门Webpack，看这篇就够了</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/42e11515c10f&quot; target=&quot;
    
    </summary>
    
      <category term="Webpack" scheme="http://jianwl.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://jianwl.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Java服务化系统线上应急和技术攻关，你必须掌握的Linux命令</title>
    <link href="http://jianwl.com/2017/07/22/Java%E6%9C%8D%E5%8A%A1%E5%8C%96%E7%B3%BB%E7%BB%9F%E7%BA%BF%E4%B8%8A%E5%BA%94%E6%80%A5%E5%92%8C%E6%8A%80%E6%9C%AF%E6%94%BB%E5%85%B3%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84Linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://jianwl.com/2017/07/22/Java服务化系统线上应急和技术攻关，你必须掌握的Linux命令/</id>
    <published>2017-07-22T12:51:16.000Z</published>
    <updated>2017-07-23T03:32:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文并不是Linux命令的手册，而是侧重于命令在特定场景如何帮助应急人员和攻关人员定位问题并解决问题，因此，对于每个命令的介绍将直切主题，直接介绍命令的具体场景，而不是介绍命令的详细使用格式。</p>
<h3 id="1-必不可少的基础命令和工具"><a href="#1-必不可少的基础命令和工具" class="headerlink" title="1. 必不可少的基础命令和工具"></a>1. 必不可少的基础命令和工具</h3><h4 id="1-1-grep"><a href="#1-1-grep" class="headerlink" title="1.1 grep"></a>1.1 grep</h4><p><code>grep</code>是<code>Linux</code>下通用的文本内容查找命令。</p>
<p>也可以利用它打印匹配的上下几行，线上查找问题的时候，可以使用以下命令,查找关键字，显示关键字出现的后5行，并且给关键字着色。</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">grep -5 &apos;pattern&apos; INPUT_FILE # 打印匹配行的前后5行</div><div class="line"></div><div class="line">grep -C 5 &apos;pattern&apos; INPUT_FILE # 打印匹配行的前后5行</div><div class="line"></div><div class="line">grep -A 5 &apos;pattern&apos; INPUT_FILE # 打印匹配行的后5行</div><div class="line"></div><div class="line">grep -B 5 &apos;pattern&apos; INPUT_FILE # 打印匹配行的前5行</div></pre></td></tr></table></figure>
<h4 id="1-2-find"><a href="#1-2-find" class="headerlink" title="1.2 find"></a>1.2 find</h4><p>通过文件名称查找文件的所在位置，名称查找支持模糊匹配</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name FILE_NAME</div></pre></td></tr></table></figure>
<p>命令输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@10-9-179-71 ~]# find . -name GifApiApplication.java</div><div class="line">./app/Gif-Api/src/main/java/com/budong/GifApiApplication.java</div></pre></td></tr></table></figure>
<h4 id="1-3-uptime"><a href="#1-3-uptime" class="headerlink" title="1.3 uptime"></a>1.3 uptime</h4><p>查看机器的启动时间、登录用户、平均负载等情况，通常用在线上应急或者技术攻关的时候来确定操作系统的重启时间。</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uptime</div></pre></td></tr></table></figure>
<p>命令输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[jianweilin@login10-103-142 ~]$ uptime</div><div class="line"> 10:35:13 up 698 days, 19:30,  3 users,  load average: 0.20, 0.13, 0.04</div></pre></td></tr></table></figure>
<p>从上面输出可以看到如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1、 当前时间：10:35:13</div><div class="line"></div><div class="line">2、 系统已运行的时间：698天19个小时30分钟</div><div class="line"></div><div class="line">3、当前在线用户：3个用户</div><div class="line"></div><div class="line">4. 系统平均负载：0.20 、0.13 、 0.04，最近1分钟、5分钟、15分钟系统的负载情况</div></pre></td></tr></table></figure>
<p>系统平均负载指在特定时间间隔内队列中运行的平均进程数，如果一个进程满足一下条件，它就会位于运行队列中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1、它没有在等待IO操作的结果</div><div class="line"></div><div class="line">2、它没有主动进入等待状态（也就是没有调用wait相关的系统API）</div><div class="line"></div><div class="line">3、没有被停止（例如：等待终止）</div></pre></td></tr></table></figure>
<p>一般来说，每个CPU内核对应活动进程数不大于3，则系统运行良好，换句话说，也就是活动进程数小于CPU核数的3倍。</p>
<p>举例说明，如果你的服务CPU有3个核心，那么只要uptime最后输出的一串字符数值小于9，即表示系统负载正常。但是，如果系统负载超过10，那就表示当前系统负载过重，需要定位系统执行任务负载超标的原因。</p>
<h4 id="1-4-lsof"><a href="#1-4-lsof" class="headerlink" title="1.4 lsof"></a>1.4 lsof</h4><p>列出系统当前打开的文件句柄，在Linux文件系统中，任何资源都是以文件句柄的形式管理的。例如：硬件设备、文件、网络套接字等，系统内部为每一种资源分配一个句柄，应用程序只能用操作系统分配的句柄来引用资源，因此，文件句柄为应用程序与基础操作系统之间的交互提供了通用的操作接口。</p>
<p>应用程序打开文件的描述列表包含大量的关于应用程序本身的运行信息，因此通过lsof工具查看这个文件句柄列表，对系统监控以及应急排错提供重要的帮助。</p>
<p>查看某一个进程打开的文件句柄：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@10-9-179-71 ~]# lsof -p 12988 | less</div><div class="line">COMMAND   PID USER   FD   TYPE             DEVICE SIZE/OFF     NODE NAME</div><div class="line">java    12988 root  cwd    DIR              252,1     4096   917916 /root/app/Gif-Api</div><div class="line">java    12988 root  rtd    DIR              252,1     4096        2 /</div><div class="line">java    12988 root  txt    REG              252,1     7718   400499 /usr/java/jdk1.7.0_80/bin/java</div><div class="line">java    12988 root  mem    REG              252,1 99170352   292284 /usr/lib/locale/locale-archive</div><div class="line">java    12988 root  mem    REG              252,1   111440   786852 /lib64/libresolv-2.12.so</div><div class="line">java    12988 root  mem    REG              252,1    27896   786492 /lib64/libnss_dns-2.12.so</div><div class="line">java    12988 root  mem    REG              252,1    90880   795901 /lib64/libgcc_s-4.4.7-20120601.</div><div class="line">so.1</div><div class="line">java    12988 root  mem    REG              252,1  1025172   663136 /usr/java/jdk1.7.0_80/jre/lib/e</div><div class="line">xt/localedata.jar</div><div class="line">java    12988 root  mem    REG              252,1   196468   663055 /usr/java/jdk1.7.0_80/jre/lib/e</div><div class="line">xt/sunjce_provider.jar</div></pre></td></tr></table></figure>
<h4 id="1-5-ulimit"><a href="#1-5-ulimit" class="headerlink" title="1.5 ulimit"></a>1.5 ulimit</h4><p>Linux系统为每个登录用户，都限制其最大进程数和打开的最大文件句柄数。为提供性能，可以根据硬件资源的具体情况，设置各个用户的最大进程数和打开的最大文件句柄数。</p>
<p>可以用<code>ulimit -a</code>来显示当前的各种系统对用户使用资源的限制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[root@10-9-179-71 ~]# ulimit -a</div><div class="line">core file size          (blocks, -c) unlimited</div><div class="line">data seg size           (kbytes, -d) unlimited</div><div class="line">scheduling priority             (-e) 0</div><div class="line">file size               (blocks, -f) unlimited</div><div class="line">pending signals                 (-i) 15356</div><div class="line">max locked memory       (kbytes, -l) 64</div><div class="line">max memory size         (kbytes, -m) unlimited</div><div class="line">open files                      (-n) 1000000</div><div class="line">pipe size            (512 bytes, -p) 8</div><div class="line">POSIX message queues     (bytes, -q) 819200</div><div class="line">real-time priority              (-r) 0</div><div class="line">stack size              (kbytes, -s) 10240</div><div class="line">cpu time               (seconds, -t) unlimited</div><div class="line">max user processes              (-u) 15356</div><div class="line">virtual memory          (kbytes, -v) unlimited</div><div class="line">file locks                      (-x) unlimited</div></pre></td></tr></table></figure>
<p>设置用户的最大进程数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ulimit -u 10240</div></pre></td></tr></table></figure>
<p>设置用户可以打开的最大文件句柄数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ulimit -n 10240</div></pre></td></tr></table></figure>
<h4 id="1-6-curl"><a href="#1-6-curl" class="headerlink" title="1.6 curl"></a>1.6 curl</h4><p>程序开发后，会使用Junit、Testng以及Jmock、Mockito进行单元测试，单元测试后需要进行集成测试，由于当前的线上服务较多使用Restful风格，那么集成测试的时候就需要进行HTTP调用，查看返回的结果是否符合预期，curl命令是首选测试的方法。</p>
<p>使用方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 打印请求响应头信息</div><div class="line">[root@10-9-179-71 ~]# curl -i https://bdapi.imdada.cn/health/check</div><div class="line">HTTP/1.1 200 OK</div><div class="line">Server: openresty</div><div class="line">Date: Sun, 23 Jul 2017 03:15:09 GMT</div><div class="line">Content-Type: application/json;charset=UTF-8</div><div class="line">Transfer-Encoding: chunked</div><div class="line">Connection: keep-alive</div><div class="line">&#123;&quot;status&quot;:&quot;ok&quot;,&quot;content&quot;:&quot;ok&quot;&#125;</div><div class="line"></div><div class="line"># 打印HTTP响应码</div><div class="line">[root@10-9-179-71 ~]# curl -I https://bdapi.imdada.cn/health/check</div><div class="line">HTTP/1.1 200 OK</div><div class="line">Server: openresty</div><div class="line">Date: Sun, 23 Jul 2017 03:16:45 GMT</div><div class="line">Content-Type: application/json;charset=UTF-8</div><div class="line">Content-Length: 30</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure>
<h4 id="1-7-scp"><a href="#1-7-scp" class="headerlink" title="1.7 scp"></a>1.7 scp</h4><p>scp命令是Linux系统中功能强大的文件传输命令，可以实现从本地到远程以及远程到本地的双向文件传输，用起来非常的方便。常用来在线上定位问题时，将线上的一些文件下载到本地进行查看，或者将本地的修改上传到服务器上。</p>
<p>使用方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">scp jianweilin@192.168.1.1:/home/jianweilin/test.txt</div><div class="line"></div><div class="line">scp ./test.txt jianweilin@192.168.1.1:/home/jianweilin/</div></pre></td></tr></table></figure></p>
<h4 id="1-8-vi-amp-vim"><a href="#1-8-vi-amp-vim" class="headerlink" title="1.8 vi &amp; vim"></a>1.8 vi &amp; vim</h4><p>vi和vim是Linux中最常用的命令行文本编辑工具，vim是vi的升级版本，在某些Linux版本下，vi实际上通过软链接指向vim。</p>
<p>常用vi/vim命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">1、h: 左移一个字符</div><div class="line"></div><div class="line">2、l: 有移一个字符</div><div class="line"></div><div class="line">3、k: 上移一个字符</div><div class="line"></div><div class="line">4、j: 下移一个字符</div><div class="line"></div><div class="line">5、set number: 显示行号</div><div class="line"></div><div class="line">6、shift + g: 移动到最后一行</div><div class="line"></div><div class="line">7、1 + shift + g: 移动到第一行</div><div class="line"></div><div class="line">8、n + shift + g: 移动到第n行</div><div class="line"></div><div class="line">9、0: 移动到行首</div><div class="line"></div><div class="line">10、$: 移动到行尾</div><div class="line"></div><div class="line">11、 /text: 查到text，按n键查找下一个，按N查找前一个</div><div class="line"></div><div class="line">12、 ?text: 查找text，按n键查找下一个，按N查找前一个</div><div class="line"></div><div class="line">13、i: 在当前位置前插入</div><div class="line"></div><div class="line">14、I: 在当前行首插入</div><div class="line"></div><div class="line">15、a: 在当前位置后插入</div><div class="line"></div><div class="line">16、A: 在当前行尾插入</div><div class="line"></div><div class="line">17、o: 在当前行之后插入一行</div><div class="line"></div><div class="line">18、O: 在当前行之前插入一行</div><div class="line"></div><div class="line">19、%s/old/new/g：用old替换new，替换当前行的所有匹配</div><div class="line"></div><div class="line">20、ctrl + f：向下滚动一屏</div><div class="line"></div><div class="line">21、ctrl + b：向上滚动一屏</div><div class="line"></div><div class="line">22、u：撤销</div><div class="line"></div><div class="line">23、U：撤销对整行的操作</div><div class="line"></div><div class="line">24、Ctrl + r：重做，即撤销的撤销</div><div class="line"></div><div class="line">25、x：删除当前字符</div><div class="line"></div><div class="line">26、dd：删除当前行</div><div class="line"></div><div class="line">27、10d：删除当前行开始的10行</div><div class="line"></div><div class="line">28、yy：拷贝当前行</div><div class="line"></div><div class="line">29、p：在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行</div><div class="line">粘贴</div><div class="line"></div><div class="line">30、：wq：保存并退出</div><div class="line"></div><div class="line">31、：q!：强制退出并忽略所有更改</div></pre></td></tr></table></figure>
<p>未完待续…</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.jianshu.com/p/6fc923ceb722" target="_blank" rel="external">Java服务化系统线上应急和技术攻关，你必须掌握的Linux命令</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文并不是Linux命令的手册，而是侧重于命令在特定场景如何帮助应急人员和攻关人员定位问题并解决问题，因此，对于每个命令的介绍将直切主题，直
    
    </summary>
    
      <category term="Linux" scheme="http://jianwl.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://jianwl.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Flask-SQLAlchemy: Can&#39;t reconnect until invalid transaction is rolled back</title>
    <link href="http://jianwl.com/2017/07/20/Flask-SQLAlchemy-Can-t-reconnect-until-invalid-transaction-is-rolled-back/"/>
    <id>http://jianwl.com/2017/07/20/Flask-SQLAlchemy-Can-t-reconnect-until-invalid-transaction-is-rolled-back/</id>
    <published>2017-07-20T13:17:45.000Z</published>
    <updated>2017-07-20T13:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近来在做些Python的重构工作，今日屡次出现这个错误；</p>
<p> <img src="http://oc5a5l0a0.bkt.clouddn.com/17-7-20/81011645.jpg" alt=""></p>
<p>由日志可知，在查询<code>bd_charge_info</code>这张表时，由于存在没有提交的事务，导致了查询失败；于是查了MYSQL数据库的事务状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SHOW ENGINE INNODB STATUS</div></pre></td></tr></table></figure>
<p>查询结果：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-7-20/50146776.jpg" alt=""></p>
<p>至此确认了问题所在。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://imysql.com/2015/03/25/mysql-faq-how-to-fetch-latest-trxid.shtml" target="_blank" rel="external">如何查看当前最新事务ID</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;近来在做些Python的重构工作，今日屡次出现这个错误；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://oc5a5l0a0.bkt.cl
    
    </summary>
    
      <category term="Python" scheme="http://jianwl.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jianwl.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>2017的小目标</title>
    <link href="http://jianwl.com/2017/07/19/2017%E7%9A%84%E5%B0%8F%E7%9B%AE%E6%A0%87/"/>
    <id>http://jianwl.com/2017/07/19/2017的小目标/</id>
    <published>2017-07-19T14:58:27.000Z</published>
    <updated>2017-07-19T15:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>已经到年中了，给后半年设定一些小目标；</p>
<h3 id="小目标制定"><a href="#小目标制定" class="headerlink" title="小目标制定"></a>小目标制定</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-7-19/17630389.jpg" alt=""></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-7-19/90166218.jpg" alt=""></p>
<h3 id="7月份小目标"><a href="#7月份小目标" class="headerlink" title="7月份小目标"></a>7月份小目标</h3><p>7月份的学习主要以巩固基础为主，熟悉JVM参数配置 &amp; 泛读JVM官方文档</p>
<p>【10h】泛读<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/" target="_blank" rel="external">The Java Virtual Machine Specification</a></p>
<p>【20h】精读《深入理解JAVA虚拟机》并输出笔记</p>
<h3 id="7月份进展"><a href="#7月份进展" class="headerlink" title="7月份进展"></a>7月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="8月份小目标"><a href="#8月份小目标" class="headerlink" title="8月份小目标"></a>8月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="8月份进展"><a href="#8月份进展" class="headerlink" title="8月份进展"></a>8月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="9月份小目标"><a href="#9月份小目标" class="headerlink" title="9月份小目标"></a>9月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="9月份进展"><a href="#9月份进展" class="headerlink" title="9月份进展"></a>9月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="10月份小目标"><a href="#10月份小目标" class="headerlink" title="10月份小目标"></a>10月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="10月份进展"><a href="#10月份进展" class="headerlink" title="10月份进展"></a>10月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="11月份小目标"><a href="#11月份小目标" class="headerlink" title="11月份小目标"></a>11月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="11月份进展"><a href="#11月份进展" class="headerlink" title="11月份进展"></a>11月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="12月份小目标"><a href="#12月份小目标" class="headerlink" title="12月份小目标"></a>12月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="12月份进展"><a href="#12月份进展" class="headerlink" title="12月份进展"></a>12月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="全年总结"><a href="#全年总结" class="headerlink" title="全年总结"></a>全年总结</h3><p>// 还没轮到我呢…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已经到年中了，给后半年设定一些小目标；&lt;/p&gt;
&lt;h3 id=&quot;小目标制定&quot;&gt;&lt;a href=&quot;#小目标制定&quot; class=&quot;headerlink&quot; title=&quot;小目标制定&quot;&gt;&lt;/a&gt;小目标制定&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.
    
    </summary>
    
      <category term="小目标" scheme="http://jianwl.com/categories/%E5%B0%8F%E7%9B%AE%E6%A0%87/"/>
    
    
      <category term="小目标" scheme="http://jianwl.com/tags/%E5%B0%8F%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>JAVA之生产者-消费者模式</title>
    <link href="http://jianwl.com/2017/06/21/JAVA%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/21/JAVA之生产者-消费者模式/</id>
    <published>2017-06-21T08:50:53.000Z</published>
    <updated>2017-06-21T10:48:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>生产者-消费者模式是一个经典的多线程设计模式，它为多线程的协作提供了良好的解决方案。在生产者与消费者模式中，通常有两类线程，即若干个生产者线程和若干个消费者线程。<strong>生产者线程负责提交用户请求，消费者线程负责具体处理生产者提交的任务</strong>；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/QQ20170621-170501@2x.png" alt=""></p>
<p>生产者-消费者模式的核心组件是共享内存缓冲区，它作为生产者和消费者间的通信桥梁，避免了生产者和消费者的直接通信，从而将生产者和消费者进行解耦，生产者不需要知道消费者的存在，消费者也不需要知道生产者的存在。</p>
<p>同时，由于内存缓冲区的存在，允许生产者和消费者在执行速度上存在时间差，无论是生产者在某一局部时间内速度高于消费者，或是消费者在局部时间内高于生产者，都可以通过共享内存缓冲区得到缓解，确保系统正常运行。</p>
<h3 id="2-生产者-消费者模式主要角色"><a href="#2-生产者-消费者模式主要角色" class="headerlink" title="2. 生产者-消费者模式主要角色"></a>2. 生产者-消费者模式主要角色</h3><table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>生产者</td>
<td>用于提交用户请求，提取用户任务，并装入内存缓冲区</td>
</tr>
<tr>
<td>消费者</td>
<td>在内存缓冲区中提取并处理任务</td>
</tr>
<tr>
<td>内存缓冲区</td>
<td>缓冲生产者提交的任务或数据，供消费者使用</td>
</tr>
<tr>
<td>任务</td>
<td>生产者向内存缓冲区提交的数据结构</td>
</tr>
<tr>
<td>Main</td>
<td>使用生产者和消费者的客户端</td>
</tr>
</tbody>
</table>
<h3 id="3-类图"><a href="#3-类图" class="headerlink" title="3. 类图"></a>3. 类图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-21/96135924.jpg" alt=""></p>
<h3 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h3><h4 id="1-共享数据模型不可变类PCData"><a href="#1-共享数据模型不可变类PCData" class="headerlink" title="1) 共享数据模型不可变类PCData"></a>1) 共享数据模型不可变类<code>PCData</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public final class PCData &#123;</div><div class="line">    private final int intData;</div><div class="line"></div><div class="line">    public PCData(int d) &#123;</div><div class="line">        intData = d;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public PCData(String d) &#123;</div><div class="line">        intData = Integer.valueOf(d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getIntData() &#123;</div><div class="line">        return intData;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;data:&quot; + intData;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-生产者Producer"><a href="#2-生产者Producer" class="headerlink" title="2) 生产者Producer"></a>2) 生产者<code>Producer</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Producer implements Runnable &#123;</div><div class="line">    private volatile boolean isRunning = true;</div><div class="line">    private BlockingQueue&lt;PCData&gt; queue;</div><div class="line">    private static AtomicInteger count = new AtomicInteger();</div><div class="line"></div><div class="line">    private static final int SLEEP_TIME = 100;</div><div class="line"></div><div class="line">    public Producer(BlockingQueue&lt;PCData&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        PCData data = null;</div><div class="line">        Random r = new Random();</div><div class="line">        System.out.println(&quot;start producer id =&quot; + Thread.currentThread().getId());</div><div class="line"></div><div class="line">        try&#123;</div><div class="line">            while (isRunning) &#123;</div><div class="line">                Thread.sleep(r.nextInt(SLEEP_TIME));</div><div class="line">                // 构造任务数据</div><div class="line">                data = new PCData(count.incrementAndGet());</div><div class="line">                System.out.println(data + &quot; is put into queue&quot;);</div><div class="line">                if (!queue.offer(data,2, TimeUnit.SECONDS)) &#123;</div><div class="line">                    System.err.println(&quot;fail to put data: &quot; + data);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void stop() &#123;</div><div class="line">        isRunning = false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-消费者Consumer"><a href="#3-消费者Consumer" class="headerlink" title="3) 消费者Consumer"></a>3) 消费者<code>Consumer</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Consumer implements Runnable &#123;</div><div class="line">    private BlockingQueue&lt;PCData&gt; queue;</div><div class="line">    private static final int SLEEP_TIME = 100;</div><div class="line"></div><div class="line">    public Consumer(BlockingQueue&lt;PCData&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;start consumer id = &quot; + Thread.currentThread().getId());</div><div class="line">        Random r = new Random();</div><div class="line"></div><div class="line">        try&#123;</div><div class="line">            while (true) &#123;</div><div class="line">                PCData data = queue.take();</div><div class="line">                if( null != data) &#123;</div><div class="line">                    int re = data.getIntData() * data.getIntData();</div><div class="line">                    System.out.println(MessageFormat.format(&quot;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&quot;,data.getIntData(), data.getIntData(),re));</div><div class="line">                &#125;</div><div class="line">                Thread.sleep(r.nextInt(SLEEP_TIME));</div><div class="line">            &#125;</div><div class="line">        &#125;catch (InterruptedException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-入口Run"><a href="#4-入口Run" class="headerlink" title="4) 入口Run"></a>4) 入口<code>Run</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        // 建立缓冲区</div><div class="line">        BlockingQueue&lt;PCData&gt; queue = new LinkedBlockingQueue&lt;&gt;(10);</div><div class="line"></div><div class="line">        // 建立生产者</div><div class="line">        Producer producer1 = new Producer(queue);</div><div class="line">        Producer producer2 = new Producer(queue);</div><div class="line">        Producer producer3 = new Producer(queue);</div><div class="line"></div><div class="line">        // 建立消费者</div><div class="line">        Consumer consumer1 = new Consumer(queue);</div><div class="line">        Consumer consumer2 = new Consumer(queue);</div><div class="line">        Consumer consumer3 = new Consumer(queue);</div><div class="line"></div><div class="line">        // 建立线程池</div><div class="line">        ExecutorService service = Executors.newCachedThreadPool();</div><div class="line"></div><div class="line">        // 运行生产者</div><div class="line">        service.execute(producer1);</div><div class="line">        service.execute(producer2);</div><div class="line">        service.execute(producer3);</div><div class="line"></div><div class="line">        // 运行消费者</div><div class="line">        service.execute(consumer1);</div><div class="line">        service.execute(consumer2);</div><div class="line">        service.execute(consumer3);</div><div class="line">        Thread.sleep(1000);</div><div class="line"></div><div class="line">        // 停止生产者</div><div class="line">        producer1.stop();</div><div class="line">        producer2.stop();</div><div class="line">        producer3.stop();</div><div class="line"></div><div class="line">        Thread.sleep(1000);</div><div class="line">        service.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5 运行结果"></a>5 运行结果</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-21/49301344.jpg" alt=""></p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><ol>
<li>Java程序性能优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;生产者-消费者模式是一个经典的多线程设计模式，它为多线程的协作提供了良好的解决方案。在生产者与消费者模式中，通常有两类线
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA之Future模式</title>
    <link href="http://jianwl.com/2017/06/20/JAVA%E4%B9%8BFuture%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/20/JAVA之Future模式/</id>
    <published>2017-06-20T13:36:05.000Z</published>
    <updated>2017-06-20T15:24:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>Future模式有点类似商品订单，比如在进行网上购物时，当看中某一件商品时，就可以提交订单。当订单处理完毕后，便可在家里等待商品送货上门。卖家根据订单从仓库里取货，并配送到客户手上。在大部分情况下，商家对订单的处理并不那么快，而在这段时间内，客户完全不必傻傻地在家里等待，可以出门处理其他事物。</p>
<h3 id="2-传统串行调用-VS-Future模式"><a href="#2-传统串行调用-VS-Future模式" class="headerlink" title="2. 传统串行调用 VS Future模式"></a>2. 传统串行调用 <code>VS</code> Future模式</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-20/29048455.jpg" alt=""></p>
<p>图1所示，客户端发出call请求，这个请求需要相当长一段时间才能返回。客户端一直等待，直到数据返回，随后，在进行其他任务的处理。</p>
<p>图2显示了一个广义Future模式的实现，从Data_Future对象可以看到，虽然call本身处理仍然需要很长一段时间来处理程序，但是服务程序不等数据处理完成便立即返回客户端一个伪造的数据，实现了Future模式的客户。</p>
<h3 id="3-Future模式的主要参与者"><a href="#3-Future模式的主要参与者" class="headerlink" title="3. Future模式的主要参与者"></a>3. Future模式的主要参与者</h3><table>
<thead>
<tr>
<th>参与者</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Main</td>
<td>系统启动，调用Client发出请求</td>
</tr>
<tr>
<td>Client</td>
<td>返回Data对象，立即返回FutureData，并开启ClientThread线程装配RealData</td>
</tr>
<tr>
<td>Data</td>
<td>返回数据接口</td>
</tr>
<tr>
<td>FutureData</td>
<td>Future数据，构造很快，但是是一个虚拟的数据，需要装配RealData</td>
</tr>
<tr>
<td>RealData</td>
<td>真实数据，其构造是比较慢的</td>
</tr>
</tbody>
</table>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-20/16429145.jpg" alt=""></p>
<h3 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h3><h4 id="1-Data接口"><a href="#1-Data接口" class="headerlink" title="1) Data接口"></a>1) Data接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Data &#123;</div><div class="line">    String getResult();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-真实数据RealData"><a href="#2-真实数据RealData" class="headerlink" title="2) 真实数据RealData"></a>2) 真实数据<code>RealData</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class RealData implements Data &#123;</div><div class="line">    protected final String result;</div><div class="line"></div><div class="line">    public RealData(String para) &#123;</div><div class="line">        StringBuffer sb = new StringBuffer();</div><div class="line">        for(int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            sb.append(para);</div><div class="line">            try&#123;</div><div class="line">                Thread.sleep(100);</div><div class="line">            &#125;catch (InterruptedException e)&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        result = sb.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String getResult() &#123;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3）FutureData"><a href="#3）FutureData" class="headerlink" title="3）FutureData"></a>3）FutureData</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class FutureData implements Data &#123;</div><div class="line">    protected RealData realData = null;</div><div class="line">    protected boolean isReady = false;</div><div class="line">    public synchronized void setRealData(RealData realData) &#123;</div><div class="line">        if (isReady) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        this.realData = realData;</div><div class="line">        isReady = true;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public synchronized String getResult() &#123;</div><div class="line">        while (!isReady) &#123;</div><div class="line">            try &#123;</div><div class="line">                wait();</div><div class="line">            &#125;catch (InterruptedException e)&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return realData.result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-客户端Client"><a href="#4-客户端Client" class="headerlink" title="4) 客户端Client"></a>4) 客户端<code>Client</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public Data request(final String queryStr) &#123;</div><div class="line">        final FutureData future = new FutureData();</div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            RealData realData = new RealData(queryStr);</div><div class="line">            future.setRealData(realData);</div><div class="line">        &#125;).start();</div><div class="line">        return future;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-入口Run"><a href="#5-入口Run" class="headerlink" title="5) 入口Run"></a>5) 入口<code>Run</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Client client = new Client();</div><div class="line">        Data data = client.request(&quot;name&quot;);</div><div class="line">        System.out.println(&quot;请求完毕!&quot;);</div><div class="line">        try&#123;</div><div class="line">            Thread.sleep(100);</div><div class="line">        &#125;catch (InterruptedException e)&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;数据 =&gt; &quot; + data.getResult());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-运行结果"><a href="#6-运行结果" class="headerlink" title="6) 运行结果"></a>6) 运行结果</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-20/38834317.jpg" alt=""></p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><ol>
<li>Java程序性能优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;Future模式有点类似商品订单，比如在进行网上购物时，当看中某一件商品时，就可以提交订单。当订单处理完毕后，便可在家里
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA观察者模式</title>
    <link href="http://jianwl.com/2017/06/18/JAVA%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/18/JAVA观察者模式/</id>
    <published>2017-06-18T14:27:32.000Z</published>
    <updated>2017-06-18T15:00:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>观察者模式是非常常用的一种设计模式，在软件系统中，当一个对象的行为依赖另一个对象的状态时，观察者模式相当有用。若不使用观察者模式提供的通用结构，而需要实现其类似的功能，则只能在另一个线程中不停监听对象所依赖的状态。在一个复杂系统中，可能会因此开启很多线程来实现这一功能，这将使系统的性能产生额外的负担。</p>
<h3 id="2-观察者模式角色"><a href="#2-观察者模式角色" class="headerlink" title="2. 观察者模式角色"></a>2. 观察者模式角色</h3><table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>主题接口</td>
<td>指被观察的对象，当其状态发生变化或者某事件发生时，它会将这个变化通知观察者。它维护了观察者所需要依赖的状态</td>
</tr>
<tr>
<td>具体主题</td>
<td>具体主题实现了主题接口中的方法，如新增观察者、删除观察者和通知观察者。其内部维护一个观察者列表</td>
</tr>
<tr>
<td>观察者接口</td>
<td>观察者接口定义了观察者的基本方法，当依赖状态发生改变时，主题接口就会调用观察者的update()方法</td>
</tr>
<tr>
<td>具体观察者</td>
<td>实现了观察者接口的update()，具体处理当被观察者状态改变或者某一事件发生时的业务逻辑</td>
</tr>
</tbody>
</table>
<h3 id="3-观察者模式类图"><a href="#3-观察者模式类图" class="headerlink" title="3. 观察者模式类图"></a>3. 观察者模式类图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-18/26557541.jpg" alt=""></p>
<h3 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h3><h4 id="主题接口ISubject"><a href="#主题接口ISubject" class="headerlink" title="主题接口ISubject"></a>主题接口<code>ISubject</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface ISubject &#123;</div><div class="line">    void attach(IObserver observer); // 添加观察者</div><div class="line">    void detach(IObserver observer); // 删除观察者</div><div class="line">    void inform(String msg); // 通知所有观察者</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="具体主题ConcreteSubject"><a href="#具体主题ConcreteSubject" class="headerlink" title="具体主题ConcreteSubject"></a>具体主题<code>ConcreteSubject</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class ConcreteSubject implements ISubject &#123;</div><div class="line">    Vector&lt;IObserver&gt; observers = new Vector&lt;IObserver&gt;();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void attach(IObserver observer) &#123;</div><div class="line">        observers.addElement(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void detach(IObserver observer) &#123;</div><div class="line">        observers.removeElement(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void inform(String msg) &#123;</div><div class="line">        for(IObserver ob:observers) &#123;</div><div class="line">            ob.update(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="观察者接口"><a href="#观察者接口" class="headerlink" title="观察者接口"></a>观察者接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface IObserver &#123;</div><div class="line">    void update(String msg); // 更新观察者</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="具体观察者"><a href="#具体观察者" class="headerlink" title="具体观察者"></a>具体观察者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class ConcreteObserve implements IObserver &#123;</div><div class="line">    @Override</div><div class="line">    public void update(String msg) &#123;</div><div class="line">        System.out.println(&quot;observe receive information =&gt; &quot; + JSON.toJSONString(msg));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="入口Run"><a href="#入口Run" class="headerlink" title="入口Run"></a>入口<code>Run</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ConcreteSubject subject = new ConcreteSubject();</div><div class="line">        ConcreteObserve observeA = new ConcreteObserve();</div><div class="line">        ConcreteObserve observeB = new ConcreteObserve();</div><div class="line">        subject.attach(observeA);</div><div class="line">        subject.attach(observeB);</div><div class="line">        subject.inform(&quot;notify-1&quot;);</div><div class="line">        subject.detach(observeB);</div><div class="line">        subject.inform(&quot;notify-2&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-18/64270257.jpg" alt=""></p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><ol>
<li>JAVA程序性能优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;观察者模式是非常常用的一种设计模式，在软件系统中，当一个对象的行为依赖另一个对象的状态时，观察者模式相当有用。若不使用观
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA之享元模式</title>
    <link href="http://jianwl.com/2017/06/17/JAVA%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/17/JAVA之享元模式/</id>
    <published>2017-06-17T10:05:18.000Z</published>
    <updated>2017-06-18T06:41:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>享元模式是设计模式中少数几个以提高系统性能为目的的模式之一；它的核心思想是：<strong>如果在一个系统中存在多个相同的对象，那么只需要共享一份对象的拷贝，而不必为每一次使用都创建新的对象。</strong></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>可以节省重复创建对象的开销；</li>
<li>创建对象的数量减少，对系统的内存需求也减小，使得GC的压力降低；</li>
</ol>
<h3 id="2-享元模式角色"><a href="#2-享元模式角色" class="headerlink" title="2. 享元模式角色"></a>2. 享元模式角色</h3><table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>享元工厂</td>
<td>用以创建具体享元类，维护相同的单元对象。它保证相同的享元对象可以被系统共享。即内部使用了类似单例模式的算法，当请求对象已经存在时，直接返回对象，不存在时，再创建对象</td>
</tr>
<tr>
<td>抽象享元</td>
<td>定义需共享的对象的业务接口。享元类被创建出来总是为了实现某些特定的业务逻辑，而抽象享元便定义这些逻辑的语义行为</td>
</tr>
<tr>
<td>具体享元类</td>
<td>实现抽象享元类的接口，完成某一具体的逻辑</td>
</tr>
<tr>
<td>Main</td>
<td>使用享元模式的组件，通过享元工厂取得享元对象</td>
</tr>
</tbody>
</table>
<h3 id="3-实战"><a href="#3-实战" class="headerlink" title="3. 实战"></a>3. 实战</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-18/33093517.jpg" alt=""></p>
<h4 id="可运行实例"><a href="#可运行实例" class="headerlink" title="可运行实例"></a>可运行实例</h4><h5 id="1、-抽象享元IReportManager"><a href="#1、-抽象享元IReportManager" class="headerlink" title="1、 抽象享元IReportManager"></a>1、 抽象享元<code>IReportManager</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface IReportManager &#123;</div><div class="line">     String createReport();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2、-具体享元类-EmployeeReportManager"><a href="#2、-具体享元类-EmployeeReportManager" class="headerlink" title="2、 具体享元类 EmployeeReportManager"></a>2、 具体享元类 <code>EmployeeReportManager</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class EmployeeReportManager implements IReportManager &#123;</div><div class="line">    protected String tenantId = null;</div><div class="line"></div><div class="line">    public EmployeeReportManager(String tenantId) &#123;</div><div class="line">        this.tenantId = tenantId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String createReport() &#123;</div><div class="line">        return &quot;This is a employee report&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3、-具体享元类-FinancialReportManager"><a href="#3、-具体享元类-FinancialReportManager" class="headerlink" title="3、 具体享元类 FinancialReportManager"></a>3、 具体享元类 <code>FinancialReportManager</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class FinancialReportManager implements IReportManager &#123;</div><div class="line">    protected String tenantId = null;</div><div class="line"></div><div class="line">    public FinancialReportManager(String tenantId) &#123;</div><div class="line">        this.tenantId = tenantId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String createReport() &#123;</div><div class="line">        return &quot;This is a financial report&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4、-享元工厂ReportManagerFactory"><a href="#4、-享元工厂ReportManagerFactory" class="headerlink" title="4、 享元工厂ReportManagerFactory"></a>4、 享元工厂<code>ReportManagerFactory</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ReportManagerFactory &#123;</div><div class="line">    Map&lt;String,IReportManager&gt; finanacialReportManager = new HashMap&lt;String,IReportManager&gt;();</div><div class="line">    Map&lt;String,IReportManager&gt; employeeReportManager = new HashMap&lt;String,IReportManager&gt;();</div><div class="line"></div><div class="line">    IReportManager getFinancialReportManager(String tenantId)&#123;</div><div class="line">        IReportManager r = finanacialReportManager.get(tenantId);</div><div class="line">        if (r == null) &#123;</div><div class="line">            r = new FinancialReportManager(tenantId);</div><div class="line">            finanacialReportManager.put(tenantId,r);</div><div class="line">        &#125;</div><div class="line">        return r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    IReportManager getEmployeeReportReportManger(String tenantId)&#123;</div><div class="line">        IReportManager r = employeeReportManager.get(tenantId);</div><div class="line">        if (r == null) &#123;</div><div class="line">            r = new EmployeeReportManager(tenantId);</div><div class="line">            employeeReportManager.put(tenantId,r);</div><div class="line">        &#125;</div><div class="line">        return r;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5、-入口Run"><a href="#5、-入口Run" class="headerlink" title="5、 入口Run"></a>5、 入口<code>Run</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ReportManagerFactory rmf = new ReportManagerFactory();</div><div class="line">        IReportManager rm = rmf.getFinancialReportManager(&quot;A&quot;);</div><div class="line">        System.out.println(rm.createReport());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="6-运行结果"><a href="#6-运行结果" class="headerlink" title="6. 运行结果"></a>6. 运行结果</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-18/81872942.jpg" alt=""></p>
<h3 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h3><ol>
<li>JAVA程序性能优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;享元模式是设计模式中少数几个以提高系统性能为目的的模式之一；它的核心思想是：&lt;strong&gt;如果在一个系统中存在多个相同
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA之装饰者模式</title>
    <link href="http://jianwl.com/2017/06/09/JAVA%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/09/JAVA之装饰者模式/</id>
    <published>2017-06-09T00:31:39.000Z</published>
    <updated>2017-06-10T03:23:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>装饰者模式拥有一个设计非常精巧的结构，它可以动态添加对象功能，在基本的设计原则中，有一条重要的设计准则叫做<strong>合成/聚合复用原则。</strong>根据该原则的思想，代码复用应该尽可能使用委托，而不是使用继承。因为继承是一种紧密耦合，任何父类的改动都会影响其子类，不利于系统维护。而委托则是松散耦合，只要接口不变，委托类的改动并不会影响上层对象。</p>
<p>装饰者模式就充分运用了这种思想，通过委托机制，复用系统中的各个组件，在运行时，可以将这些功能进行叠加，从而构造一个“超级对象”，使其拥有所有这些组件的功能。而各个子模块功能，被很好地维护在各个组件的相关类中 ，拥有整洁的系统结构。</p>
<h3 id="2-装饰者模式基本结构"><a href="#2-装饰者模式基本结构" class="headerlink" title="2. 装饰者模式基本结构"></a>2. 装饰者模式基本结构</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-9/53287711.jpg" alt=""></p>
<p>装饰者(Decorator) 和被装饰者(ConcreteComponent)拥有相同的接口Component，被装饰者通常是系统的核心组件，完成特定的功能目标。而装饰者则可以在被装饰者的方法前后，加上特定的前置处理和后置处理，增强被装饰者的功能。</p>
<p>装饰者模式角色</p>
<table>
<thead>
<tr>
<th style="text-align:left">角色</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">组件接口</td>
<td style="text-align:center">组件接口是装饰者和被装饰者的超类或接口，它定义了被装饰者的核心功能和装饰者需要加强的功能点。</td>
</tr>
<tr>
<td style="text-align:left">具体组件</td>
<td style="text-align:center">具体组件实现了组件接口的核心方法，完成某一个具体的业务逻辑，它也是被装饰的对象</td>
</tr>
<tr>
<td style="text-align:left">装饰者</td>
<td style="text-align:center">实现组件接口，并持有一个具体的被装饰对象</td>
</tr>
<tr>
<td style="text-align:left">具体装饰者</td>
<td style="text-align:center">具体实现装饰的业务逻辑，即实现了被分离的各个增强功能点，各个具体装饰者是可以相互叠加的，从而可以构成一个功能更强大的组件对象</td>
</tr>
</tbody>
</table>
<h3 id="3-实战"><a href="#3-实战" class="headerlink" title="3. 实战"></a>3. 实战</h3><h4 id="1）场景描述"><a href="#1）场景描述" class="headerlink" title="1）场景描述"></a>1）场景描述</h4><p>将某一结果通过HTML进行发布，那么首先就需要将内容转化为一个HTML文本，同时由于内容要在网络上通过HTTP流传，故还需要为其增加HTTP头。</p>
<h4 id="2）类图"><a href="#2）类图" class="headerlink" title="2）类图"></a>2）类图</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-10/63142422.jpg" alt=""></p>
<h4 id="3-可运行实例"><a href="#3-可运行实例" class="headerlink" title="3) 可运行实例"></a>3) 可运行实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">// Component</div><div class="line">public interface IPacketCreator &#123;</div><div class="line">    String handleContent();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Concrete Component</div><div class="line">public class PacketBodyCreator implements IPacketCreator &#123;</div><div class="line">    @Override</div><div class="line">    public String handleContent() &#123;</div><div class="line">        return &quot;Content of Packet&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Decorator</div><div class="line">public abstract class PacketDecorator implements IPacketCreator &#123;</div><div class="line">    IPacketCreator component;</div><div class="line"></div><div class="line">    public PacketDecorator(IPacketCreator component) &#123;</div><div class="line">        this.component = component;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Concrete Decorator</div><div class="line">public class PacketHTTPHeaderCreator extends PacketDecorator &#123;</div><div class="line">    public PacketHTTPHeaderCreator(IPacketCreator component) &#123;</div><div class="line">        super(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String handleContent() &#123;</div><div class="line">        StringBuffer sb = new StringBuffer();</div><div class="line">        sb.append(&quot;Cache-Control:no-cache\n&quot;);</div><div class="line">        sb.append(&quot;Date:2017-06-10\n&quot;);</div><div class="line">        sb.append(component.handleContent());</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Concrete Decorator</div><div class="line">public class PacketHTMLHeaderCreator extends PacketDecorator &#123;</div><div class="line"></div><div class="line">    public PacketHTMLHeaderCreator(IPacketCreator component) &#123;</div><div class="line">        super(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String handleContent() &#123;</div><div class="line">        StringBuffer sb = new StringBuffer();</div><div class="line">        sb.append(&quot;&lt;html&gt;&quot;);</div><div class="line">        sb.append(&quot;&lt;body&gt;&quot;);</div><div class="line">        sb.append(component.handleContent());</div><div class="line">        sb.append(&quot;&lt;/body&gt;&quot;);</div><div class="line">        sb.append(&quot;&lt;/html&gt;\n&quot;);</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 运行</div><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        IPacketCreator pc = new PacketHTTPHeaderCreator(new PacketHTMLHeaderCreator(new PacketBodyCreator()));</div><div class="line">        System.out.println(pc.handleContent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-10/21550495.jpg" alt=""></p>
<h3 id="4-JDK中用装饰者的实例"><a href="#4-JDK中用装饰者的实例" class="headerlink" title="4. JDK中用装饰者的实例"></a>4. JDK中用装饰者的实例</h3><h4 id="1-描述"><a href="#1-描述" class="headerlink" title="1) 描述"></a>1) 描述</h4><p>OutStream为核心的装饰者模式的实现，其中FileOutputStream为系统的核心类，它实现了向文件写入数据。使用DataOutputStream可以在FileOutputStream的基础上，增加对多种数据类型的写操作，而BufferedOutputStream秀使其，可以对FileOutputStream增加缓冲功能，优化I/O的性能，以BufferedOutputStream为代表的性能组件，是将性能模块和功能模块分离的一种典型实现。</p>
<h4 id="2-类图"><a href="#2-类图" class="headerlink" title="2) 类图"></a>2) 类图</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-10/56315217.jpg" alt=""></p>
<h4 id="3）可运行实例"><a href="#3）可运行实例" class="headerlink" title="3）可运行实例"></a>3）可运行实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class OutputStreamTest &#123;</div><div class="line">    public static void notBufferOut()&#123;</div><div class="line">        long start = System.currentTimeMillis();</div><div class="line">        try &#123;</div><div class="line">            DataOutputStream dout = new DataOutputStream(new FileOutputStream(&quot;/Users/jianweilin/Desktop/output1.txt&quot;));</div><div class="line">            for (int i=0; i&lt; 1000; i++) &#123;</div><div class="line">                dout.writeInt(i);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;notBufferOut spend =&gt; &quot; + (System.currentTimeMillis() - start));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void bufferOut()&#123;</div><div class="line">        long start = System.currentTimeMillis();</div><div class="line">        try &#123;</div><div class="line">            DataOutputStream dout = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(&quot;/Users/jianweilin/Desktop/output2.txt&quot;)));</div><div class="line">            for (int i=0; i&lt; 1000; i++) &#123;</div><div class="line">                dout.writeInt(i);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;bufferOut spend =&gt; &quot; + (System.currentTimeMillis() - start));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        notBufferOut();</div><div class="line">        bufferOut();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结果</div><div class="line">// notBufferOut spend =&gt; 11</div><div class="line">// bufferOut spend =&gt; 1</div></pre></td></tr></table></figure>
<h4 id="4-工作流程图"><a href="#4-工作流程图" class="headerlink" title="4) 工作流程图"></a>4) 工作流程图</h4><p><code>FileOutputStream.write()</code>的调用之前，会首先调用<code>BufferedOutputStream.write()</code>。且<code>BufferedOutputStream.write()</code>不会每次都去磁盘写数据，而是将数据写入缓存，当缓存满时，才会调用<code>FileOutputStream.write()</code>方法，实际写入数据。以此实现性能组件与功能组件的分离。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-10/51627202.jpg" alt=""></p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><ol>
<li>Java程序性能优化 by 葛一鸣</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;装饰者模式拥有一个设计非常精巧的结构，它可以动态添加对象功能，在基本的设计原则中，有一条重要的设计准则叫做&lt;strong
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>单例模式之性能比较</title>
    <link href="http://jianwl.com/2017/06/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"/>
    <id>http://jianwl.com/2017/06/08/单例模式之性能比较/</id>
    <published>2017-06-08T14:00:55.000Z</published>
    <updated>2017-06-08T14:48:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>设计模式是前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是对某一特定问题的成熟解决方案。如果能合理地使用设计模式，不仅能使系统更容易被他人理解，同时也能使系统拥有更加合理的结构。本节将对单例模式多种实现进行性能分析。</p>
<h3 id="2-单例模式的好处"><a href="#2-单例模式的好处" class="headerlink" title="2. 单例模式的好处"></a>2. 单例模式的好处</h3><ol>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于new操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间。</li>
</ol>
<h3 id="3-多种实现方式"><a href="#3-多种实现方式" class="headerlink" title="3. 多种实现方式"></a>3. 多种实现方式</h3><h4 id="1-简单的单例实现"><a href="#1-简单的单例实现" class="headerlink" title="1) 简单的单例实现"></a>1) 简单的单例实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton instance = new Singleton();</div><div class="line"></div><div class="line">    private Singleton() &#123;</div><div class="line">        System.out.println(&quot;Singleton is create&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Singleton getInstance()&#123;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void createString()&#123;</div><div class="line">        System.out.println(&quot;createString in Singleton&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Singleton.createString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缺点是无法对instance实例延迟加载，在任何地方使用这个单例类都会初始化这个单例变量，就如例子中的一样，仅仅只调用<code>createString</code>方法，也会初始化单例变量；</p>
<h4 id="2-延迟加载"><a href="#2-延迟加载" class="headerlink" title="2) 延迟加载"></a>2) 延迟加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class LazySingleton &#123;</div><div class="line">    private static LazySingleton instance = null;</div><div class="line"></div><div class="line">    private LazySingleton()&#123;</div><div class="line">        System.out.println(&quot;LazySingleton is create&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static synchronized LazySingleton getInstance()&#123;</div><div class="line">        if (instance == null) &#123;</div><div class="line">            instance = new LazySingleton();</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void createString()&#123;</div><div class="line">        System.out.println(&quot;createString in Singleton&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        LazySingleton.createString()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 结果</div><div class="line">// createString in Singleton</div></pre></td></tr></table></figure>
<p>为了解决例1中的问题，引入延迟加载机制，但这种延迟加载有一致命的缺点，因为引入了同步关键字，在多线程环境时耗远远大于第一种单例模式。</p>
<h4 id="3-改进"><a href="#3-改进" class="headerlink" title="3) 改进"></a>3) 改进</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class StaticSingleton &#123;</div><div class="line">    private StaticSingleton()&#123;</div><div class="line">        System.out.println(&quot;StaticSingleton is create&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class SingletonHolder &#123;</div><div class="line">        private static StaticSingleton instance = new StaticSingleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static StaticSingleton getInstance()&#123;</div><div class="line">        return SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例2为了使用延迟加载引入同步关键字降低了性能，为了解决这个问题，引入例3。当StaticSingleton被加载时，内部类不会被初始化。</p>
<h4 id="4-三种模式性能比较"><a href="#4-三种模式性能比较" class="headerlink" title="4) 三种模式性能比较"></a>4) 三种模式性能比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">// 实现1</div><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton instance = new Singleton();</div><div class="line"></div><div class="line">    public static Singleton getInstance()&#123;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实现2</div><div class="line">public class LazySingleton &#123;</div><div class="line">    private static LazySingleton instance = null;</div><div class="line"></div><div class="line">    public static synchronized LazySingleton getInstance()&#123;</div><div class="line">        if (instance == null) &#123;</div><div class="line">            instance = new LazySingleton();</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实现3</div><div class="line">public class StaticSingleton &#123;</div><div class="line">    private static class SingletonHolder &#123;</div><div class="line">        private static StaticSingleton instance = new StaticSingleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static StaticSingleton getInstance()&#123;</div><div class="line">        return SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 主类</div><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            long startTime = System.currentTimeMillis();</div><div class="line">            for (int j = 0; j &lt; 100000000; j++) &#123;</div><div class="line">                Singleton.getInstance();</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;Singleton spend =&gt; &quot; + (System.currentTimeMillis() - startTime));</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            long startTime = System.currentTimeMillis();</div><div class="line">            for (int j = 0; j &lt; 100000000; j++) &#123;</div><div class="line">                LazySingleton.getInstance();</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;LazySingleton spend =&gt; &quot; + (System.currentTimeMillis() - startTime));</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            long startTime = System.currentTimeMillis();</div><div class="line">            for (int j = 0; j &lt; 100000000; j++) &#123;</div><div class="line">                StaticSingleton.getInstance();</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;StaticSingleton spend =&gt; &quot; + (System.currentTimeMillis() - startTime));</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结果</div><div class="line">// Singleton spend =&gt; 8</div><div class="line">// StaticSingleton spend =&gt; 10</div><div class="line">// LazySingleton spend =&gt; 3268</div></pre></td></tr></table></figure>
<h3 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h3><ol>
<li>Java程序性能优化 by 葛一鸣</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;设计模式是前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是对某一特定问题的成熟解决方案。如果能合理地使用设计模式
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Java之异常</title>
    <link href="http://jianwl.com/2017/06/04/Java%E4%B9%8B%E5%BC%82%E5%B8%B8-0/"/>
    <id>http://jianwl.com/2017/06/04/Java之异常-0/</id>
    <published>2017-06-04T04:26:45.000Z</published>
    <updated>2017-06-04T05:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-4/26082118.jpg" alt=""></p>
<p>在Java程序运行时，常常会出现一些非正常现象，根据其性质分为<strong>错误和异常。</strong> Java程序中，所有抛出的异常都必须从<code>Throwable</code>派生而来。Throwable有两个直接子类：Error和Exception。</p>
<p>Error</p>
<p>常见的错误有程序进入死循环、内存泄露等</p>
<p>Exception</p>
<p>异常分为受检异常 &amp; 非受检异常。受检异常是去除RuntimeExeption的其他直接继承Exception的子类；非受检异常是直接继承RunTimeException的子类；</p>
<p>对于受检异常，必须要用<code>try catch</code>去处理这个异常，或者在方法加上<code>throws</code>暗示这个方法可能会抛出某种异常。</p>
<p>非受检异常，不需要明确地去处理这个异常；</p>
<h3 id="2-受检异常-amp-非受检异常实战"><a href="#2-受检异常-amp-非受检异常实战" class="headerlink" title="2. 受检异常 &amp; 非受检异常实战"></a>2. 受检异常 &amp; 非受检异常实战</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-4/31638990.jpg" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://stackoverflow.com/questions/2190161/difference-between-java-lang-runtimeexception-and-java-lang-exception" target="_blank" rel="external">difference between java.lang.RuntimeException and java.lang.Exception</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 基本概念&quot;&gt;&lt;/a&gt;1. 基本概念&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.clouddn.com/17-6-4/26
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
</feed>
