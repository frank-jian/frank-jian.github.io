<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录点滴成长</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianwl.com/"/>
  <updated>2018-07-01T01:34:34.663Z</updated>
  <id>http://jianwl.com/</id>
  
  <author>
    <name>流云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语法概述</title>
    <link href="http://jianwl.com/2018/07/01/Go%E8%AF%AD%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    <id>http://jianwl.com/2018/07/01/Go语法概述/</id>
    <published>2018-07-01T01:19:24.000Z</published>
    <updated>2018-07-01T01:34:34.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为之前已经有编程基础了，所以在接触新语言时，会预先概览语言的语法，而后在针对每个语法深入学习。本节会描述Go常用的语法规则。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="1-编程第一个Go程序"><a href="#1-编程第一个Go程序" class="headerlink" title="1. 编程第一个Go程序"></a>1. 编程第一个Go程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">// 输出Hello world!</div><div class="line">func main() &#123;</div><div class="line">	fmt.Println(&quot;hello world!&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-声明变量"><a href="#2-声明变量" class="headerlink" title="2. 声明变量"></a>2. 声明变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">// 方式1</div><div class="line">func defineVar1()&#123;</div><div class="line">	var x int32</div><div class="line">	var s = &quot;hello world&quot;</div><div class="line">	println(x,s)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 方式2</div><div class="line">func defineVar2()&#123;</div><div class="line">	x := 100</div><div class="line">	println(x)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 定义变量</div><div class="line">func main() &#123;</div><div class="line">	defineVar1()</div><div class="line">	defineVar2()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-1-表达式if"><a href="#3-1-表达式if" class="headerlink" title="3.1 表达式if"></a>3.1 表达式if</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">// 表达式</div><div class="line">func main() &#123;</div><div class="line">	x := 100</div><div class="line"></div><div class="line">	if x &gt; 0 &#123;</div><div class="line">		println(&quot;x&quot;)</div><div class="line">	&#125;else if x &lt; 0 &#123;</div><div class="line">		println(&quot;-x&quot;)</div><div class="line">	&#125;else&#123;</div><div class="line">		println(&quot;0&quot;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-2-表达式switch"><a href="#3-2-表达式switch" class="headerlink" title="3.2 表达式switch"></a>3.2 表达式switch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// switch</div><div class="line">func main() &#123;</div><div class="line">	x := 100</div><div class="line"></div><div class="line">	switch &#123;</div><div class="line">	case x &gt; 0:</div><div class="line">		println(&quot;x&quot;)</div><div class="line">	case x &lt; 0:</div><div class="line">		println(&quot;-x&quot;)</div><div class="line">	default:</div><div class="line">		println(&quot;0&quot;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-3-表达式for"><a href="#3-3-表达式for" class="headerlink" title="3.3 表达式for"></a>3.3 表达式for</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">func for01()&#123;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for01 &gt;&gt;&gt;&gt;&gt;&quot;)</div><div class="line">	for i:=0; i&lt;5;i++&#123;</div><div class="line">		println(i)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	for i := 4; i&gt;=0;i--&#123;</div><div class="line">		println(i)</div><div class="line">	&#125;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for01 &gt;&gt;&gt;&gt;&gt;\n&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func for02()&#123;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for02 &gt;&gt;&gt;&gt;&gt;&quot;)</div><div class="line">	x := 0</div><div class="line"></div><div class="line">	for x &lt; 5&#123;</div><div class="line">		println(x)</div><div class="line">		x++</div><div class="line">	&#125;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for02 &gt;&gt;&gt;&gt;&gt;\n&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func for03()&#123;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for03 &gt;&gt;&gt;&gt;&gt;&quot;)</div><div class="line">	x := 4</div><div class="line"></div><div class="line">	for &#123;</div><div class="line">		println(x)</div><div class="line">		x--</div><div class="line"></div><div class="line">		if x&lt;0&#123;</div><div class="line">			break</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for03 &gt;&gt;&gt;&gt;&gt;\n&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func for04()&#123;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for04 &gt;&gt;&gt;&gt;&gt;&quot;)</div><div class="line"></div><div class="line">	x := []int&#123;100,101,102&#125;</div><div class="line"></div><div class="line">	for i,n :=range x&#123;</div><div class="line">		println(i,&quot;:&quot;,n)</div><div class="line">	&#125;</div><div class="line">	println(&quot;&gt;&gt;&gt;&gt; for04 &gt;&gt;&gt;&gt;&gt;\n&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 多种循环</div><div class="line">func main() &#123;</div><div class="line">	for01()</div><div class="line">	for02()</div><div class="line">	for03()</div><div class="line">	for04()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;errors&quot;</div><div class="line">	&quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line">// 函数: 可定义多个返回值</div><div class="line">func div(a,b int) (int,error)&#123;</div><div class="line">	if b==0&#123;</div><div class="line">		return 0,errors.New(&quot;division by zero&quot;)</div><div class="line">	&#125;</div><div class="line">	return a/b, nil</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 函数是第一类型，可作为参数或返回值</div><div class="line">func print01(x int) func()&#123;</div><div class="line">	return func()&#123;</div><div class="line">		println(x)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// defer定义延迟调用，无论函数是否出错，它都确保结束前被调用</div><div class="line">func defer01(a,b int)&#123;</div><div class="line">	defer println(&quot;dispace ...&quot;)</div><div class="line"></div><div class="line">	println(a/b)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	a,b := 10,2</div><div class="line">	c,err := div(a,b)</div><div class="line"></div><div class="line">	fmt.Println(c,err)</div><div class="line"></div><div class="line">	x := 100</div><div class="line"></div><div class="line">	f := print01(x)</div><div class="line">	f()</div><div class="line"></div><div class="line">	defer01(10,2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-切片"><a href="#5-切片" class="headerlink" title="5. 切片"></a>5. 切片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">// 切片(slice)可实现类似动态数组的功能</div><div class="line">func main() &#123;</div><div class="line">	x := make([]int, 0,5) // 创建容量为5的切片</div><div class="line"></div><div class="line">	for i:=0; i&lt;8;i++&#123;</div><div class="line">		x = append(x,i) // 追加数据，当容量超出，自动分配更大的存储空间</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	fmt.Println(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-字典"><a href="#6-字典" class="headerlink" title="6. 字典"></a>6. 字典</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">// 将字典(map)类型内置，可直接从运行时层面获得性能优化</div><div class="line">func main() &#123;</div><div class="line">	m := make(map[string]int) // 创建字典对象</div><div class="line"></div><div class="line">	m[&quot;a&quot;] = 1 // 添加</div><div class="line"></div><div class="line">	x,ok := m[&quot;b&quot;] // 可知道key/value 是否存在</div><div class="line"></div><div class="line">	fmt.Println(x,ok)</div><div class="line">	delete(m,&quot;a&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-结构体"><a href="#7-结构体" class="headerlink" title="7. 结构体"></a>7. 结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">type user struct &#123; // 结构体</div><div class="line">	name string</div><div class="line">	age byte</div><div class="line">&#125;</div><div class="line"></div><div class="line">type manager struct &#123;</div><div class="line">	user // 匿名嵌入其他类型</div><div class="line">	title string</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结构体：可匿名嵌入其他类型</div><div class="line">func main() &#123;</div><div class="line">	var m manager</div><div class="line"></div><div class="line">	m.name = &quot;Tom&quot;</div><div class="line">	m.age = 29</div><div class="line">	m.title = &quot;cto&quot;</div><div class="line"></div><div class="line">	fmt.Println(m)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="8-方法"><a href="#8-方法" class="headerlink" title="8. 方法"></a>8. 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">type X int</div><div class="line"></div><div class="line">func (x *X) inc()&#123; // 名称前的参数称作receiver，作用类似python self</div><div class="line">	*x++</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 方法，可以为当前包内的任意类型定义方法</div><div class="line">func main() &#123;</div><div class="line">	var x X</div><div class="line">	x.inc()</div><div class="line">	println(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="9-接口"><a href="#9-接口" class="headerlink" title="9. 接口"></a>9. 接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import &quot;fmt&quot;</div><div class="line"></div><div class="line">type role struct &#123;</div><div class="line">	name string</div><div class="line">	parentId int</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (r role) Print()&#123;</div><div class="line">	fmt.Printf(&quot;%+v\n&quot;,r)</div><div class="line">&#125;</div><div class="line"></div><div class="line">type Printer interface &#123;</div><div class="line">	Print()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接口采用了duck type方式，也就是说无须在实现类型上添加显式声明。</div><div class="line">// 另有空接口类型interface&#123;&#125;,用途类似OOP里的system.Object,可接受任意类型对象</div><div class="line">func main() &#123;</div><div class="line">	var r role</div><div class="line">	r.name = &quot;admin&quot;</div><div class="line">	r.parentId = 29</div><div class="line"></div><div class="line">	var p Printer = r</div><div class="line">	p.Print()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="10-并发"><a href="#10-并发" class="headerlink" title="10. 并发"></a>10. 并发</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func task(id int)&#123;</div><div class="line">	for i:=0; i&lt;5;i++&#123;</div><div class="line">		fmt.Printf(&quot;%d:%d\n&quot;,id,i)</div><div class="line">		time.Sleep(time.Second)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 整体运行时完全并发设计，凡你能看到的，几乎都在以goroutine方式运行，这是一种比普通协程或线程更加高效的并发设计，能够</div><div class="line">// 轻松创建和运行成千上万的并发任务</div><div class="line">func main() &#123;</div><div class="line">	go task(1)  // 创建goroutine</div><div class="line">	go task(2)</div><div class="line"></div><div class="line">	time.Sleep(time.Second*6)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="11-通道-channel-与-goroutine搭配"><a href="#11-通道-channel-与-goroutine搭配" class="headerlink" title="11. 通道(channel) 与 goroutine搭配"></a>11. 通道(channel) 与 goroutine搭配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">// 消费者</div><div class="line">func consumer(data chan int, done chan bool)&#123;</div><div class="line">	for x:=range data&#123;</div><div class="line">		println(&quot;recv:&quot;,x)  // 接受数据，直到通道被关闭</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	done &lt;- true // 通知main，消费结束</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 生产者</div><div class="line">func producer(data chan int)&#123;</div><div class="line">	for i :=0; i&lt;4; i++&#123;</div><div class="line">		data &lt;- i         // 发送数据</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	close(data) // 生产结束，关闭通道</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通道(channel) 与 goroutine搭配，实现用通信替代内存共享的CSP模型</div><div class="line">func main() &#123;</div><div class="line">	done := make(chan bool) // 用于接收消费结束信息</div><div class="line">	data := make(chan int)  // 数据管道</div><div class="line"></div><div class="line">	go consumer(data, done) // 启动消费者</div><div class="line">	go producer(data) // 启动生产者</div><div class="line"></div><div class="line">	&lt;-done // 阻塞，直到消费者发回结束信息</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;因为之前已经有编程基础了，所以在接触新语言时，会预先概览语言的语法，而后在针对每个语法深入学习。本节会描述Go常用的语法规则。&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="Go" scheme="http://jianwl.com/categories/Go/"/>
    
    
      <category term="Go" scheme="http://jianwl.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Git的各种撤销技巧</title>
    <link href="http://jianwl.com/2018/06/20/Git%E7%9A%84%E5%90%84%E7%A7%8D%E6%92%A4%E9%94%80%E6%8A%80%E5%B7%A7/"/>
    <id>http://jianwl.com/2018/06/20/Git的各种撤销技巧/</id>
    <published>2018-06-19T23:53:43.000Z</published>
    <updated>2018-06-19T23:57:01.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://blog.github.com/2015-06-08-how-to-undo-almost-anything-with-git/" target="_blank" rel="external">How to undo anything with Git</a></li>
<li><a href="https://tonydeng.github.io/2015/07/08/how-to-undo-almost-anything-with-git/" target="_blank" rel="external">Git的各种Undo技巧</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.github.com/2015-06-08-how-to-undo-
    
    </summary>
    
      <category term="Git" scheme="http://jianwl.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://jianwl.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Spring容器的基本实现</title>
    <link href="http://jianwl.com/2018/06/04/Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jianwl.com/2018/06/04/Spring容器的基本实现/</id>
    <published>2018-06-04T00:14:01.000Z</published>
    <updated>2018-06-11T23:48:14.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这一节从实战到理论学习Spring容器的实现。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="1-核心依赖"><a href="#1-核心依赖" class="headerlink" title="1) 核心依赖"></a>1) 核心依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;parent&gt;</div><div class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;2.0.2.RELEASE&lt;/version&gt;</div><div class="line">	&lt;relativePath/&gt; </div><div class="line">&lt;/parent&gt;</div><div class="line"></div><div class="line">&lt;dependencies&gt;</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">	</div><div class="line">	&lt;dependency&gt;</div><div class="line">		&lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;5.0.6.RELEASE&lt;/version&gt;</div><div class="line">	&lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<h4 id="2）在容器中注册Bean-amp-获取Bean"><a href="#2）在容器中注册Bean-amp-获取Bean" class="headerlink" title="2）在容器中注册Bean &amp; 获取Bean"></a>2）在容器中注册Bean &amp; 获取Bean</h4><p>运行类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class MainBootstrap &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        BeanFactory bf = new XmlBeanFactory(new ClassPathResource(&quot;beanFactoryTest.xml&quot;));</div><div class="line">        MyTestBean bean = (MyTestBean) bf.getBean(&quot;myTestBean&quot;);</div><div class="line">        System.out.println(String.format(&quot;测试是否加载xml: %s&quot;,bean.getTestStr()));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>beanFactoryTest.xml文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">       xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">       xmlns:task=&quot;http://www.springframework.org/schema/task&quot;</div><div class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</div><div class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</div><div class="line">		http://www.springframework.org/schema/task</div><div class="line">        http://www.springframework.org/schema/task/spring-task-3.0.xsd</div><div class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;</div><div class="line">&gt;</div><div class="line">    &lt;bean id=&quot;myTestBean&quot; class=&quot;com.frank.springlearning.domain.MyTestBean&quot;/&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>以上完成了，Bean的注册和使用；</p>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>未完待续…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这一节从实战到理论学习Spring容器的实现。&lt;/p&gt;
&lt;h3 id=&quot;实战&quot;&gt;&lt;a href=&quot;#实战&quot; class=&quot;headerlin
    
    </summary>
    
      <category term="Spring源码学习专题" scheme="http://jianwl.com/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="Spring源码学习专题" scheme="http://jianwl.com/tags/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码学习计划</title>
    <link href="http://jianwl.com/2018/06/04/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://jianwl.com/2018/06/04/Spring源码学习计划/</id>
    <published>2018-06-03T23:58:32.000Z</published>
    <updated>2018-06-04T00:13:50.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>接触Spring有3年了，Spring的两大特性IOC和AOP在工作中也是常用，但是如果有人问我，Spring是如何实现这两大特性的，我一定只能模棱两可的说出。或许这个时候就是你该沉下心来，好好学习它的原理实现了，知其所以然，学习其思想。学习Spring这是一个专题，刻意学习，才能有所收获。</p>
<h3 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h3><ol>
<li>容器的基本实现；</li>
<li>AOP的基本实现；</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;接触Spring有3年了，Spring的两大特性IOC和AOP在工作中也是常用，但是如果有人问我，Spring是如何实现这两大特性的，我一定
    
    </summary>
    
      <category term="Spring源码学习专题" scheme="http://jianwl.com/categories/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="Spring源码学习专题" scheme="http://jianwl.com/tags/Spring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型之happens-before</title>
    <link href="http://jianwl.com/2018/05/20/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8Bhappens-before/"/>
    <id>http://jianwl.com/2018/05/20/Java内存模型之happens-before/</id>
    <published>2018-05-20T10:31:08.000Z</published>
    <updated>2018-05-20T11:01:21.079Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java语言中有一个“先行发生”的原则，它是判断数据是否存在竞争、线程是否安全的主要依据。下面是Java内存模型一些“天然”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p>
<h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><h4 id="1-程序次序规则"><a href="#1-程序次序规则" class="headerlink" title="1) 程序次序规则"></a>1) 程序次序规则</h4><p>在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p>
<h4 id="2）管程锁定规则"><a href="#2）管程锁定规则" class="headerlink" title="2）管程锁定规则"></a>2）管程锁定规则</h4><p>一个unlock操作先行发生于后面的对同一个锁的lock操作。这里必须强调是同一个锁，而“后面”同样是指时间上的先后顺序。</p>
<h4 id="3）volatile变量规则"><a href="#3）volatile变量规则" class="headerlink" title="3）volatile变量规则"></a>3）volatile变量规则</h4><p>对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</p>
<h4 id="4-线程启动规则"><a href="#4-线程启动规则" class="headerlink" title="4) 线程启动规则"></a>4) 线程启动规则</h4><p>Thread对象的start()方法先行发生于此线程的每一个动作。</p>
<h4 id="5）线程终止规则"><a href="#5）线程终止规则" class="headerlink" title="5）线程终止规则"></a>5）线程终止规则</h4><p>线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行了。</p>
<h4 id="6）线程中断规则"><a href="#6）线程中断规则" class="headerlink" title="6）线程中断规则"></a>6）线程中断规则</h4><p>对于线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生，可以通过Thread.interrupted方法检测到是否有中断发生。</p>
<h4 id="7）对象终结规则"><a href="#7）对象终结规则" class="headerlink" title="7）对象终结规则"></a>7）对象终结规则</h4><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的finilize()方法的开始。</p>
<h4 id="8）传递性"><a href="#8）传递性" class="headerlink" title="8）传递性"></a>8）传递性</h4><p>如果操作A先行发生于操作B，操作B先行发生于操作C，那么就可以得出操作A先行发生于操作C。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>深入理解Java虚拟机 - P376</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Java语言中有一个“先行发生”的原则，它是判断数据是否存在竞争、线程是否安全的主要依据。下面是Java内存模型一些“天然”先行发生关系，这
    
    </summary>
    
      <category term="Java进阶" scheme="http://jianwl.com/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java进阶" scheme="http://jianwl.com/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://jianwl.com/2018/05/20/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://jianwl.com/2018/05/20/Java内存模型/</id>
    <published>2018-05-20T08:10:13.000Z</published>
    <updated>2018-05-20T10:10:15.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java内存模型有什么用？"><a href="#Java内存模型有什么用？" class="headerlink" title="Java内存模型有什么用？"></a>Java内存模型有什么用？</h3><p>JVM规范定义Java内存模型主要是为了屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各个平台下都能达到一致的内存访问效果。</p>
<p>在此之前，主流程序语言如<code>C/C++</code>直接使用物理硬件和操作系统的内存模型，因此，会由于不同内存模型的差异，有可能导致在平台A能运行，平台B却不能运行的情况。</p>
<h3 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h3><p>在多CPU的系统中，每个CPU都有多级缓存，一般分为L1、L2、L3缓存，因为这些缓存的存在，提供了数据的访问性能，也减轻了数据总线上数据传输的压力，同时也带来了很多新的挑战，比如两个CPU同时去操作同一个内存地址，会发生什么？在什么条件下，它们可以看到相同的结果？这些都是需要解决的。</p>
<p>所以在CPU的层面，内存模型定义了一个充分必要条件，保证其他CPU的写入动作对该CPU是可见的，而且该CPU的写入动作对其他CPU也是可见的，那这种可见性，应该如何实现呢？</p>
<p>有些处理器提供了强内存模型，所有CPU在任何时候都能看到内存中任意位置相同的值，这种完全是硬件提供的支持。</p>
<p>其他处理器，提供了弱内存模型，需要执行一些特殊指令(就是经常看到货听到的，Memory Barries内存屏障)，刷新CPU缓存的数据到内存中，保证这个写操作能够被其他CPU可见，或者将CPU缓存的数据设置为无效状态，保证其他CPU的写操作对本CPU可见。通过这些内存屏障的行为由底层实现，对于上层语言的程序员来说是透明的。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-20/9953164.jpg" alt=""></p>
<p>前面说到的内存屏障，除了实现CPU之外的数据可见性之外，还有一个重要的职责，可以禁止指令的重排序。</p>
<p>这里说的重排序可以发生在好几个地方：编译器、运行时、JIT等，比如编译器会觉得把一个变量的写操作放在最后更有效率，编译后，这个指令就是在最后了(前提是只要不改变程序的语义，编译器、执行器就可以这样自由的随意优化)，一旦编译器对某个变量的写操作进行优化(放到最后)，那么执行之前，另一个线程将不会看到这个执行结果。</p>
<p>当然了，写入动作可能被移到后面，那么也有可能挪到前面，这样的优化有什么影响呢？这种情况下，其他线程可能会在程序实现“发生”之前，看到这个写入动作(这里怎么理解，指令已经执行了，但是在代码层面还没执行到)，通过内存屏障的功能，我们可以禁止一些不必要、或者会带来负面影响的重排序优化，在内存模型的范围内，实现更高性能，同时保证程序的正确性。</p>
<p>下面看一个重排序的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Class Reordering &#123;</div><div class="line">  int x = 0, y = 0;</div><div class="line">  public void writer() &#123;</div><div class="line">    x = 1;</div><div class="line">    y = 2;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void reader() &#123;</div><div class="line">    int r1 = y;</div><div class="line">    int r2 = x;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设这段代码有2个线程并发执行，线程A执行writer方法，线程B执行reader方法，线程B看到y的值为2，因为把y设置成2发生在变量x的写入之后，所以能断定线程B这时看到的x就是1吗？</p>
<p>在Java内存模型中，描述了在多线程代码中，哪些行为是正确的、合法的、以及多线程之间如何进行通信，代码中变量的读写行为如何反应到内存、CPU缓存的底层细节。</p>
<p>在Java中包含了几个关键字：volatile、final和synchronized，帮助程序员把代码中的并发需求描述给编译器，Java内存模型中定义了他们的行为，确保正确同步的Java代码在所有的处理器上都能正确执行。</p>
<h3 id="synchronization可以实现什么"><a href="#synchronization可以实现什么" class="headerlink" title="synchronization可以实现什么"></a>synchronization可以实现什么</h3><p>Synchronizeation有多中语义，其中最容易理解的是互斥，对于一个monitor对象，只能够被一个线程持有，意味着一旦有线程进入了同步代码块，那么其他线程就不能进入直到第一个进入的线程退出代码块。</p>
<p>但是更多的时候，使用synchronization并非单单互斥功能，synchronization保证了线程在同步块之前或者期间写入动作，对于后续进入该代码块的线程是可见的(又是可见性，不过这里需要注意的是对同一个monitor对象而言)。在一个线程退出同步块时，线程释放monitor对象，它的作用是把CPU缓存数据(本地缓存数据)刷新到主内存中，从而实现该线程的行为可以被其他线程看到。在其他线程进入到该代码块时，需要获得monitor对象，它的作用是使CPU缓存失效，从而使变量从主内存中重新加载，然后就可以看到之前线程对该变量的修改。</p>
<p>但从缓存的角度看，似乎这个问题只会影响多处理器的机器，对于单核来说没什么问题，但是别忘了，它还有一个语义是禁止指令的重排序，对于编译器来说，同步块中的代码不会移动到获取和释放monitor外面。</p>
<p>下面这种代码，千万别写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">synchronized(new Object()) 「×」</div></pre></td></tr></table></figure>
<p>编译器完全可以删除这个同步语义，因为编译器知道没有其他线程会在同一个monitor对象上同步。</p>
<p>所以，请注意：对于两个线程来说，在相同的monitor对象上同步是很重要的，以便正确的设置happens-before关系。</p>
<h3 id="final可以影响什么"><a href="#final可以影响什么" class="headerlink" title="final可以影响什么"></a>final可以影响什么</h3><p>如果一个类包含final字段，且在构造器中初始化，那么正确的构造一个对象后，final字段被设置后对于其他线程是可见的。</p>
<p>这里所说的正确构造对象，意思是在对象的构造过程中，不允许对该对象进行引用，不然的话，可能存在其他线程在对象还没构造完成时就对该对象进行访问，造成不必要的麻烦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">final int x;</div><div class="line">  int y;</div><div class="line">  static FinalFieldExample f;</div><div class="line">  public FinalFieldExample() &#123;</div><div class="line">    x = 3;</div><div class="line">    y = 4;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  static void writer() &#123;</div><div class="line">    f = new FinalFieldExample();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  static void reader() &#123;</div><div class="line">    if (f != null) &#123;</div><div class="line">      int i = f.x;</div><div class="line">      int j = f.y;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个例子描述了应该如何使用final字段，一个线程A执行reader方法，如果f已经在线程B初始化好了，那么可以确保线程A看到x值是3，因为final它是final修饰的，而不能确保看到y的值是4.</p>
<h3 id="volatile可以做什么"><a href="#volatile可以做什么" class="headerlink" title="volatile可以做什么"></a>volatile可以做什么</h3><p>volatile字段主要用于线程之间进行通信，volatile字段的每次读行为都能看到其他线程最后一次对该字段的写行为，通过它就可以避免拿到缓存中陈旧数据。它们必须保证在被写入之后，会被刷新到主内存中，这样就可以立即对其他线程可以见。类似的，在读取volatile字段之前，缓存必须是无效的，以保证每次拿到的都是主内存的值，都是最新的值。volatile的内存语义和synchronized获取和释放monitor的实现目的差不多。</p>
<p>对于重排序，volatile也有额外的限制。</p>
<p>下面看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class VolatileExample &#123;</div><div class="line">  int x = 0;</div><div class="line">  volatile boolean v = false;</div><div class="line">  public void writer() &#123;</div><div class="line">    x = 42;</div><div class="line">    v = true;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void reader() &#123;</div><div class="line">    if (v == true) &#123;</div><div class="line">      //uses x - guaranteed to see 42.</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的，假设一个线程A执行writer，另一个线程B执行reader，writer中对变量v的写入把x的写入也刷新到主内存中。reader方法会从主内存重新获取v的值，所以如果线程B看到v的值为true，就能保证拿到的x是42.（因为把x设置成42发生在把v设置成true之前，volatile禁止这两个写入行为的重排序）</p>
<p>如果变量v不是volatile，那么以上描述就不成立了，因为执行顺序可能是v=true，x=42,或者对于线程B来说，根本看不到v被设置为true。</p>
<h3 id="double-checked-locking的问题"><a href="#double-checked-locking的问题" class="headerlink" title="double-checked locking的问题"></a>double-checked locking的问题</h3><p>臭名昭著的双重检查(单例模式的一种)，是一种延时初始化的实现技巧，避免了同步的开销，因为在早起的JVM，同步操作性能很差，所以才出现了这样的小技巧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private static Something instance = null;</div><div class="line"></div><div class="line">public Something getInstance() &#123;</div><div class="line">  if (instance == null) &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (instance == null)</div><div class="line">        instance = new Something();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个技巧看起来很聪明，避免了同步的开销，但是有一个问题，它可能不起作用，为什么呢？因为实例的初始化和实例字段的写入可能被编译器重排序，这样可能读到一个未初始化完成的对象。</p>
<p>当然，这种bug可以通过使用volatile修饰instance字段进行修复，但是我觉得这种代码格式实在太丑陋了，如果真要延时初始化，不妨使用下面这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private static class LazySomethingHolder &#123;</div><div class="line">  public static Something something = new Something();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static Something getInstance() &#123;</div><div class="line">  return LazySomethingHolder.something;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于是静态字段的初始化，可以确保对访问该类的所有线程都是可见的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java内存模型有什么用？&quot;&gt;&lt;a href=&quot;#Java内存模型有什么用？&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型有什么用？&quot;&gt;&lt;/a&gt;Java内存模型有什么用？&lt;/h3&gt;&lt;p&gt;JVM规范定义Java内存模型主要是为了屏蔽各种硬件
    
    </summary>
    
      <category term="Java进阶" scheme="http://jianwl.com/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java进阶" scheme="http://jianwl.com/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入分析CAS</title>
    <link href="http://jianwl.com/2018/05/19/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90CAS/"/>
    <id>http://jianwl.com/2018/05/19/深入分析CAS/</id>
    <published>2018-05-19T15:17:12.000Z</published>
    <updated>2018-05-20T05:19:14.727Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>CAS, Compare And Swap，即比较并交换。Doug lea大神在同步组价中大量使用CAS技术鬼斧神工地实现了Java多线程的并发操作。整个AQS同步组件、Atomic原子类操作等等都是以CAS实现的，甚至ConcurrentHashMap在1.8版本中也调整为CAS + Synchronized。可以说CAS是整个JUC的基石。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-20/58954764.jpg" alt=""></p>
<h3 id="CAS分析"><a href="#CAS分析" class="headerlink" title="CAS分析"></a>CAS分析</h3><p>在CAS中有三个参数：内存值V、旧的预期值A，要更新的值B，当前仅当内存值V的值等于旧的预期值A时才会将内存值V的值修改为B，否则什么都不干。其伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if(this.value == A)&#123;</div><div class="line">	this.value = B</div><div class="line">	return true;</div><div class="line">&#125;else&#123;</div><div class="line">	return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JUC的atomic类都是通过CAS来实现的，下面就以AtomicInteger为例阐述CAS的实现。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</div><div class="line">private static final long valueOffset;</div><div class="line"></div><div class="line">static &#123;</div><div class="line">    try &#123;</div><div class="line">        valueOffset = unsafe.objectFieldOffset</div><div class="line">            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</div><div class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private volatile int value;</div></pre></td></tr></table></figure>
<p>Unsafe是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地(native)方法来访问。不过尽管如此，JVM还是开了一个后门，Unsafe，它提供了<strong>硬件级别</strong>的原子操作。</p>
<p><code>valueOffset</code>为变量值在内存中的偏移地址，unsafe就是通过偏移地址来得到数据的原值的。</p>
<p><code>value</code>当前值，使用volatile修饰，保证多线程环境下看见的是同一个。</p>
<p>我们就以AtomicInteger的addAndGet()方法来说明，先看源代码；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   public final int addAndGet(int delta) &#123;</div><div class="line">       return unsafe.getAndAddInt(this, valueOffset, delta) + delta;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   public final int getAndAddInt(Object var1, long var2, int var4) &#123;</div><div class="line">       int var5;</div><div class="line">       do &#123;</div><div class="line">           var5 = this.getIntVolatile(var1, var2);</div><div class="line">       &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</div><div class="line">       return var5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部调用unsafe的getAndAddInt方法，在getAndAddInt方法中主要看compareAndSwapInt方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</div></pre></td></tr></table></figure>
<p>该方法为本地方法，有4个参数，分表代表：对象、对象的地址、预期值、修改值，该方法的实现这里就不做详细介绍了，有兴趣的伙伴可以看看<code>openjdk</code>的源码。</p>
<p>CAS可以保证一次的读-写-改操作是原子操作，在单处理器上该操作容易实现，但是在多处理器上实现就有点复杂了。</p>
<p>CPU提供了两种方法来实现多处理器的原子操作：总线加锁或缓存加锁。</p>
<h4 id="总线加锁"><a href="#总线加锁" class="headerlink" title="总线加锁"></a>总线加锁</h4><p>总线加锁就是使用处理器提供一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占使用共享内存。但是这种处理方式显得有点霸道，它把CPU和内存之间的通信锁住了，在锁定期间，其他处理器都不能访问内存地址的数据，其开销有点大。所以就有了缓存加锁。</p>
<h4 id="缓存加锁"><a href="#缓存加锁" class="headerlink" title="缓存加锁"></a>缓存加锁</h4><p>其实针对上面那种情况我们只需要保证在同一时刻对某个内存地址的操作是原子性的即可。缓存加锁就是缓存在内存区域的数据如果在加锁期间，当它执行操作写回内存时，处理器不在输出LOCK#信号，而是修改内存的内存地址，利用缓存一致性协议来保证原子性。缓存一致性机制可以保证同一个内存区域的数据仅能被一个处理器修改，也就是说当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。</p>
<h3 id="CAS缺陷"><a href="#CAS缺陷" class="headerlink" title="CAS缺陷"></a>CAS缺陷</h3><p>CAS虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面：循环时间太长、只能保证一个共性变量原子操作、ABA问题。</p>
<h5 id="1-循环时间太长"><a href="#1-循环时间太长" class="headerlink" title="1) 循环时间太长"></a>1) 循环时间太长</h5><p>如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC有些地方就限制了CAS自旋的次数，例如BlockQueue的SynchronousQueue。</p>
<h5 id="2-只能保证一个共享变量原子操作"><a href="#2-只能保证一个共享变量原子操作" class="headerlink" title="2) 只能保证一个共享变量原子操作"></a>2) 只能保证一个共享变量原子操作</h5><p>看了CAS的实现就知道它只能针对一个共享变量，如果是多个共享变量就只能使用锁了。当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高位</p>
<h5 id="3-ABA问题"><a href="#3-ABA问题" class="headerlink" title="3) ABA问题"></a>3) ABA问题</h5><p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A -&gt; B -&gt; A，变成1A -&gt; 2B -&gt; 3A。</p>
<h5 id="ABA解决方案"><a href="#ABA解决方案" class="headerlink" title="ABA解决方案"></a>ABA解决方案</h5><p>CAS的ABA隐患问题，解决方案则是加上版本号，Java提供了AtomicStampedReference来解决。AtomicStampedReference通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题。</p>
<p>AtomicStampedReference的compareAndSet()方法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public boolean compareAndSet(V   expectedReference,</div><div class="line">                             V   newReference,</div><div class="line">                             int expectedStamp,</div><div class="line">                             int newStamp) &#123;</div><div class="line">    Pair&lt;V&gt; current = pair;</div><div class="line">    return</div><div class="line">        expectedReference == current.reference &amp;&amp;</div><div class="line">        expectedStamp == current.stamp &amp;&amp;</div><div class="line">        ((newReference == current.reference &amp;&amp;</div><div class="line">          newStamp == current.stamp) ||</div><div class="line">         casPair(current, Pair.of(newReference, newStamp)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>compareAndSet有四个参数，分别表示：预期引用、更新后的引用、预期标志、更新后的标志。如果更新后的引用和标志和当前引用和标志相等则直接返回true，否则通过Pair生成一个新的pair对象与当前pair CAS替换。Pair为AtomicStampedReference的内部类，主要用于记录引用和版本戳信息，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private static class Pair&lt;T&gt; &#123;</div><div class="line">    final T reference;</div><div class="line">    final int stamp;</div><div class="line">    private Pair(T reference, int stamp) &#123;</div><div class="line">        this.reference = reference;</div><div class="line">        this.stamp = stamp;</div><div class="line">    &#125;</div><div class="line">    static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;</div><div class="line">        return new Pair&lt;T&gt;(reference, stamp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Pair记录着对象的引用和版本戳，版本戳为int型，保持自增，同时Pair是一个不可变对象，其所有属性定义都为final，对外提供一个of方法，该方法返回一个新建的Pair对象，pair对象定义为volatile，保证多线程环境下的可见性。在AtomicStampedReference中，大多方法都是通过调用Pair的of方法来产生一个新的Pair对象，然后赋予给变量pair。如set方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void set(V newReference, int newStamp) &#123;</div><div class="line">    Pair&lt;V&gt; current = pair;</div><div class="line">    if (newReference != current.reference || newStamp != current.stamp)</div><div class="line">        this.pair = Pair.of(newReference, newStamp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h5><p>下面我们将通过一个例子可以看到AtomicStampedReference和AtomicInteger的区别。我们定义两个线程，线程1负责将100 -&gt; 110 -&gt; 100，线程2执行100 -&gt; 120，看看两者之间的区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">public class AtomicDemo2 &#123;</div><div class="line">    private static AtomicInteger atomicInteger = new AtomicInteger(100);</div><div class="line">    private static AtomicStampedReference atomicStampedReference = new AtomicStampedReference(100,1);</div><div class="line"></div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        // AtomicInteger</div><div class="line">        Thread at1 = new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                atomicInteger.compareAndSet(100,110);</div><div class="line">                atomicInteger.compareAndSet(110,100);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread at2 = new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(2); // at1，执行完</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(&quot;AtomicInteger: &quot; + atomicInteger.compareAndSet(100,120));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        at1.start();</div><div class="line">        at2.start();</div><div class="line">        at1.join();</div><div class="line">        at2.join();</div><div class="line"></div><div class="line">        // AtomicStampedReference</div><div class="line">        Thread tsf1 = new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                try &#123;</div><div class="line">                    // 让tsf2先获取stamp，导致预期时间戳不一致</div><div class="line">                    TimeUnit.SECONDS.sleep(2);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // 预期引用：100， 更新后的引用110，预期表示getStamp(), 更新后表示：getStamp() + 1</div><div class="line">                atomicStampedReference.compareAndSet(100,110,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() +1);</div><div class="line">                System.out.println(&quot;100 -&gt; 110: &quot; + atomicStampedReference.getStamp());</div><div class="line">                atomicStampedReference.compareAndSet(110,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() +1);</div><div class="line">                System.out.println(&quot;110 -&gt; 100: &quot; + atomicStampedReference.getStamp());</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread tsf2 = new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                int stamp = atomicStampedReference.getStamp();</div><div class="line">                System.out.println(&quot;100 -&gt; 120: &quot; + stamp);</div><div class="line">                </div><div class="line">                // 此处线程休眠，是为了让线程tsf1执行，从而改变版本戳，最后导致atomicStampedReference.compareAndSet()因版本对不上而更新失败；</div><div class="line">                try &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(5);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(&quot;AtomicStampedReference: &quot; + atomicStampedReference.compareAndSet(100,120,stamp,stamp+1));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        tsf1.start();</div><div class="line">        tsf2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AtomicInteger: true</div><div class="line">100 -&gt; 120: 1</div><div class="line">100 -&gt; 110: 2</div><div class="line">110 -&gt; 100: 3</div><div class="line">AtomicStampedReference: false</div></pre></td></tr></table></figure>
<p>运行结果充分展示了AtomicInteger的ABA问题和AtomicStampedReference解决ABA问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;CAS, Compare And Swap，即比较并交换。Doug lea大神在同步组价中大量使用CAS技术鬼斧神工地实现了Java多线程的
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码学习</title>
    <link href="http://jianwl.com/2018/05/16/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/05/16/ConcurrentHashMap源码学习/</id>
    <published>2018-05-16T00:12:00.000Z</published>
    <updated>2018-05-18T00:41:43.555Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>HashMap是我们平时开发过程中用的比较多的集合，它是非线程安全的，涉及到多线程并发的情况，进行get操作有可能会引起死循环「JDK1.8以前」，导致CPU利用率接近100%。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test_001()&#123;</div><div class="line">    final Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</div><div class="line">    IntStream.range(0,1000).forEach(num -&gt; new Thread(new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            map.put(UUID.randomUUID().toString(),&quot;&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;).start()</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决方案有HashTable和Collections.synchronizedMap(hashMap),不过两个方案基本上是对读写进行加锁操作，一个线程在读写元素，其余线程必须等待，性能可想而知。</p>
<p>所以，Doug Lea给我们带来了并发安全的CocurrentHashMap,它的实现是依赖于Java内存模型，本文源码是JDK8的版本，与之前的版本有较大差异。</p>
<h3 id="JDK1-7分析"><a href="#JDK1-7分析" class="headerlink" title="JDK1.7分析"></a>JDK1.7分析</h3><p>ConcurrentHashMap采用分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构。其包含两个核心静态内部类Segment和HashEntry。</p>
<ol>
<li>Segment继承ReentrantLock用来充当锁的角色，每个Segment对象守护每个散列映射表的若干个桶。</li>
<li>HashEntry用来封装映射表的键/值对；</li>
<li>每个桶是由若干个HashEntry对象链接起来的链表</li>
</ol>
<p>一个ConcurrentHashMap实例中包含由若干个Segment对象组成的数组。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-16/36278984.jpg" alt=""></p>
<h3 id="JDK1-8-分析"><a href="#JDK1-8-分析" class="headerlink" title="JDK1.8 分析"></a>JDK1.8 分析</h3><p>1.8的实现已经抛弃了Segment分段锁机制，利用CAS + Synchronized来保证并发更新的安全，底层采用数组 + 链表 + 红黑树的存储结构。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-18/3990408.jpg" alt=""></p>
<h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><p>在开始之前，有些重要的概念需要介绍一下：</p>
<p>1、 <code>table</code>: 默认为null,初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方。</p>
<p>2、<code>nextTable</code>: 默认为null,扩容时新生成的数组，其大小为原数组的两倍。</p>
<p>3 、<code>sizeCtl</code>: 默认为0， 用来控制table的初始化和扩容操作，具体应用在后续会体现出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-1 代表table正在初始化</div><div class="line">-N 表示有N-1个线程正在进行扩容操作</div><div class="line">其他情况：</div><div class="line">1. 如果table未初始化，表示table需要初始化的大小；</div><div class="line">2. 如果table初始化完成，表示table的容量，默认是table大小的0.75倍</div></pre></td></tr></table></figure>
<p>4、 Node: 保存key，value及key的hash值的数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">    final int hash;</div><div class="line">    final K key;</div><div class="line">    volatile V val;</div><div class="line">    volatile Node&lt;K,V&gt; next;</div><div class="line">    ... 省略部分代码</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中value和next都用volatile修饰，保证并发的可见性。</p>
<p>5、<code>ForwardingNode:</code> 一个特殊的Node节点，hash值为-1，其中存储nextTable的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</div><div class="line">    final Node&lt;K,V&gt;[] nextTable;</div><div class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</div><div class="line">        super(MOVED, null, null, null);</div><div class="line">        this.nextTable = tab;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有table发生扩容的时候，ForwardingNode才会发生作用，作为一个占位符放在table中表示当前节点为null或已经被移动。</p>
<h4 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h4><p>实例化CocurrentHashMap时带参数时，会根据参数调整table的大小，假设参数为100，最终会调整成256，确保table的大小总是2的幂次方，算法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ConcurrentHashMap&lt;String, String&gt; hashMap = new ConcurrentHashMap&lt;&gt;(100);</div><div class="line">private static final int tableSizeFor(int c) &#123;</div><div class="line">    int n = c - 1;</div><div class="line">    n |= n &gt;&gt;&gt; 1;</div><div class="line">    n |= n &gt;&gt;&gt; 2;</div><div class="line">    n |= n &gt;&gt;&gt; 4;</div><div class="line">    n |= n &gt;&gt;&gt; 8;</div><div class="line">    n |= n &gt;&gt;&gt; 16;</div><div class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，ConcurrentHashMap在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。</p>
<h4 id="table初始化"><a href="#table初始化" class="headerlink" title="table初始化"></a>table初始化</h4><p>前面已经提到过，table初始化操作会延缓到第一次put行为，但是put是可以并发执行的，DougLea是如何实现table只初始化一次的？让我们来看看源码的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; int sc;</div><div class="line">    while ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">//如果一个线程发现sizeCtl&lt;0，意味着另外的线程执行CAS操作成功，当前线程只需要让出cpu时间片</div><div class="line">        if ((sc = sizeCtl) &lt; 0) </div><div class="line">            Thread.yield(); // lost initialization race; just spin</div><div class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</div><div class="line">            try &#123;</div><div class="line">                if ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">                    sc = n - (n &gt;&gt;&gt; 2);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                sizeCtl = sc;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return tab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sizeCtl默认为0，如果ConcurrentHashMap实例化时有传参数，sizeCtl会是一个2的幂次方的值。所以执行第一次put操作的线程会执行<code>Unsafe.compareAndSwapInt</code>方法修改sizeCtl为-1，有且只有一个线程能够修改成功，其他线程通过Thread.yield()让出CPU时间片等待初始化完成。</p>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>假设table已经初始化完成，put操作采用CAS + synchronized实现并发插入或更新操作，具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class="line">    if (key == null || value == null) throw new NullPointerException();</div><div class="line">    int hash = spread(key.hashCode());</div><div class="line">    int binCount = 0;</div><div class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; int n, i, fh;</div><div class="line">        if (tab == null || (n = tab.length) == 0)</div><div class="line">            tab = initTable();</div><div class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class="line">            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class="line">                break;                   // no lock when adding to empty bin</div><div class="line">        &#125;</div><div class="line">        else if ((fh = f.hash) == MOVED)</div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        ...省略部分代码</div><div class="line">    &#125;</div><div class="line">    addCount(1L, binCount);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1、 hash算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static final int spread(int h) &#123;return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;&#125;</div></pre></td></tr></table></figure>
<p>2、table中定位索引位置，n是table的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int index = (n - 1) &amp; hash</div></pre></td></tr></table></figure>
<p>3、获取table中对应索引的元素f。</p>
<p>Doug Lea采用Unsafe.getObjectVolatile来获取，也许有人质疑，直接talbe[index]不可以么，为什么要这么复杂？</p>
<p>在java内存模型中，我们已经知道每个线程都有一个工作内存，里面存储这table的副本，虽然table是volatile修饰的，但是不能保证线程每次都拿到table中的最新元素，Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。</p>
<p>4、如果f为null，说明table中这个位置第一次元素，利用Unsafe.compareAndSwapObject方法插入Node节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">如果CAS成功，说明Node节点已经插入，随后addCount(1L,binCount)方法会检查当前容量是否需要进行扩容。</div><div class="line"></div><div class="line">如果CAS失败，说明有其他线程提前插入了节点，自旋重新尝试在这个位置插入节点。</div></pre></td></tr></table></figure>
<p>5、如果f的hash值为-1，说明当前f是ForwardingNode节点，意味有其他线程正在扩容，则一起进行扩容操作。</p>
<p>6、其余情况把新的Node节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">synchronized (f) &#123;</div><div class="line">    if (tabAt(tab, i) == f) &#123;</div><div class="line">        if (fh &gt;= 0) &#123;</div><div class="line">            binCount = 1;</div><div class="line">            for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                K ek;</div><div class="line">                if (e.hash == hash &amp;&amp;</div><div class="line">                    ((ek = e.key) == key ||</div><div class="line">                     (ek != null &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                    oldVal = e.val;</div><div class="line">                    if (!onlyIfAbsent)</div><div class="line">                        e.val = value;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                Node&lt;K,V&gt; pred = e;</div><div class="line">                if ((e = e.next) == null) &#123;</div><div class="line">                    pred.next = new Node&lt;K,V&gt;(hash, key,</div><div class="line">                                              value, null);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else if (f instanceof TreeBin) &#123;</div><div class="line">            Node&lt;K,V&gt; p;</div><div class="line">            binCount = 2;</div><div class="line">            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                           value)) != null) &#123;</div><div class="line">                oldVal = p.val;</div><div class="line">                if (!onlyIfAbsent)</div><div class="line">                    p.val = value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在节点f上进行同步，节点插入之前，再次利用tabAt(tab,i) == f判断，防止被其他线程修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1、如果f.hash &gt;= 0，说明f是链表结构的头结点，遍历链表，如果找到对应的node节点，则修改value，否则在链表尾部加入节点。</div><div class="line"></div><div class="line">2、如果f是TreeBin类型节点，说明f是红黑树跟节点，则在树结构上遍历元素，更新或增加节点。</div><div class="line"></div><div class="line">3、如果链表中节点数binCount &gt;= TREEIFY_THRESHOLD(默认是8)，则把链表转化为红黑树结构。</div></pre></td></tr></table></figure>
<h4 id="table扩容"><a href="#table扩容" class="headerlink" title="table扩容"></a>table扩容</h4><p>当table容量不足的时候，即table的元素数量达到容量阈值sizeCtl,需要对table进行扩容。</p>
<blockquote>
<p>整个扩容分为两部分：</p>
<p>1、构建一个nextTable，大小为table的两倍</p>
<p>2、把table的数据复制到nextTable中</p>
</blockquote>
<p>这两个过程在单线程实现很简单，但是ConcurrentHashMap是支持并发插入的，扩容操作自然也会有并发的出现，这种情况下，第二步可以支持节点的并发复制，这样性能自然提升不少，但是实现的复杂度也上升了一个台阶。</p>
<p>先看第一步，构建nextTable，毫无疑问，这个过程只能单个线程进行nextTable的初始化，具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private final void addCount(long x, int check) &#123;</div><div class="line">    ... 省略部分代码</div><div class="line">    if (check &gt;= 0) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab, nt; int n, sc;</div><div class="line">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</div><div class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class="line">            int rs = resizeStamp(n);</div><div class="line">            if (sc &lt; 0) &#123;</div><div class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</div><div class="line">                    transferIndex &lt;= 0)</div><div class="line">                    break;</div><div class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</div><div class="line">                    transfer(tab, nt);</div><div class="line">            &#125;</div><div class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</div><div class="line">                transfer(tab, null);</div><div class="line">            s = sumCount();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable,扩容后的数组长度为原来的两倍，但是容量是原来的1.5。</p>
<p>节点是从table移动nextTable，大体思路是遍历、复制的过程。</p>
<p>1、首先根据运算得到遍历的次数i，利用tabAt方法获得i位置的元素f，初始化一个forwardNode实例fwd。</p>
<p>2、如果f == null，则在table中的i位置放入fwd,这个过程是采用Unsafe.compareAndSwapObject方法实现的，很巧妙的实现了节点的并发移动。</p>
<p>3、如果f是链表的头节点，就构造一个反序列链表，把他们分别放在nextTable的i和i+n的位置上，移动完成，采用Unsafe.putObjectVolatile方法给table原位置复制fwd。</p>
<p>4、如果f是TreeBin节点，也做了一个反序处理，并判断是否需要untreeify,把处理的结果分别放在nextTable的i和i+n的位置上，移动完成，同样采用Unsafe.putObjectVolatile方法给table原位置复制fwd。</p>
<p>遍历过所有的节点以后就完成了复制工作，把table指向nextTable，并更新sizeCtl为新数组大小的0.75倍，扩容完成。</p>
<h4 id="红黑树构造"><a href="#红黑树构造" class="headerlink" title="红黑树构造"></a>红黑树构造</h4><p>注意: 如果链表结构中元素超过TREEIFY_THRESHOLD阈值，默认为8个，则把链表转化为红黑树，提高遍历查询效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (binCount != 0) &#123;</div><div class="line">    if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">        treeifyBin(tab, i);</div><div class="line">    if (oldVal != null)</div><div class="line">        return oldVal;</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们看看如何构造树结构，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</div><div class="line">    Node&lt;K,V&gt; b; int n, sc;</div><div class="line">    if (tab != null) &#123;</div><div class="line">        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</div><div class="line">            tryPresize(n &lt;&lt; 1);</div><div class="line">        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123;</div><div class="line">            synchronized (b) &#123;</div><div class="line">                if (tabAt(tab, index) == b) &#123;</div><div class="line">                    TreeNode&lt;K,V&gt; hd = null, tl = null;</div><div class="line">                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123;</div><div class="line">                        TreeNode&lt;K,V&gt; p =</div><div class="line">                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</div><div class="line">                                              null, null);</div><div class="line">                        if ((p.prev = tl) == null)</div><div class="line">                            hd = p;</div><div class="line">                        else</div><div class="line">                            tl.next = p;</div><div class="line">                        tl = p;</div><div class="line">                    &#125;</div><div class="line">                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，生成树节点的代码块是同步的，进入同步代码块之后，再次验证table中index位置元素是否被修改过。</p>
<p>1、根据table中index位置Node链表，重新生成一个hd为头结点的TreeNode链表</p>
<p>2、 根据hd头结点，生成TreeBin树结构，并把树结构的root节点写到table的index位置的内存中，具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</div><div class="line">    super(TREEBIN, null, null, null);</div><div class="line">    this.first = b;</div><div class="line">    TreeNode&lt;K,V&gt; r = null;</div><div class="line">    for (TreeNode&lt;K,V&gt; x = b, next; x != null; x = next) &#123;</div><div class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</div><div class="line">        x.left = x.right = null;</div><div class="line">        if (r == null) &#123;</div><div class="line">            x.parent = null;</div><div class="line">            x.red = false;</div><div class="line">            r = x;</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            K k = x.key;</div><div class="line">            int h = x.hash;</div><div class="line">            Class&lt;?&gt; kc = null;</div><div class="line">            for (TreeNode&lt;K,V&gt; p = r;;) &#123;</div><div class="line">                int dir, ph;</div><div class="line">                K pk = p.key;</div><div class="line">                if ((ph = p.hash) &gt; h)</div><div class="line">                    dir = -1;</div><div class="line">                else if (ph &lt; h)</div><div class="line">                    dir = 1;</div><div class="line">                else if ((kc == null &amp;&amp;</div><div class="line">                          (kc = comparableClassFor(k)) == null) ||</div><div class="line">                         (dir = compareComparables(kc, k, pk)) == 0)</div><div class="line">                    dir = tieBreakOrder(k, pk);</div><div class="line">                    TreeNode&lt;K,V&gt; xp = p;</div><div class="line">                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</div><div class="line">                    x.parent = xp;</div><div class="line">                    if (dir &lt;= 0)</div><div class="line">                        xp.left = x;</div><div class="line">                    else</div><div class="line">                        xp.right = x;</div><div class="line">                    r = balanceInsertion(r, x);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    this.root = r;</div><div class="line">    assert checkInvariants(root);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要根据Node节点的hash值大小构建二叉树，这个红黑树的构造过程实在有点复杂，感兴趣的同学可以看看源码。</p>
<h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><p>get操作和put操作相比，显得简单了许多</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</div><div class="line">    int h = spread(key.hashCode());</div><div class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</div><div class="line">        if ((eh = e.hash) == h) &#123;</div><div class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</div><div class="line">                return e.val;</div><div class="line">        &#125;</div><div class="line">        else if (eh &lt; 0)</div><div class="line">            return (p = e.find(h, key)) != null ? p.val : null;</div><div class="line">        while ((e = e.next) != null) &#123;</div><div class="line">            if (e.hash == h &amp;&amp;</div><div class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</div><div class="line">                return e.val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1、判断table是否为空，如果为空，直接返回null<br>2、计算key的hash值，并获取指定table中指定位置的Node节点，通过遍历链表或树结构找到对应节点，返回value值。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ConcurrentHashMap是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相当于HashTable和同步包装器包装的HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一个时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化。</p>
<p>1.6中采用ReentrantLock分段锁的方式，是多个线程在不同的segment上进行写操作，不会发现阻塞行为；1.8中采用内置锁synchronized，难道是因为1.8的虚拟机内置锁已经优化足够快了？</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;HashMap是我们平时开发过程中用的比较多的集合，它是非线程安全的，涉及到多线程并发的情况，进行get操作有可能会引起死循环「JDK1.8
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于「数据库架构」和「查询优化」的分享</title>
    <link href="http://jianwl.com/2018/05/15/%E5%85%B3%E4%BA%8E%E3%80%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E3%80%8D%E5%92%8C%E3%80%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E3%80%8D%E7%9A%84%E5%88%86%E4%BA%AB/"/>
    <id>http://jianwl.com/2018/05/15/关于「数据库架构」和「查询优化」的分享/</id>
    <published>2018-05-14T23:58:14.000Z</published>
    <updated>2018-05-15T13:55:53.491Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>部门技术分享，选了个数据库专题，做完KeyNote，顺便整理成文，方便后续查阅和补充；本次分享囊括数据库架构、存储引擎功能对比、常用InnoDB日志以及InnoDB逻辑储存结构、索引相关和模拟线上并发问题；</p>
<h3 id="1-MySQL体系结构"><a href="#1-MySQL体系结构" class="headerlink" title="1. MySQL体系结构"></a>1. MySQL体系结构</h3><p> <img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/89852452.jpg" alt=""></p>
<p> MySQL由以下几部分组成： 连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、优化器组件、缓冲组件、插件式存储引擎、物理文件。</p>
<p> MySQL数据库与其他数据库不一样的地方，最重要的一点就是其「插件式的表存储引擎」。特别注意，存储引擎是基于表的，而不是数据库。</p>
<h3 id="2-存储引擎功能对比"><a href="#2-存储引擎功能对比" class="headerlink" title="2. 存储引擎功能对比"></a>2. 存储引擎功能对比</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/94396221.jpg" alt=""></p>
<h4 id="2-1-MyISAM"><a href="#2-1-MyISAM" class="headerlink" title="2-1 MyISAM"></a>2-1 MyISAM</h4><p>不支持事务、表锁设计、支持全文索引，主要面向线上分析处理(OLAP)数据库应用。MyISAM另一个与众不同的地方是它的缓冲池只缓存「索引文件」，而不缓存「数据文件」。</p>
<h4 id="2-2-InnoDB"><a href="#2-2-InnoDB" class="headerlink" title="2-2 InnoDB"></a>2-2 InnoDB</h4><p>支持数据、行锁设计、支持B+树索引、哈希索引、全文索引、支持外键，设计目标主要面向在线事务处理(OLTP)应用。InnoDB通过多版本并发控制(MVCC)来获得并发，并且实现SQL标准的4个隔离级别。默认隔离级别是「REPEATABLE-READ」</p>
<h4 id="2-3-NDB"><a href="#2-3-NDB" class="headerlink" title="2-3 NDB"></a>2-3 NDB</h4><p>NDB是个「集群式」存储引擎，其将数据全部放在内存中(MySQL5.1版本开始，可以将索引数据放在磁盘上)，因此通过主键查询速度极快，且通过增加NDB数据存储节点，可以线性提高数据库性能。</p>
<p>有个问题值得注意：NDB存储引擎的连接操作是在MySQL数据库层完成，而不是在存储引擎层完成。这意味着，复杂的连接操作需要巨大的网络开销。</p>
<h4 id="2-4-Memory"><a href="#2-4-Memory" class="headerlink" title="2-4 Memory"></a>2-4 Memory</h4><p>将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据将消失。它非常使用于存储临时数据的临时表。默认使用「哈希索引」</p>
<h4 id="2-5-Archive"><a href="#2-5-Archive" class="headerlink" title="2-5 Archive"></a>2-5 Archive</h4><p>只持此INSERT和SELECT操作，从MySQL5.1开始支持索引。Archive存储引擎使用zlib算法将数据行进行压缩后存储，应用场景主要是「存储归档数据」。</p>
<h4 id="2-6-Federated"><a href="#2-6-Federated" class="headerlink" title="2-6 Federated"></a>2-6 Federated</h4><p>表不存放数据，它只是指向一台远程MySQL数据库服务器上的表。</p>
<h4 id="2-7-Maria"><a href="#2-7-Maria" class="headerlink" title="2-7 Maria"></a>2-7 Maria</h4><p>Maria是新开发的引擎，设计目标是取代原有的MyISAM存储引擎。其特点是: 支持缓存数据和索引文件，应用行锁设计，提供MVCC功能，支持事务和非事务的安全选项，以及更好的BLOB字符类型的处理性能。</p>
<h3 id="3-InnoDB"><a href="#3-InnoDB" class="headerlink" title="3. InnoDB"></a>3. InnoDB</h3><h4 id="3-1-日志文件"><a href="#3-1-日志文件" class="headerlink" title="3-1 日志文件"></a>3-1 日志文件</h4><p>用来记录MySQL实例对某种条件做出响应时写入的文件，如错误日志文件、二进制文件、慢查询日志。</p>
<h5 id="1）错误日志文件"><a href="#1）错误日志文件" class="headerlink" title="1）错误日志文件"></a>1）错误日志文件</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/248741.jpg" alt=""></p>
<p>可以得到错误日志文件在本地存储的位置；</p>
<h5 id="2）慢查询日志文件"><a href="#2）慢查询日志文件" class="headerlink" title="2）慢查询日志文件"></a>2）慢查询日志文件</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/83986237.jpg" alt=""></p>
<p>默认情况下，慢查询日志不是开启的，通过slow_query_log查看，如果未开启，需要通过以下命令开启。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set global slow_query_log = ON</div></pre></td></tr></table></figure>
<p>long_query_time是查询时间超过这个值，就认为是慢查询；slow_query_log_file是慢查询在本地存储的位置。</p>
<h5 id="3）二进制文件"><a href="#3）二进制文件" class="headerlink" title="3）二进制文件"></a>3）二进制文件</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/8138280.jpg" alt=""></p>
<p>二进制文件记录了MySQL数据库执行更改的所有操作，不包括SELECT 和 SHOW这类操作，因为这类操作对数据本身没有修改。</p>
<h4 id="3-2-逻辑存储结构"><a href="#3-2-逻辑存储结构" class="headerlink" title="3-2 逻辑存储结构"></a>3-2 逻辑存储结构</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/22066716.jpg" alt=""></p>
<p>存储引擎是基于表，所有数据都被逻辑存放在一个空间，称为表空间(tableSpace)。表空间又由段(segment)、区(extent)和页(page)组成。</p>
<h5 id="1-表空间"><a href="#1-表空间" class="headerlink" title="1) 表空间"></a>1) 表空间</h5><p>用于存放数据、索引和插入缓冲页；</p>
<h5 id="2-段"><a href="#2-段" class="headerlink" title="2) 段"></a>2) 段</h5><p>表空间由各个段组成，常见的段有数据段、索引段、回滚段；</p>
<h5 id="3）区"><a href="#3）区" class="headerlink" title="3）区"></a>3）区</h5><p>区是由连续页组成，在任何情况下每个区的大小都是1MB。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4 ~ 5个区，在默认情况下, 页的大小为16K，即一个区有64个连续的页。</p>
<h4 id="3-3-由慢查询引发的思考"><a href="#3-3-由慢查询引发的思考" class="headerlink" title="3-3 由慢查询引发的思考"></a>3-3 由慢查询引发的思考</h4><h5 id="1-什么是慢查询？"><a href="#1-什么是慢查询？" class="headerlink" title="1) 什么是慢查询？"></a>1) 什么是慢查询？</h5><p>Innodb会设置<code>long_query_time</code>参数，查询时间超过这个数值，则判定这个查询为慢查询；</p>
<h5 id="2）如何解决慢查询？"><a href="#2）如何解决慢查询？" class="headerlink" title="2）如何解决慢查询？"></a>2）如何解决慢查询？</h5><p>从三个层面上解决，① 优化查询本身；② 调优表包括增加索引； ③ 调优服务器</p>
<h6 id="优化查询本身"><a href="#优化查询本身" class="headerlink" title="优化查询本身"></a>优化查询本身</h6><p> ① 是否向数据请求了不需要的数据；② 大查询切分为小查询；③ 分解关联查询，可增加缓存命中概率；</p>
<h6 id="优化表"><a href="#优化表" class="headerlink" title="优化表"></a>优化表</h6><p>① 创建表时字段够用就好，越小越好；② 字段不能为空, 字段加索引需要额外空间，含NULL的复合索引无效；③ 加索引，后文会详细接受；</p>
<h6 id="调优服务器"><a href="#调优服务器" class="headerlink" title="调优服务器"></a>调优服务器</h6><p>调节缓冲区参数；</p>
<h5 id="3）联合索引"><a href="#3）联合索引" class="headerlink" title="3）联合索引"></a>3）联合索引</h5><h6 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h6><p>① 联合索引，最左匹配原则；</p>
<h6 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h6><p>① <code>=</code>可以向后传递 ② <code>in</code>如果后面是<code>=</code>或<code>in</code>可以传递 ③ <code>&gt;</code>、<code>&lt;</code>、<code>GROUP BY</code>、<code>ORDER BY</code>、<code>LIKE</code>不向后传递；</p>
<h5 id="4）索引原理"><a href="#4）索引原理" class="headerlink" title="4）索引原理"></a>4）索引原理</h5><p>索引是用B+树的数据结构；B+树包含「索引页」和「数据页」；索引页为非叶子节点，不存数据，只存指向；数据页为叶子节点，只存数据；B+树有一些特性：① 左树小于中间数；② 右树大于中间数；③ 数据页之间是通过双向链表连接的；</p>
<h6 id="B-树插入3种情况"><a href="#B-树插入3种情况" class="headerlink" title="B+树插入3种情况"></a>B+树插入3种情况</h6><p>① 叶子节点(数据页)和非叶子节点(索引页)都未满，插入数据直接插入到叶子节点；（插入28）</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/77745979.jpg" alt=""></p>
<p>② 非叶子节点未满，叶子节点满了；拆分叶子节点，将中间的节点放入Index Page中，小于中间节点的记录放左边，大于或等于中间节点的记录放右边；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/66912616.jpg" alt=""></p>
<p>③ 叶子节点和非叶子节点都满了；拆分叶子节点，小于中间节点的记录放左边，大于或等于中间节点的记录放右边，拆分Index Page，小于中间节点的记录放左边，大于中间节点的记录放右边，中间节点放上一层Index Page。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/30209172.jpg" alt=""></p>
<h4 id="3-4-模拟并发问题"><a href="#3-4-模拟并发问题" class="headerlink" title="3-4 模拟并发问题"></a>3-4 模拟并发问题</h4><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `parent` (</div><div class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</div><div class="line">  PRIMARY KEY (`id`)</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=67 DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure>
<h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><p>1) 客户端1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">insert into parent values(2);</div><div class="line"></div><div class="line">select * from parent;</div><div class="line"></div><div class="line">update parent set id = sleep(30) where id = 2;</div></pre></td></tr></table></figure>
<p>2) 客户端2</p>
<p>因为行锁，以下SQL耗时27.55秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update parent set id = 22 where id = 2;</div></pre></td></tr></table></figure>
<p>3) 客户端3</p>
<p>查看当前执行的线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show processlist \G;</div></pre></td></tr></table></figure>
<h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>1）客户端1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">insert into parent values(3);</div><div class="line"></div><div class="line">begin;</div><div class="line"></div><div class="line">update parent set id = 33 where id = 3;</div></pre></td></tr></table></figure>
<p>2) 客户端2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select * from parent;</div><div class="line"></div><div class="line">begin;</div><div class="line"></div><div class="line">update parent set id = 333 where id = 3;</div></pre></td></tr></table></figure>
<p>3) 客户端3</p>
<p>查看事务情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show engine innodb status \G;</div></pre></td></tr></table></figure>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>1) 客户端1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">begin; // 步骤1</div><div class="line">insert into parent values(4); // 步骤2</div><div class="line">update parent set id = 5 where id = 4; // 步骤5</div></pre></td></tr></table></figure>
<p>2) 客户端2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">begin；// 步骤3</div><div class="line">insert into parent values(5); // 步骤4</div><div class="line">update parent set id = 4 where id = 5; // 步骤6</div></pre></td></tr></table></figure>
<p>3) 客户端</p>
<p>查看死锁情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show engine innodb status \G;</div></pre></td></tr></table></figure>
<h3 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h3><ol>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" target="_blank" rel="external">执行计划explain各个参数含义</a></li>
<li>MySQL排查指南</li>
<li>InnoDB存储引擎</li>
<li>高性能MySQL</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;部门技术分享，选了个数据库专题，做完KeyNote，顺便整理成文，方便后续查阅和补充；本次分享囊括数据库架构、存储引擎功能对比、常用Inno
    
    </summary>
    
      <category term="MYSQL" scheme="http://jianwl.com/categories/MYSQL/"/>
    
    
      <category term="MYSQL" scheme="http://jianwl.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>Thread源码学习</title>
    <link href="http://jianwl.com/2018/05/04/Thread%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/05/04/Thread源码学习/</id>
    <published>2018-05-03T22:47:52.000Z</published>
    <updated>2018-05-04T00:19:01.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Thread内部有个State枚举，表示线程的状态"><a href="#1、Thread内部有个State枚举，表示线程的状态" class="headerlink" title="1、Thread内部有个State枚举，表示线程的状态"></a>1、Thread内部有个State枚举，表示线程的状态</h3><ul>
<li>NEW, 新建未开始</li>
<li>RUNNABLE，可执行，但他可能处于等待系统资源状态，因为CPU此时别其他线程占用；</li>
<li>BLOCKED，阻塞状态，等待一个monitor lock，在调用wait方法后，进入synchronized同步块或方法</li>
<li>WAITING, 等待状态，调用以下方法导致进入等待状态，object.wait()、Thread.join()、LockSupport.park()</li>
<li>TIMED_WAITING, 带超时时间的等待，调用以下方法会处于这个状态 Thread.sleep()、Object.wait()、Thread.join()、LockSupport.parkNanos()、LockSupport.parkUntil()</li>
<li>TERMINATED, 终止状态</li>
</ul>
<p>2、接着看下Thread的构造函数及其他几个相关的成员变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">/* 带目标run对象. */</div><div class="line">   private Runnable target;</div><div class="line"></div><div class="line">   /* 线程组 */</div><div class="line">   private ThreadGroup group;</div><div class="line">   </div><div class="line">   /* 此线程的类加载器 */</div><div class="line">   private ClassLoader contextClassLoader;</div><div class="line">   </div><div class="line">   /* 想要的栈大小，为0时此参数被忽略，且有VM不支持此参数 */</div><div class="line">    private long stackSize;</div><div class="line">    </div><div class="line">   /* 状态标识，0代表新建未开始*/</div><div class="line">   private volatile int threadStatus = 0;</div><div class="line">   </div><div class="line">   /* 静态native方法，返回当前线程*/</div><div class="line">   public static native Thread currentThread();</div><div class="line"></div><div class="line"></div><div class="line">   public Thread() &#123;</div><div class="line">       init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</div><div class="line">   &#125;</div><div class="line">   public Thread(Runnable target) &#123;</div><div class="line">       init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);</div><div class="line">   &#125;</div><div class="line">    Thread(Runnable target, AccessControlContext acc) &#123;</div><div class="line">       init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0, acc);</div><div class="line">   &#125;</div><div class="line">    public Thread(ThreadGroup group, Runnable target) &#123;</div><div class="line">       init(group, target, &quot;Thread-&quot; + nextThreadNum(), 0);</div><div class="line">   &#125;</div><div class="line">    public Thread(String name) &#123;</div><div class="line">       init(null, null, name, 0);</div><div class="line">   &#125;</div><div class="line">   public Thread(ThreadGroup group, String name) &#123;</div><div class="line">       init(group, null, name, 0);</div><div class="line">   &#125;</div><div class="line">   public Thread(Runnable target, String name) &#123;</div><div class="line">       init(null, target, name, 0);</div><div class="line">   &#125;</div><div class="line">   public Thread(ThreadGroup group, Runnable target, String name) &#123;</div><div class="line">       init(group, target, name, 0);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   /**</div><div class="line">    * Initializes a Thread.</div><div class="line">    *</div><div class="line">    * @param g 线程组</div><div class="line">    * @param target 要执行的带run的目标对象</div><div class="line">    * @param name 线程名</div><div class="line">    * @param stackSize 新线程的栈大小，等于0时可忽略此参数</div><div class="line">    * @param acc 接入控制上下文</div><div class="line">    */</div><div class="line">   private void init(ThreadGroup g, Runnable target, String name,</div><div class="line">                     long stackSize, AccessControlContext acc) &#123;</div><div class="line">       if (name == null) &#123;</div><div class="line">           throw new NullPointerException(&quot;name cannot be null&quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       this.name = name;</div><div class="line"></div><div class="line">       Thread parent = currentThread();</div><div class="line">       SecurityManager security = System.getSecurityManager();</div><div class="line">       //获取线程组</div><div class="line">       if (g == null) &#123;</div><div class="line"></div><div class="line">           /* 从SecurityManager拿线程组  */</div><div class="line">           if (security != null) &#123;</div><div class="line">               g = security.getThreadGroup();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           /* 如果还没拿到从当前线程拿*/</div><div class="line">           if (g == null) &#123;</div><div class="line">               g = parent.getThreadGroup();</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /* 检查是否可获取 */</div><div class="line">       g.checkAccess();</div><div class="line"></div><div class="line">       /*</div><div class="line">        * 还是权限控制检查</div><div class="line">        */</div><div class="line">       if (security != null) &#123;</div><div class="line">           if (isCCLOverridden(getClass())) &#123;</div><div class="line">               security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       g.addUnstarted();</div><div class="line"></div><div class="line">       this.group = g;</div><div class="line">       this.daemon = parent.isDaemon();</div><div class="line">       this.priority = parent.getPriority();</div><div class="line">       if (security == null || isCCLOverridden(parent.getClass()))</div><div class="line">           this.contextClassLoader = parent.getContextClassLoader();</div><div class="line">       else</div><div class="line">           this.contextClassLoader = parent.contextClassLoader;</div><div class="line">       this.inheritedAccessControlContext =</div><div class="line">               acc != null ? acc : AccessController.getContext();</div><div class="line">       this.target = target;</div><div class="line">       setPriority(priority);</div><div class="line">       //从父线程继承可继承的ThreadLocal</div><div class="line">       if (parent.inheritableThreadLocals != null)</div><div class="line">           this.inheritableThreadLocals =</div><div class="line">               ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</div><div class="line">     </div><div class="line">       this.stackSize = stackSize;</div><div class="line"></div><div class="line">       /* 设置线程ID */</div><div class="line">       tid = nextThreadID();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>不同的构造函数很多，最终都调init方法，init主要实现的就是把相应的参数放入成员变量里，线程ID为自增长方式；</p>
<h3 id="3、调用线程执行的主方法start与run方法"><a href="#3、调用线程执行的主方法start与run方法" class="headerlink" title="3、调用线程执行的主方法start与run方法"></a>3、调用线程执行的主方法start与run方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/* 线程启动方法 */</div><div class="line"> public synchronized void start() &#123;</div><div class="line">        /**</div><div class="line">         * 如果线程不是NEW状态，则抛异常</div><div class="line">         */</div><div class="line">        if (threadStatus != 0)</div><div class="line">            throw new IllegalThreadStateException();</div><div class="line"></div><div class="line">        /*</div><div class="line">        通知线程组此线程准备运行里，所以它可以加入到线程组列表中，线程组的未开始数量可以减少了 */</div><div class="line">        group.add(this);</div><div class="line"></div><div class="line">        boolean started = false;</div><div class="line">        try &#123;</div><div class="line">            start0();</div><div class="line">            started = true;</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (!started) &#123;</div><div class="line">                    group.threadStartFailed(this);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">                /*什么都不做，如果start0排除一个异常，它已经可以被调用栈知道 */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private native void start0();</div></pre></td></tr></table></figure>
<p>特别注意：start方法会创建一个新的线程，之后在执行run方法里的逻辑；而run方法只会在当前线程中执行逻辑；</p>
<h3 id="4、join方法-等待线程挂掉的方法"><a href="#4、join方法-等待线程挂掉的方法" class="headerlink" title="4、join方法, 等待线程挂掉的方法"></a>4、join方法, 等待线程挂掉的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/*如果这个线程还活着就一直等待*/</div><div class="line"> public final void join() throws InterruptedException &#123;</div><div class="line">        join(0);</div><div class="line">    &#125;</div><div class="line">/*如果这个线程还活着就一直等待millis时间*/</div><div class="line">public final synchronized void join(long millis)</div><div class="line">    throws InterruptedException &#123;</div><div class="line">        long base = System.currentTimeMillis();</div><div class="line">        long now = 0;</div><div class="line"></div><div class="line">        if (millis &lt; 0) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (millis == 0) &#123;</div><div class="line">            while (isAlive()) &#123;</div><div class="line">                wait(0);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            while (isAlive()) &#123;</div><div class="line">                long delay = millis - now;</div><div class="line">                if (delay &lt;= 0) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                wait(delay);</div><div class="line">                now = System.currentTimeMillis() - base;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过自旋方法检验线程是否活着，如果活着，则wait释放锁；</p>
<h3 id="5、sleep方法，native实现，会抛出InterruptedException"><a href="#5、sleep方法，native实现，会抛出InterruptedException" class="headerlink" title="5、sleep方法，native实现，会抛出InterruptedException"></a>5、sleep方法，native实现，会抛出InterruptedException</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* 睡眠指定毫秒，并不释放monitor*/</div><div class="line">public static native void sleep(long millis) throws InterruptedException;</div></pre></td></tr></table></figure>
<h3 id="6、yield方法"><a href="#6、yield方法" class="headerlink" title="6、yield方法"></a>6、yield方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/*使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了*/</div><div class="line">public static native void yield();</div></pre></td></tr></table></figure>
<h3 id="7、interrupted-方法与isInterrupted方法的区别？"><a href="#7、interrupted-方法与isInterrupted方法的区别？" class="headerlink" title="7、interrupted()方法与isInterrupted方法的区别？"></a>7、interrupted()方法与isInterrupted方法的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static boolean interrupted() &#123;</div><div class="line">    return currentThread().isInterrupted(true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean isInterrupted() &#123;</div><div class="line">    return isInterrupted(false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码上看，这两个方法都是调用<code>isInterrupted(boolean ClearInterrupted)</code>,只不过一个带的参数是true，另一个带的参数是false;</p>
<p>所以他们之间的区别是：</p>
<p>1、<code>interrupted</code>方法会清除中断标识符，<code>isInterrupted</code>方法不会清除中断标识符；</p>
<p>2、<code>interrupted</code>测试的是当前线程的中断状态，<code>isInterrupted</code>测试的是调用该方法对象所表示的线程。</p>
<p>3、<code>interrupted</code>为静态方法，Thread对象调用，<code>isInterrupted</code>为普通方法，Thread实例化对象调用</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、Thread内部有个State枚举，表示线程的状态&quot;&gt;&lt;a href=&quot;#1、Thread内部有个State枚举，表示线程的状态&quot; class=&quot;headerlink&quot; title=&quot;1、Thread内部有个State枚举，表示线程的状态&quot;&gt;&lt;/a&gt;1、Thr
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL索引原理</title>
    <link href="http://jianwl.com/2018/04/24/MYSQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
    <id>http://jianwl.com/2018/04/24/MYSQL索引原理/</id>
    <published>2018-04-24T09:51:23.000Z</published>
    <updated>2018-04-24T15:27:55.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-索引目的"><a href="#1-索引目的" class="headerlink" title="1. 索引目的"></a>1. 索引目的</h3><p>索引的目的在于提高查询效率，可以类比字典，如果要查<code>mysql</code>这个单词，我们肯定需要定位到m字母，然后从往下找到y字母，再找到剩下的sql。如果没有索引，那么你很可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p>
<h3 id="2-索引原理"><a href="#2-索引原理" class="headerlink" title="2. 索引原理"></a>2. 索引原理</h3><p>除了字典，生活中随处可见索引的例子，如火车站的车次表，图书的目录等，他们的原理都是一样的，通过不断的缩小想要获得的范围来筛选出最终想要的结果，同时把随机事件变成顺序的时间，也就是我们总是通过同一种查找方式来锁定数据。</p>
<p>数据库也是一样，但显然要复杂许多，因为不仅面临这等值查询、还有范围查询(<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>in</code>)、模糊查询(like)、并集查询(or)等。数据库应该选择怎么样的方式来应对所有问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段、201到300分成第三段…这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但是如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN,具有不错的查询性能。但这里我们忽略一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p>
<h3 id="3-磁盘IO和预读"><a href="#3-磁盘IO和预读" class="headerlink" title="3. 磁盘IO和预读"></a>3. 磁盘IO和预读</h3><p>前面提高了访问磁盘，那么这里先简单介绍一些磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分、寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们常说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是1秒转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错，但要知道一台500 - MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万数据，每次9毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图，供大家参考；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-24/44660032.jpg" alt=""></p>
<p>考虑到磁盘IO是非常高昂的操作计算机操作系统做了一些优化，当一次IO是，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<h3 id="4-索引的数据结构"><a href="#4-索引的数据结构" class="headerlink" title="4. 索引的数据结构"></a>4. 索引的数据结构</h3><p>前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有他的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足要求呢？就这样，b+树应运而生。</p>
<h3 id="5-详解B-树"><a href="#5-详解B-树" class="headerlink" title="5. 详解B+树"></a>5. 详解B+树</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-24/6850674.jpg" alt=""></p>
<p>如上图，是一颗B+树，这里只说一些重点，浅蓝色的块我们称之为磁盘块，可以看到每个磁盘块包含几个数据项(深蓝色所示)和指针(黄色所示)，如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示17和35之间的磁盘块，P3表示大于35的磁盘块，真实的数据存于<strong>叶子节点</strong>即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<h4 id="B-树的查找过程"><a href="#B-树的查找过程" class="headerlink" title="B+树的查找过程"></a>B+树的查找过程</h4><p>如图所示，如果要查找数据项是29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分法查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短(相比磁盘的IO)可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘块8加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的B+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总计共需要百万次IO，显然成本非常高。</p>
<h4 id="B-树性质"><a href="#B-树性质" class="headerlink" title="B+树性质"></a>B+树性质</h4><p>1、通过上面的分析，我们知道IO次数取决于B+数的高度H，假设当前数据表的数据为N，每个磁盘块的数据项的数据是m，则有h=log(m+1)N,当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段尽量要小，比如int占4字节，要比bigint8字节少一半，这也是为什么B+树要求吧真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时，会将退化成线性表。</p>
<p>2、 当B+树的数据项是符合的数据，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三，20，F)这样的数据来检索的时候，B+树会优先比较name来确定下一步的搜索方向，如果name相同再一次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，B+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才知道下一步去哪里查询。比如当(张三，F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后在匹配性别F的数据了，这个是非常重要的性质，即索引最左匹配特性。</p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>1、 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a、b、c、d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<p>2、 = 和 in 可以乱序，比如 a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>
<p>3、 尽量寻找区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录越少，唯一键的区分度是1，而一些状态，性别字段可能在大数据面前区分度就是0，一般需要join的字段我们要求是0.1以上，平均1条扫描10条记录</p>
<p>4、 索引项不能参与计算，保持干净列，比如 from_unixtime(create_time) = ‘2018-04-20’就不能使用索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(‘2018-04-20’)</p>
<p>5、 尽量的扩展索引，不要新建索引，比如表中已经有a的索引，现在要加(a,b)索引，那么只需要修改原来的索引即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-索引目的&quot;&gt;&lt;a href=&quot;#1-索引目的&quot; class=&quot;headerlink&quot; title=&quot;1. 索引目的&quot;&gt;&lt;/a&gt;1. 索引目的&lt;/h3&gt;&lt;p&gt;索引的目的在于提高查询效率，可以类比字典，如果要查&lt;code&gt;mysql&lt;/code&gt;这个单词，我们肯定
    
    </summary>
    
      <category term="MYSQL" scheme="http://jianwl.com/categories/MYSQL/"/>
    
    
      <category term="MYSQL" scheme="http://jianwl.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码学习</title>
    <link href="http://jianwl.com/2018/04/19/ThreadLocal%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/19/ThreadLocal源码学习/</id>
    <published>2018-04-18T22:44:09.000Z</published>
    <updated>2018-04-22T23:00:00.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段"><a href="#常用方法-amp-字段" class="headerlink" title="常用方法 &amp; 字段"></a>常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-19/34870755.jpg" alt=""></p>
<h3 id="1、使用ThreadLocal的好处"><a href="#1、使用ThreadLocal的好处" class="headerlink" title="1、使用ThreadLocal的好处"></a>1、使用ThreadLocal的好处</h3><p>可以实现多线程，变量间互不干扰；举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class ThreadLocalDemo &#123;</div><div class="line">    public static class MyTask implements Runnable&#123;</div><div class="line">        private ThreadLocal&lt;Double&gt; threadLocal = new ThreadLocal&lt;&gt;();</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            threadLocal.set(Math.random());</div><div class="line">            System.out.println(String.format(&quot;thread name : %s, threadlocal: %.2f&quot;,Thread.currentThread().getName(), threadLocal.get()));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MyTask task = new MyTask();</div><div class="line">        new Thread(task,&quot;测试线程1&quot;).start();</div><div class="line">        new Thread(task,&quot;测试线程2&quot;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">thread name : 测试线程2, threadlocal: 0.38</div><div class="line">thread name : 测试线程1, threadlocal: 0.85</div></pre></td></tr></table></figure>
<p>由结果可以看出，每个线程的变量是独立互不干扰的，如果把<code>ThreadLocal</code>换成Double等其他对象，每个线程的变量结果应该是一样的。</p>
<h3 id="2、提出问题"><a href="#2、提出问题" class="headerlink" title="2、提出问题"></a>2、提出问题</h3><ol>
<li>ThreadLocal为多线程共享变量，如何实现变量在多线程中互不干扰的？set()，get()</li>
<li>每个线程变量的存储方式，ThreadLocalMap</li>
<li>ThreadLocalMap是如何解决Hash冲突的；</li>
<li>ThreadLocal放置在Entry数组的索引位置，如何确定；</li>
<li>什么场景下会发生内存泄露，如何防止内存泄露；</li>
<li>为什么ThreadLocalMap是一个Entry数组的数据结构？明明一个threadlocal在一个线程中只能存入一个值；</li>
</ol>
<h4 id="1）如何实现变量在多线程中互不干扰的"><a href="#1）如何实现变量在多线程中互不干扰的" class="headerlink" title="1）如何实现变量在多线程中互不干扰的"></a>1）如何实现变量在多线程中互不干扰的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public void set(T value) &#123;</div><div class="line">    Thread t = Thread.currentThread(); // 获取当前线程</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value); </div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ThreadLocalMap getMap(Thread t) &#123;</div><div class="line">    return t.threadLocals;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public T get() &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">        if (e != null) &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            T result = (T)e.value;</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，每个线程中都有一个<code>ThreadLocalMap</code>数据结构，当执行set方法时，其值是保存在当前线程的<code>threadLocals</code>变量中，当执行get方法时，是从当前线程的<code>threadLocals</code>变量获取的，所以线程1中set的值，对线程2来说是拿不到的，而且在线程2中重新set的话，也不会影响到线程1中的值，保证了线程之间不会相互干扰；</p>
<p>那每个线程中的<code>ThreadLocalMap</code>究竟是什么？</p>
<h4 id="2）-每个线程变量的存储方式，ThreadLocalMap"><a href="#2）-每个线程变量的存储方式，ThreadLocalMap" class="headerlink" title="2） 每个线程变量的存储方式，ThreadLocalMap"></a>2） 每个线程变量的存储方式，ThreadLocalMap</h4><p>从名字上看，可以猜到它也是一个类似<code>HashMap</code>的数据结构，但是在ThreadLocal中，并没实现Map接口。</p>
<p>在ThreadLocalMap中，也是初始化一个大小16的Entry数组，Entry对象用来保存每一个key-value键值对，只不过这里的key永远都是ThreadLocal对象，通过ThreadLocal的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLocalMap中。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-23/56990974.jpg" alt=""></p>
<p>这里需要注意的是，ThreadLocalMap的Entry继承WeakReference和HashMap很大的区别是，Entry中没有next字段，所以就不存在链表的情况；</p>
<h4 id="3）Hash冲突"><a href="#3）Hash冲突" class="headerlink" title="3）Hash冲突"></a>3）Hash冲突</h4><p>没有链表结构，那发生Hash冲突了怎么办？</p>
<p>先看看ThreadLocalMap中插入一个key-value的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</div><div class="line">   Entry[] tab = table;</div><div class="line">   int len = tab.length;</div><div class="line">   int i = key.threadLocalHashCode &amp; (len-1);</div><div class="line"></div><div class="line">   for (Entry e = tab[i];</div><div class="line">         e != null;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">         ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">         if (k == key) &#123;</div><div class="line">             e.value = value;</div><div class="line">             return;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          if (k == null) &#123;</div><div class="line">              replaceStaleEntry(key, value, i);</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tab[i] = new Entry(key, value);</div><div class="line">    int sz = ++size;</div><div class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">          rehash();</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>每个ThreadLocal对象都有一个hash值<code>threadLocalHashCode</code>, <strong>每初始化一个ThreadLocal对象，hash值就增加一个固定的大小0x61c88647</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private final int threadLocalHashCode = nextHashCode();</div><div class="line"></div><div class="line">private static AtomicInteger nextHashCode =</div><div class="line">    new AtomicInteger();</div><div class="line">    </div><div class="line">private static final int HASH_INCREMENT = 0x61c88647;</div><div class="line"></div><div class="line">private static int nextHashCode() &#123;</div><div class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-ThreadLocal如何定位到Entry数组的索引位的"><a href="#4-ThreadLocal如何定位到Entry数组的索引位的" class="headerlink" title="4) ThreadLocal如何定位到Entry数组的索引位的"></a>4) ThreadLocal如何定位到Entry数组的索引位的</h4><p>在插入过程中，根据ThreadLocal对象的Hash值，定位到table中的位置i，过程如下：</p>
<p>1、如果当前位置是空的，那么正好，就初始化一个Entry对象放置位置i上，位置i通过threadlocal的hashcode与table的长度的取余得到；</p>
<p>2、不巧，位置i已经有Entry对象了，如果这个Entry对象的key正好是即将设置的key，那么重新设置Entry中的value；</p>
<p>3、很不巧，位置i的Entry对象和即将设置的key没有关系，那么只能找到下一个空位置；</p>
<p>这样的话，在get的时候，也会根据ThreadLocal对象的hash值，定位table中的位置，然后判断位置Entry中的key是否和get的key一致，如果不一致，就判断下一个位置。</p>
<p>可以发现，set和get如果冲突严重的话，效率很低，因为ThreadLocalMap是Thread的一个属性，所以即使在自己的代码中控制了设置的元素个数，但还是不能控制其代码的行为；</p>
<h4 id="5）内存泄露"><a href="#5）内存泄露" class="headerlink" title="5）内存泄露"></a>5）内存泄露</h4><p>ThreadLocal可能导致内存泄露，为什么？</p>
<p>先看看Entry的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;     Object value;</div><div class="line">     Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">         super(k);</div><div class="line">         value = v;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过之前的分析已经知道，当使用ThreadLocal保存一个value时，会在ThreadLocalMap中的数组插入一个Entry对象，按理说key-value都应该以强引用保存在Entry对象中，但在ThreadLocalMap的实现中，key被保存到了WeakReference对象中。</p>
<p>这就导致了一个问题，ThreadLocal在没有外部强引用是，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露；</p>
<h5 id="如何避免内存泄露"><a href="#如何避免内存泄露" class="headerlink" title="如何避免内存泄露"></a>如何避免内存泄露</h5><p>既然已经发现有内存泄露的隐患，自然有应对的策略，在调用ThreadLocal的get()、set()可能会清楚ThreadLocalMap中key为null的Entry对象，这样对应的value就没有GC Roots可达了，下次GC的时候就可以被回收，当然如果调用remove方法，肯定会删除对应的Entry对象；</p>
<p>如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test_002()&#123;</div><div class="line">    ThreadLocal&lt;String&gt; hello = new ThreadLocal&lt;&gt;();</div><div class="line">    try &#123;</div><div class="line">        hello.set(&quot;Hello World!&quot;);</div><div class="line">    &#125;finally &#123;</div><div class="line">        hello.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-为什么ThreadLocalMap是一个Entry数组的数据结构？"><a href="#6-为什么ThreadLocalMap是一个Entry数组的数据结构？" class="headerlink" title="6. 为什么ThreadLocalMap是一个Entry数组的数据结构？"></a>6. 为什么ThreadLocalMap是一个Entry数组的数据结构？</h4><p>我们知道，每个线程都有一个ThreadLocalMap；之前一直困扰为什么它的数据结构是Entry数组，而不是Entry对象呢？</p>
<p>因为同一个线程中，可以设置多个ThreadLocal，每个threadLocal都会存入到线程的ThreadLocalMap对象中，所以是Entry数组的数据结构；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor线程池源码学习</title>
    <link href="http://jianwl.com/2018/04/18/ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/18/ThreadPoolExecutor线程池源码学习/</id>
    <published>2018-04-18T00:24:37.000Z</published>
    <updated>2018-04-18T01:10:06.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-使用线程池的好处"><a href="#1-使用线程池的好处" class="headerlink" title="1. 使用线程池的好处"></a>1. 使用线程池的好处</h3><p>合理利用线程池能够带来三个好处。</p>
<p>① 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</p>
<p>② 提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
<p>③ 提高线程的可管理性。线程时稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h3 id="2-线程池的工作原理"><a href="#2-线程池的工作原理" class="headerlink" title="2. 线程池的工作原理"></a>2. 线程池的工作原理</h3><p>首先我们看下当一个新的任务提交到线程池之后，线程池是如何处理的；</p>
<p>① 线程池判断核心线程池里的线程是否都在执行任务；如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步；</p>
<p>② 线程池判断工作队列是否已经满。如果工作队列已经满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步；</p>
<p>③ 线程池判断线程池的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务</p>
<h4 id="线程池饱和策略"><a href="#线程池饱和策略" class="headerlink" title="线程池饱和策略"></a>线程池饱和策略</h4><p>这里提到了线程池的饱和策略，那我们就简单介绍下有哪些饱和策略</p>
<table>
<thead>
<tr>
<th style="text-align:center">策略类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AbortPolicy</td>
<td style="text-align:center">直接抛出异常，线程池默认处理策略；切记ThreadPoolExecutor.execute需要try catch，否则程序会直接退出</td>
</tr>
<tr>
<td style="text-align:center">DiscardPolicy</td>
<td style="text-align:center">不处理，丢弃掉</td>
</tr>
<tr>
<td style="text-align:center">DiscardOldestPolicy</td>
<td style="text-align:center">丢弃队里里最近一个任务，并执行当前任务</td>
</tr>
<tr>
<td style="text-align:center">CallerRusPolicy</td>
<td style="text-align:center">只用调用者所在线程来运行任务</td>
</tr>
<tr>
<td style="text-align:center">自定义策略</td>
<td style="text-align:center">可以根据引用场景需要来实现RejectedExecutionHandler接口自定义策略，如记录日志或持久化不能处理的任务</td>
</tr>
</tbody>
</table>
<h3 id="3-线程池工作流程图"><a href="#3-线程池工作流程图" class="headerlink" title="3. 线程池工作流程图"></a>3. 线程池工作流程图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-12/20324843.jpg" alt=""></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-12/82099386.jpg" alt=""></p>
<p>① 如果当前运行的线程小于corePoolSize,则创建新线程来执行任务（注意执行这一步需要获取全局锁）</p>
<p>② 如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue；</p>
<p>③ 如果BlockingQueue队列已满，则在非corePool中创建新的线程来处理任务（注意执行这一步需要获取全局锁）</p>
<p>④ 如果创建新线程将使当前运行的线程超出maximumPoolSize,任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</p>
<h3 id="4-线程池的使用"><a href="#4-线程池的使用" class="headerlink" title="4. 线程池的使用"></a>4. 线程池的使用</h3><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><p>我们可以通过ThreadPoolExecutor来创建一个线程池；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds, runnableTaskQueue,threadFactory, handler);</div></pre></td></tr></table></figure>
<p>创建一个线程池需要输入几个参数：</p>
<h5 id="1）corePoolSize（线程池的基本大小）"><a href="#1）corePoolSize（线程池的基本大小）" class="headerlink" title="1）corePoolSize（线程池的基本大小）"></a>1）corePoolSize（线程池的基本大小）</h5><p>当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程池</p>
<h5 id="2）runnableTaskQueue（任务队列）"><a href="#2）runnableTaskQueue（任务队列）" class="headerlink" title="2）runnableTaskQueue（任务队列）"></a>2）runnableTaskQueue（任务队列）</h5><p>用于保存等待执行的任务的阻塞队列，可以选择一下几个阻塞队列</p>
<p>① ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO(先进先出)原则对元素进行排序；</p>
<p>② LinkedBlockingQueue: 一个基于链表结构的阻塞队列，此队列按FIFO(先进先出)排序元素，吞吐量通常高于ArrayBlockingQueue，静态工厂方法Executors.newFixedThreadPool()使用这个队列</p>
<p>③ SyschronousQueue: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常高于LinkedBlockingQueue，静态工作方法 Executors.newCachedThreadPool使用这个队列；</p>
<p>④ PriorityBlockingQueue： 一个具有优先级的无限阻塞队列；</p>
<h5 id="3）maxmumPoolSize（线程池最大大小）"><a href="#3）maxmumPoolSize（线程池最大大小）" class="headerlink" title="3）maxmumPoolSize（线程池最大大小）"></a>3）maxmumPoolSize（线程池最大大小）</h5><p>线程池允许创建的最大线程数，如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的队列这个参数就没有效果了；</p>
<h5 id="4-ThreadFactory"><a href="#4-ThreadFactory" class="headerlink" title="4) ThreadFactory"></a>4) ThreadFactory</h5><p>用于设置创建线程工厂，可以通过线程工厂给创建出来的线程设置有语义的名字</p>
<h5 id="5）RejectedExecutionHandler（饱和策略）"><a href="#5）RejectedExecutionHandler（饱和策略）" class="headerlink" title="5）RejectedExecutionHandler（饱和策略）"></a>5）RejectedExecutionHandler（饱和策略）</h5><p>参考上述步骤2中的，饱和策略分析</p>
<h5 id="6）keepAliveTime（线程活动保持时间）"><a href="#6）keepAliveTime（线程活动保持时间）" class="headerlink" title="6）keepAliveTime（线程活动保持时间）"></a>6）keepAliveTime（线程活动保持时间）</h5><p>大于corePool(线程池基本大小)的空闲工作线程，保持存活的时间<strong>(在存活时间内，如果没有接受新任务，就会被销毁)</strong>。如果任务很多，每个任务执行的时间比较短，可以调整这个时间，提高线程的利用率；</p>
<h5 id="7）TimeUnit（线程活动保持时间的单位）"><a href="#7）TimeUnit（线程活动保持时间的单位）" class="headerlink" title="7）TimeUnit（线程活动保持时间的单位）"></a>7）TimeUnit（线程活动保持时间的单位）</h5><p>可选单位有天(DAYS)、小时(HOURS)、分钟(MINUTES)、毫秒(MILLISECONDS)、微秒(MICROSECONDS)</p>
<h3 id="5-源码分析"><a href="#5-源码分析" class="headerlink" title="5. 源码分析"></a>5. 源码分析</h3><h4 id="1）提问"><a href="#1）提问" class="headerlink" title="1）提问"></a>1）提问</h4><p>1、线程池新增任务的流程；execute(Runnable command)</p>
<p>2、线程池如何实现，在RUNING状态下，接受新任务，且处理队列里的任务；在SHUTDOWN状态下，不接受新任务，但处理新任务的 ;以及在STOP、TIDYING和TERMINATE状态下的处理方式；</p>
<p>3、线程池如何处理新增任务时，出现异常的；addWorkerFailed(Worker w)</p>
<p>4、线程池如何实现关闭的；</p>
<h5 id="1-1-execute-Runnable-command"><a href="#1-1-execute-Runnable-command" class="headerlink" title="1-1) execute(Runnable command)"></a>1-1) execute(Runnable command)</h5><p><code>execute</code>方法三个主要步骤：① 活动线程小于<code>corePoolSize</code>的时候创建新的线程；②活动线程大于<code>corePoolSize</code>先加入到任务队列当中；③ 任务队列满了再去启动新的线程，如果线程数达到最大值就拒绝任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void execute(Runnable command) &#123; </div><div class="line">    if (command == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">  </div><div class="line">    int c = ctl.get();</div><div class="line"></div><div class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        if (addWorker(command, true))</div><div class="line">            return;</div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        int recheck = ctl.get();</div><div class="line"></div><div class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line"></div><div class="line">        else if (workerCountOf(recheck) == 0)</div><div class="line">            addWorker(null, false);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    else if (!addWorker(command, false))</div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第 5 行：ctl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</div></pre></td></tr></table></figure>
<p><code>ThreadPoolExecutor</code>用这一变量保存了两个内容：① 所有有效线程数量「workerCount」② 线程池运行状态「runState」; 低29位存<code>workerCounter</code>，高3位存<code>runState</code>, 这样<code>runState</code>有5个值；</p>
<ul>
<li>RUNNING: -1 &lt;&lt; 29</li>
<li>SHOTDOWN: 0 &lt;&lt; 29</li>
<li>STOP: 1 &lt;&lt; 29</li>
<li>TIDYING: 2 &lt;&lt; 29</li>
<li>TERMINATED: 3 &lt;&lt; 29</li>
</ul>
<p>线程池各状态转换比较复杂，记住下面内容就可以了：</p>
<ul>
<li>RUNNING状态：线程池正常运行，可以接受新的任务并处理队列中的任务；</li>
<li>SHUTDOWN状态：不再接受新的任务，但是会执行队列中的任务；</li>
<li>STOP状态：不再接受新任务，不处理队列中的任务，中断正在进行中的任务；</li>
<li>TIDYING: 所有任务都已关闭，有效线程数为0，将运行<code>terminated()</code>钩子方法；</li>
<li>TERMINATED: <code>terminated()</code>方法执行完毕；</li>
</ul>
<p>第 7 行：当有效线程数 小于 核心线程数时；</p>
<p><code>workerCountOf(ctl.get())</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private static final int COUNT_BITS = 29;</div><div class="line"></div><div class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</div><div class="line"></div><div class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</div></pre></td></tr></table></figure>
<p>ctl的低29位存着有效线程数，通过 <code>c &amp; 00011111111111111111111111111</code>的方式得到<code>有效线程数</code></p>
<p>第 8 行：线程池有效线程数小于核心线程数时，新增任务成功，则退出；</p>
<p>源码中：<code>Worker类</code>、<code>addWorkerFailed()方法</code>在后文继续分析</p>
<p><code>addWorker(command,true)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</div><div class="line">    retry:</div><div class="line">    for (;;) &#123;</div><div class="line">        int c = ctl.get();</div><div class="line">        int rs = runStateOf(c); // 当前线程池状态</div><div class="line"></div><div class="line">        // 线程池状态为：SHUTDOWN STOP TIDYING TERMINATED 均不在接受新任务；</div><div class="line">        // 但是当状态为SHUTDOWN时，若此时队列不为空，为了保证队列中的任务能够被执行完；</div><div class="line">        // SHUTDOWN时通过addWoker(null,false)方法,新增有效线程数；「执行addWorker(null,false)，此时workerCounter == 0」</div><div class="line">        // 所以当线程池的状态为SHUTDOWN，firstTask == null，队列不为空时，将继续往下执行；</div><div class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">            ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">               firstTask == null &amp;&amp;</div><div class="line">               ! workQueue.isEmpty()))</div><div class="line">            return false;</div><div class="line"></div><div class="line">        for (;;) &#123;</div><div class="line">            int wc = workerCountOf(c); // 有效线程数</div><div class="line"></div><div class="line">            if (wc &gt;= CAPACITY ||</div><div class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                return false;</div><div class="line"></div><div class="line">            if (compareAndIncrementWorkerCount(c)) // 原子操作递增workerCount</div><div class="line">                break retry; // 操作成功跳出重试循环</div><div class="line">            c = ctl.get();  // Re-read ctl</div><div class="line">            if (runStateOf(c) != rs) // 如果线程池的状态发生变化则重试</div><div class="line">                continue retry;</div><div class="line">            // else CAS failed due to workerCount change; retry inner loop</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // workerCount递增成功</div><div class="line">    boolean workerStarted = false;</div><div class="line">    boolean workerAdded = false;</div><div class="line">    Worker w = null;</div><div class="line">    try &#123;</div><div class="line">        w = new Worker(firstTask);</div><div class="line">        final Thread t = w.thread;</div><div class="line">        if (t != null) &#123;</div><div class="line">            final ReentrantLock mainLock = this.mainLock;</div><div class="line">            // 并发的访问线程池workers对象必须加锁</div><div class="line">            mainLock.lock();</div><div class="line">            try &#123;</div><div class="line">                // Recheck while holding lock.</div><div class="line">                // Back out on ThreadFactory failure or if</div><div class="line">                // shut down before lock acquired.</div><div class="line">                int rs = runStateOf(ctl.get());</div><div class="line"></div><div class="line">                // RUNNING 状态 || SHUTDOWN状态下清理队列中剩余的任务</div><div class="line">                if (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</div><div class="line">                    if (t.isAlive()) // precheck that t is startable</div><div class="line">                        throw new IllegalThreadStateException();</div><div class="line">                    // 将线程放到线程列表中</div><div class="line">                    workers.add(w);</div><div class="line">                    int s = workers.size();</div><div class="line">                    if (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = true;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            // 启动新添加的线程，这个线程首先执行firstTask，然后不停的从队列中取任务执行；</div><div class="line">            if (workerAdded) &#123;</div><div class="line">                t.start(); // 最终执行的是ThreadPoolExecutor的runWorker方法</div><div class="line">                workerStarted = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        // 线程启动失败，则从workers中移除w并递减workerCount</div><div class="line">        if (! workerStarted)</div><div class="line">            // 递减workerCount会触发tryTerminate方法</div><div class="line">            addWorkerFailed(w);</div><div class="line">    &#125;</div><div class="line">    return workerStarted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第13 ~ 21行：</p>
<p><code>runState</code>为RUNNING状态且队列未满，双重检查，再次获取线程池ctl，判断当前线程池状态；若线程池为非RUNNING状态，则从workQueue中移除任务，并执行线程池拒绝任务策略；若当前有效线程数为0，则添加一个空任务到队列里；「理由是：当线程池状态为SHUTDOWN时，若队列不为空，有效线程数为0，需要通过添加空任务的方法，增加有效线程数」</p>
<p>第 23 ~ 25行：</p>
<p>① 线程池非RUNNING状态，拒绝新任务，执行拒绝策略 ② 队列满了且当且有效线程数大于最大线程数时，执行拒绝策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final void reject(Runnable command) &#123;</div><div class="line">    handler.rejectedExecution(command, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-2-Worker"><a href="#1-2-Worker" class="headerlink" title="1-2 Worker"></a>1-2 Worker</h5><p>任务添加成功后，实际执行的是runWorker(this)的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">private final class Worker</div><div class="line">    extends AbstractQueuedSynchronizer</div><div class="line">    implements Runnable</div><div class="line">&#123;</div><div class="line">    private static final long serialVersionUID = 6138294804551838833L;</div><div class="line"></div><div class="line">    final Thread thread;</div><div class="line"></div><div class="line">    Runnable firstTask;</div><div class="line"></div><div class="line">    volatile long completedTasks;</div><div class="line"></div><div class="line">    Worker(Runnable firstTask) &#123;</div><div class="line">        setState(-1); // inhibit interrupts until runWorker</div><div class="line">        this.firstTask = firstTask;</div><div class="line">        this.thread = getThreadFactory().newThread(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void run() &#123;</div><div class="line">        runWorker(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean isHeldExclusively() &#123;</div><div class="line">        return getState() != 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean tryAcquire(int unused) &#123;</div><div class="line">        if (compareAndSetState(0, 1)) &#123;</div><div class="line">            setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean tryRelease(int unused) &#123;</div><div class="line">        setExclusiveOwnerThread(null);</div><div class="line">        setState(0);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void lock()        &#123; acquire(1); &#125;</div><div class="line">    public boolean tryLock()  &#123; return tryAcquire(1); &#125;</div><div class="line">    public void unlock()      &#123; release(1); &#125;</div><div class="line">    public boolean isLocked() &#123; return isHeldExclusively(); &#125;</div><div class="line"></div><div class="line">    void interruptIfStarted() &#123;</div><div class="line">        Thread t;</div><div class="line">        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;</div><div class="line">            try &#123;</div><div class="line">                t.interrupt();</div><div class="line">            &#125; catch (SecurityException ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第 20 行：runWorker简单来说做了两件事：</p>
<p>① 第一次启动会执行传进来的任务firstTask;</p>
<p>② 如果firstTask为空，则从workQueue中取任务，如果队列为空则等待<code>keepAliveTime</code>这么长的时间；</p>
<p>runWorker的核心代码为第10行代码中的<code>getTask()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">final void runWorker(Worker w) &#123;</div><div class="line">        Thread wt = Thread.currentThread();</div><div class="line">        Runnable task = w.firstTask;</div><div class="line">        w.firstTask = null;</div><div class="line">        // 任务被锁住了，需要解锁才能被中断？「这个解释需要验证」</div><div class="line">        w.unlock(); // allow interrupts</div><div class="line">        boolean completedAbruptly = true;</div><div class="line">        try &#123;</div><div class="line">            // 先执行firstTask，若firstTask为空，则从队列里取任务执行；</div><div class="line">            while (task != null || (task = getTask()) != null) &#123;</div><div class="line">                w.lock();</div><div class="line">                if ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                     (Thread.interrupted() &amp;&amp;</div><div class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                    !wt.isInterrupted())</div><div class="line">                    wt.interrupt();</div><div class="line">                try &#123;</div><div class="line">                    // 任务执行前可以插入一些处理、子类重载该方法</div><div class="line">                    beforeExecute(wt, task);</div><div class="line">                    Throwable thrown = null;</div><div class="line">                    try &#123;</div><div class="line">                        task.run(); // 执行用户任务</div><div class="line">                    &#125; catch (RuntimeException x) &#123;</div><div class="line">                        thrown = x; throw x;</div><div class="line">                    &#125; catch (Error x) &#123;</div><div class="line">                        thrown = x; throw x;</div><div class="line">                    &#125; catch (Throwable x) &#123;</div><div class="line">                        thrown = x; throw new Error(x);</div><div class="line">                    &#125; finally &#123;</div><div class="line">                        // 和beforeExecute一样，留给子类去重载；</div><div class="line">                        afterExecute(task, thrown);</div><div class="line">                    &#125;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    task = null;</div><div class="line">                    w.completedTasks++;</div><div class="line">                    w.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            completedAbruptly = false;</div><div class="line">        &#125; finally &#123;</div><div class="line">            // 结束线程的一些清理工作</div><div class="line">            processWorkerExit(w, completedAbruptly);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="1-3-runWorker-中的getTask-方法"><a href="#1-3-runWorker-中的getTask-方法" class="headerlink" title="1-3 runWorker()中的getTask()方法"></a>1-3 runWorker()中的getTask()方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private Runnable getTask() &#123;</div><div class="line">    boolean timedOut = false; // Did the last poll() time out?</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line">        int c = ctl.get();</div><div class="line">        int rs = runStateOf(c);</div><div class="line"></div><div class="line">        // SHUTDOWN状态：队列不为空，不接受新任务，但有队列中的任务需要执行；</div><div class="line">        // Check if queue empty only if necessary.</div><div class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">            decrementWorkerCount();</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int wc = workerCountOf(c);</div><div class="line"></div><div class="line">        // Are workers subject to culling?</div><div class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">        // timed == false 不允许核心线程超时，即使核心线程处于闲置装填也不会被回收；</div><div class="line">        // timed == true 允许核心线程超时,只要核心线程处于闲置状态就会被回收;</div><div class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</div><div class="line">            if (compareAndDecrementWorkerCount(c))</div><div class="line">                return null;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            Runnable r = timed ?</div><div class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                workQueue.take();</div><div class="line">            if (r != null)</div><div class="line">                return r;</div><div class="line">            timedOut = true;</div><div class="line">        &#125; catch (InterruptedException retry) &#123;</div><div class="line">            timedOut = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-4-addWorkerFailed"><a href="#1-4-addWorkerFailed" class="headerlink" title="1-4 addWorkerFailed"></a>1-4 addWorkerFailed</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private void addWorkerFailed(Worker w) &#123;</div><div class="line">    final ReentrantLock mainLock = this.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    try &#123;</div><div class="line">        if (w != null)</div><div class="line">            workers.remove(w); // 移除任务</div><div class="line">        decrementWorkerCount(); // 递减workerCount</div><div class="line">        tryTerminate();</div><div class="line">    &#125; finally &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在addWorker时，出现异常时，需要做回滚操作，① 将任务从队列中移除； ② 将有效线程数减1 ③ 因为有效线程数发生变化了，所有需要尝试调用<code>tryTerminate</code>来终止线程池;</p>
<p><code>tryTerminate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">final void tryTerminate() &#123;</div><div class="line">    for (;;) &#123;</div><div class="line">        int c = ctl.get();</div><div class="line">        // 以下状态直接返回</div><div class="line">        // 1. 线程池还处于RUNNING状态</div><div class="line">        // 2. runState &gt;= TIDYING 线程池已经停止了或正在停止了</div><div class="line">        // 3. SHUTDOWN状态但队列非空</div><div class="line">        if (isRunning(c) ||</div><div class="line">            runStateAtLeast(c, TIDYING) ||</div><div class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</div><div class="line">            return;</div><div class="line"></div><div class="line">        // workerCount不为0，则还不能停止线程池，</div><div class="line">        if (workerCountOf(c) != 0) &#123; // Eligible to terminate</div><div class="line">            // ONLY_ONE: 只需中断1个线程去处理shutdown信号就可以了；</div><div class="line">            interruptIdleWorkers(ONLY_ONE);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final ReentrantLock mainLock = this.mainLock;</div><div class="line">        mainLock.lock();</div><div class="line">        try &#123;</div><div class="line">            // 进入TIDYING状态</div><div class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</div><div class="line">                try &#123;</div><div class="line">                    // 子类重载：一些资源清理工作</div><div class="line">                    terminated();</div><div class="line">                &#125; finally &#123;</div><div class="line">                    // TERMINATED状态</div><div class="line">                    ctl.set(ctlOf(TERMINATED, 0));</div><div class="line">                    // 进行awaitTermination</div><div class="line">                    termination.signalAll();</div><div class="line">                &#125;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line">        // else retry on failed CAS</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-5-关闭线程池shutdown"><a href="#1-5-关闭线程池shutdown" class="headerlink" title="1-5 关闭线程池shutdown"></a>1-5 关闭线程池shutdown</h5><p>shutdown这个方法会将<code>runState</code>置为SHUTDOWN，会终止所有空闲的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void shutdown() &#123;</div><div class="line">    final ReentrantLock mainLock = this.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    try &#123;</div><div class="line">        checkShutdownAccess();</div><div class="line">        // 线程池状态设为SHUTDOWN，如果已经至少是这个状态那么则直接返回</div><div class="line">        advanceRunState(SHUTDOWN);</div><div class="line">        // 注意这里是中断所有空闲的线程：runWorker中等待的线程被中断 → 进入processWorkerExit →</div><div class="line">        // tryTerminate方法中会保证队列中剩余的任务得到执行。</div><div class="line">        interruptIdleWorkers();</div><div class="line">        onShutdown(); // hook for ScheduledThreadPoolExecutor</div><div class="line">    &#125; finally &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">    tryTerminate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-使用线程池的好处&quot;&gt;&lt;a href=&quot;#1-使用线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;1. 使用线程池的好处&quot;&gt;&lt;/a&gt;1. 使用线程池的好处&lt;/h3&gt;&lt;p&gt;合理利用线程池能够带来三个好处。&lt;/p&gt;
&lt;p&gt;① 降低资源消耗。通过重
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>StringBuilder源码学习</title>
    <link href="http://jianwl.com/2018/04/02/StringBuilder%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/02/StringBuilder源码学习/</id>
    <published>2018-04-02T14:06:55.000Z</published>
    <updated>2018-04-04T00:39:36.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段"><a href="#常用方法-amp-字段" class="headerlink" title="常用方法 &amp; 字段"></a>常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-3/88149991.jpg" alt=""></p>
<p>StringBuilder常用于单线程字符串的拼接，可以减小堆内存的开销；</p>
<p>StringBuilder继承<code>AbstractStringBuilder</code>抽象类，且实现了<code>CharSequence</code>、<code>Serializable</code>接口</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>通过append方法拼接字符串，为什么能够减少内存的开销呢，append();</li>
<li>StringBuffer和StringBuilder有什么区别？</li>
</ol>
<h4 id="1-如何拼接字符串"><a href="#1-如何拼接字符串" class="headerlink" title="1) 如何拼接字符串"></a>1) 如何拼接字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">    @Override</div><div class="line">    public StringBuilder append(String str) &#123;</div><div class="line">        super.append(str);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// AbstractStringBuilder类   </div><div class="line">    public AbstractStringBuilder append(String str) &#123;</div><div class="line">        if (str == null)</div><div class="line">            return appendNull();</div><div class="line">        int len = str.length();</div><div class="line">        ensureCapacityInternal(count + len);</div><div class="line">        str.getChars(0, len, value, count);</div><div class="line">        count += len;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private AbstractStringBuilder appendNull() &#123;</div><div class="line">        int c = count;</div><div class="line">        ensureCapacityInternal(c + 4);</div><div class="line">        final char[] value = this.value;</div><div class="line">        value[c++] = &apos;n&apos;;</div><div class="line">        value[c++] = &apos;u&apos;;</div><div class="line">        value[c++] = &apos;l&apos;;</div><div class="line">        value[c++] = &apos;l&apos;;</div><div class="line">        count = c;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line">      </div><div class="line">    private void ensureCapacityInternal(int minimumCapacity) &#123;</div><div class="line">        // overflow-conscious code</div><div class="line">        if (minimumCapacity - value.length &gt; 0)</div><div class="line">            expandCapacity(minimumCapacity);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void expandCapacity(int minimumCapacity) &#123;</div><div class="line">        int newCapacity = value.length * 2 + 2;</div><div class="line">        if (newCapacity - minimumCapacity &lt; 0)</div><div class="line">            newCapacity = minimumCapacity;</div><div class="line">        if (newCapacity &lt; 0) &#123;</div><div class="line">            if (minimumCapacity &lt; 0) // overflow</div><div class="line">                throw new OutOfMemoryError();</div><div class="line">            newCapacity = Integer.MAX_VALUE;</div><div class="line">        &#125;</div><div class="line">        value = Arrays.copyOf(value, newCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// Arrays类</div><div class="line">    public static char[] copyOf(char[] original, int newLength) &#123;</div><div class="line">        char[] copy = new char[newLength];</div><div class="line">        System.arraycopy(original, 0, copy, 0,</div><div class="line">                         Math.min(original.length, newLength));</div><div class="line">        return copy;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">// String类</div><div class="line">    public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123;</div><div class="line">        if (srcBegin &lt; 0) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcBegin);</div><div class="line">        &#125;</div><div class="line">        if (srcEnd &gt; value.length) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd);</div><div class="line">        &#125;</div><div class="line">        if (srcBegin &gt; srcEnd) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</div><div class="line">        &#125;</div><div class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="1、拼接元素为null"><a href="#1、拼接元素为null" class="headerlink" title="1、拼接元素为null"></a>1、拼接元素为null</h5><p>第 9 ~ 10 行：如果拼接字符串为<code>null值</code>，则拼接<code>null</code>字符串；</p>
<p>第 20 行：确保当前字符数组数量加4，小于字符数组长度，否则扩容；</p>
<p>第 36 ~ 45行: 执行扩容；新容量为当前字符数组长度的2倍 + 2；如果新容量仍然小于，实际字符数量，则新容量等于实际字符数量；如果新容量溢出，则新容量赋值为Integer.MAX_VALUE;将原字符数组，赋值到扩容后的数组中；</p>
<p>第 49 ~ 53行：新建容量为扩容后的长度的字符数组，将原数组元素赋值到新数组中;</p>
<h5 id="2-新增元素不为null"><a href="#2-新增元素不为null" class="headerlink" title="2 新增元素不为null"></a>2 新增元素不为null</h5><p>第 11 ~12行: 获取新增字符串的长度，确保当前字符数量 + 新增字符串长度，在字符数组容量范围内，否则执行扩容；</p>
<p>第 13行: 将新增字符串转为字符数组，将其赋值到当前字符数组中实际元素的尾部，具体如图所示；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-4/53045816.jpg" alt=""></p>
<h5 id="3-为什么可以减少堆内存的开销？"><a href="#3-为什么可以减少堆内存的开销？" class="headerlink" title="3 为什么可以减少堆内存的开销？"></a>3 为什么可以减少堆内存的开销？</h5><p>因为字符串是不可变类，每次通过new的方式创建一个不同的字符串，都会在堆内存开辟一个空间；而通过StringBuilder的append方式拼接字符串，只会开辟一个字符数组内存空间，拼接的字符串将添加到字符数组中；从而减少了堆内存的开销；</p>
<h4 id="2）StringBuffer和StringBuilder有什么区别"><a href="#2）StringBuffer和StringBuilder有什么区别" class="headerlink" title="2）StringBuffer和StringBuilder有什么区别"></a>2）StringBuffer和StringBuilder有什么区别</h4><p>StringBuffer是线程安全的，在拼接元素方法中添加了同步锁；其他实现方式与StringBuilder一致；这里就不再赘述了；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">    @Override</div><div class="line">    public synchronized StringBuffer append(String str) &#123;</div><div class="line">        toStringCache = null;</div><div class="line">        super.append(str);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">// AbstractStringBuilder类</div><div class="line">    public AbstractStringBuilder append(String str) &#123;</div><div class="line">        if (str == null)</div><div class="line">            return appendNull();</div><div class="line">        int len = str.length();</div><div class="line">        ensureCapacityInternal(count + len);</div><div class="line">        str.getChars(0, len, value, count);</div><div class="line">        count += len;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void ensureCapacityInternal(int minimumCapacity) &#123;</div><div class="line">        // overflow-conscious code</div><div class="line">        if (minimumCapacity - value.length &gt; 0)</div><div class="line">            expandCapacity(minimumCapacity);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void expandCapacity(int minimumCapacity) &#123;</div><div class="line">        int newCapacity = value.length * 2 + 2;</div><div class="line">        if (newCapacity - minimumCapacity &lt; 0)</div><div class="line">            newCapacity = minimumCapacity;</div><div class="line">        if (newCapacity &lt; 0) &#123;</div><div class="line">            if (minimumCapacity &lt; 0) // overflow</div><div class="line">                throw new OutOfMemoryError();</div><div class="line">            newCapacity = Integer.MAX_VALUE;</div><div class="line">        &#125;</div><div class="line">        value = Arrays.copyOf(value, newCapacity);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line"> // String类</div><div class="line">     public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123;</div><div class="line">        if (srcBegin &lt; 0) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcBegin);</div><div class="line">        &#125;</div><div class="line">        if (srcEnd &gt; value.length) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd);</div><div class="line">        &#125;</div><div class="line">        if (srcBegin &gt; srcEnd) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</div><div class="line">        &#125;</div><div class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>String源码学习</title>
    <link href="http://jianwl.com/2018/04/01/String%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/01/String源码学习/</id>
    <published>2018-04-01T04:32:28.000Z</published>
    <updated>2018-04-01T05:59:09.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>从一段代码说起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void stringTest()&#123;</div><div class="line">    String str1 = &quot;a&quot; + &quot;b&quot; + 1;</div><div class="line">    String str2 = &quot;ab1&quot;;</div><div class="line">    System.out.println(str1 == str2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大家猜猜结果如何？如果你的结论是<code>true</code>，再来一段代码；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void stringTest2()&#123;</div><div class="line">    String str1 = new String(&quot;ab1&quot;);</div><div class="line">    String str2 = &quot;ab1&quot;;</div><div class="line">    System.out.println(str1 == str2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如何呢？正确答案是false。</p>
<p>让我们看看经过编译器编译后的代码如何：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 第一段代码</div><div class="line">    public static void stringTest()&#123;</div><div class="line">        String str1 = &quot;ab1&quot;;</div><div class="line">        String str2 = &quot;ab1&quot;;</div><div class="line">        System.out.println(str1 == str2);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">// 第二段代码  </div><div class="line">    public static void stringTest2()&#123;</div><div class="line">        String str1 = new String(&quot;ab1&quot;);</div><div class="line">        String str2 = &quot;ab1&quot;;</div><div class="line">        System.out.println(str1 == str2);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>也就是说第一段代码经过了编译器优化，原因是编译器发现”a”+”b”+1和”ab1”的效果一样，都是不可变量组成，但是为什么他们的内存地址会相同呢？如果你对此还有兴趣，那就一起来看看String类源码；</p>
<h3 id="1-String类"><a href="#1-String类" class="headerlink" title="1 String类"></a>1 String类</h3><p>String类被<code>final</code>所修饰，也就是说String对象是不可变类。String类实现了<code>Serializable</code>、<code>Comparable&lt;String&gt;</code>、<code>CharSequence</code>接口。</p>
<p>Comparable接口有compareTo(String s)方法，CharSequence接口有lengh()、chatAt(int index)、subSequence(int start,int end)方法。</p>
<h3 id="2-String属性"><a href="#2-String属性" class="headerlink" title="2 String属性"></a>2 String属性</h3><p>String类中包含一个不可变的char数组来存放字符串，一个int型的变量hash用来存放计算后的哈希值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/** The value is used for character storage. */</div><div class="line">private final char value[];</div><div class="line"></div><div class="line">/** Cache the hash code for the string */</div><div class="line">private int hash; // Default to 0</div></pre></td></tr></table></figure>
<h3 id="3-String构造函数"><a href="#3-String构造函数" class="headerlink" title="3 String构造函数"></a>3 String构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//不含参数的构造函数，一般没什么用，因为value是不可变量</div><div class="line">    public String() &#123;</div><div class="line">        this.value = &quot;&quot;.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> </div><div class="line">//参数为String类型</div><div class="line">    public String(String original) &#123;</div><div class="line">        this.value = original.value;</div><div class="line">        this.hash = original.hash;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// 声明编码类型    </div><div class="line">    public String(byte bytes[], Charset charset) &#123;</div><div class="line">        this(bytes, 0, bytes.length, charset);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">//参数为char数组，使用java.utils包中的Arrays类复制</div><div class="line">    public String(char value[]) &#123;</div><div class="line">        this.value = Arrays.copyOf(value, value.length);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">//从bytes数组中的offset位置开始，将长度为length的字节，以charsetName格式编码，拷贝到value</div><div class="line">    public String(byte bytes[], int offset, int length, Charset charset) &#123;</div><div class="line">        if (charset == null)</div><div class="line">            throw new NullPointerException(&quot;charset&quot;);</div><div class="line">        checkBounds(bytes, offset, length);</div><div class="line">        this.value =  StringCoding.decode(charset, bytes, offset, length);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="4-String-常用方法"><a href="#4-String-常用方法" class="headerlink" title="4 String 常用方法"></a>4 String 常用方法</h3><h4 id="1-equals"><a href="#1-equals" class="headerlink" title="1) equals()"></a>1) equals()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object anObject) &#123;</div><div class="line">    // 如果引用的是同一个对象，则为真</div><div class="line">    if (this == anObject) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (anObject instanceof String) &#123;</div><div class="line">        String anotherString = (String)anObject;</div><div class="line">        int n = value.length;</div><div class="line">        if (n == anotherString.value.length) &#123;</div><div class="line">            char v1[] = value;</div><div class="line">            char v2[] = anotherString.value;</div><div class="line">            int i = 0;</div><div class="line">            // 比较每一个字符是否相等</div><div class="line">            while (n-- != 0) &#123;</div><div class="line">                if (v1[i] != v2[i])</div><div class="line">                    return false;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>equals方法经常用得到，它用来判断两个对象内容是否相等，String对象判断流程：</p>
<blockquote>
<p>内存地址相同，则为真</p>
<p>如果对象类型不是String类型，则为假；否则继续判断</p>
<p>如果对象长度不相等，则为假，否则继续判断。</p>
<p>从后往前，判断String类中的char数组value的单个字符是否相等，有不相等则为假，如果一直相等直到一个数，则返回真。</p>
<p>由此可以看出，如果对两个超长的字符进行比较还是比较费时间的。</p>
</blockquote>
<h4 id="2-compareTo"><a href="#2-compareTo" class="headerlink" title="2) compareTo"></a>2) compareTo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public int compareTo(String anotherString) &#123;</div><div class="line">    // 自身字符串的长度</div><div class="line">    int len1 = value.length;</div><div class="line"></div><div class="line">    // 比较字符串的长度</div><div class="line">    int len2 = anotherString.value.length;</div><div class="line"></div><div class="line">    // 获取两个字符串的最小长度</div><div class="line">    int lim = Math.min(len1, len2);</div><div class="line">    char v1[] = value;</div><div class="line">    char v2[] = anotherString.value;</div><div class="line"></div><div class="line">    // 从头往后遍历，如果相同位置的字符不相等，则进行比较字符大小；</div><div class="line">    int k = 0;</div><div class="line">    while (k &lt; lim) &#123;</div><div class="line">        char c1 = v1[k];</div><div class="line">        char c2 = v2[k];</div><div class="line">        if (c1 != c2) &#123;</div><div class="line">            return c1 - c2;</div><div class="line">        &#125;</div><div class="line">        k++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 如果前面都相等，就等于当前字符长度 减去 比较字符长度</div><div class="line">    return len1 - len2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法写的很巧妙，先从0开始判断字符大小，如果两个对象能比较字符的地方比较完了还相等，就直接返回自身长度减比较对象长度，如果两个字符串长度相同，则返回0，巧妙地判断了三种情况。</p>
<h4 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3) hashCode()"></a>3) hashCode()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public int hashCode() &#123;</div><div class="line">    int h = hash;</div><div class="line">    if (h == 0 &amp;&amp; value.length &gt; 0) &#123;</div><div class="line">        char val[] = value;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</div><div class="line">            h = 31 * h + val[i];</div><div class="line">        &#125;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div><div class="line">    return h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>String类重写了hashCode方法，Object中的hashCode方法是一个Native调动。String类的hash采用多项式计算。不同的字符串，hashcode是有可能相同的。</p>
<h4 id="4-intern"><a href="#4-intern" class="headerlink" title="4) intern()"></a>4) intern()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public native String intern();</div></pre></td></tr></table></figure>
<p>intern方法是Native调用，它的作用是在方法区中的常量池里通过equals方法寻找字面值相等的对象，如果没有找到则在常量池中开辟一片空间存放字符串并返回字符串引用，否则直接返回常量池中已存在String对象的引用。</p>
<p>将引言中第二段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// String a = new String(&quot;ab1&quot;);</div><div class="line">// 改为</div><div class="line">String a = new String(&quot;ab1&quot;).intern();</div></pre></td></tr></table></figure>
<p>则结果为<code>true</code>，原因在于a所指向的地址来源于常量池，而b所指向的字符串默认会调用这个方法，所以a和b都指向同一个地址。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;从一段代码说起&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hashtable源码学习</title>
    <link href="http://jianwl.com/2018/03/29/Hashtable%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/29/Hashtable源码学习/</id>
    <published>2018-03-28T22:55:24.000Z</published>
    <updated>2018-03-29T23:37:47.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段"><a href="#常用方法-amp-字段" class="headerlink" title="常用方法 &amp; 字段"></a>常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-30/94194717.jpg" alt=""></p>
<p>Hashtable底层是一个数组 + 链表的数据结构，与HashMap的区别在于，其是线程安全、插入的键值对均不能为空、插入元素时，若发生哈希碰撞，Hashtable是从头结点插入，而HashMap1.8版本是从尾部插入；</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><ol>
<li>新增元素时，如何保证线程安全, put()</li>
<li>扩容与数据迁移机制，rehash()</li>
</ol>
<h4 id="1-新增元素时，如何保证线程安全"><a href="#1-新增元素时，如何保证线程安全" class="headerlink" title="1) 新增元素时，如何保证线程安全"></a>1) 新增元素时，如何保证线程安全</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public synchronized V put(K key, V value) &#123;</div><div class="line">    // Make sure the value is not null</div><div class="line">    if (value == null) &#123;</div><div class="line">        throw new NullPointerException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Makes sure the key is not already in the hashtable.</div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    int hash = key.hashCode();</div><div class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</div><div class="line">    for(; entry != null ; entry = entry.next) &#123;</div><div class="line">        if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</div><div class="line">            V old = entry.value;</div><div class="line">            entry.value = value;</div><div class="line">            return old;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addEntry(hash, key, value, index);</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void addEntry(int hash, K key, V value, int index) &#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    if (count &gt;= threshold) &#123;</div><div class="line">        // Rehash the table if the threshold is exceeded</div><div class="line">        rehash();</div><div class="line"></div><div class="line">        tab = table;</div><div class="line">        hash = key.hashCode();</div><div class="line">        index = (hash &amp; 0x7FFFFFFF) % tab.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Creates the new entry.</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</div><div class="line">    tab[index] = new Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    count++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第1行：<code>synchronized</code>关键字用于普通方法时，获取到对象实例的锁才能执行，所以在多线程环境下是线程安全的；</p>
<p>第3 ~ 9行：保证插入的键值对，key和value均不为空，否则抛出空指针异常；</p>
<p>第10行：获取插入元素，在数组中的索引位置；</p>
<p>第11 ~ 19行：获取索引位置的元素(元素为链表头结点)，遍历链表，若新增元素的key，在链表中已存在，则替换键值；</p>
<p>第28 ~ 36行: 如果当前的容量(count) 大于 扩容阈值(threshold),则进行扩容（rehash），得到插入元素在扩容后数组的索引位置；</p>
<p>第39 ~ 42行：获取索引位置的元素(链表头结点)，在头结点之前插入元素，容量 + 1；</p>
<h4 id="2-扩容与数据迁移机制"><a href="#2-扩容与数据迁移机制" class="headerlink" title="2) 扩容与数据迁移机制"></a>2) 扩容与数据迁移机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"> @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line"> protected void rehash() &#123;</div><div class="line"> 	  // ① 当前数组容量</div><div class="line">     int oldCapacity = table.length;</div><div class="line">     Entry&lt;?,?&gt;[] oldMap = table;</div><div class="line"></div><div class="line">     // overflow-conscious code ② 数组扩容为原数组的2倍 + 1</div><div class="line">     int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</div><div class="line">     // ③ 判断新容量是否溢出</div><div class="line">     if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; </div><div class="line">         if (oldCapacity == MAX_ARRAY_SIZE)</div><div class="line">             // Keep running with MAX_ARRAY_SIZE buckets</div><div class="line">             return;</div><div class="line">         newCapacity = MAX_ARRAY_SIZE;</div><div class="line">     &#125;</div><div class="line">     Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];</div><div class="line"></div><div class="line">     modCount++;</div><div class="line">     // ④ 计算出新的扩容阈值</div><div class="line">     threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</div><div class="line">     table = newMap;</div><div class="line">// ⑤ 遍历数组，将数据迁移到新数组中</div><div class="line">     for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;</div><div class="line">         for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123;</div><div class="line">             Entry&lt;K,V&gt; e = old;</div><div class="line">             old = old.next;</div><div class="line"></div><div class="line">             int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</div><div class="line">             e.next = (Entry&lt;K,V&gt;)newMap[index];</div><div class="line">             newMap[index] = e;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>第23 ~ 31行：从后往前遍历数组，得到链表首结点；若首结点不为空，继续遍历链表，将链表中的元素迁移到新容器，发生哈希碰撞时，采用从头结点插入的方式；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HashSet源码学习</title>
    <link href="http://jianwl.com/2018/03/27/HashSet%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/27/HashSet源码学习/</id>
    <published>2018-03-27T00:52:55.000Z</published>
    <updated>2018-03-28T22:51:10.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-29/4636358.jpg" alt=""></p>
<p>HashSet是以HashMap为基础类封装的对象，在新增元素E时，往HashMap中插入(E,Object)的键值对，因为在HashMap中Key是不存在重复的，所以保证了HashSet的唯一性。</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><ol>
<li>如何保证唯一性；</li>
</ol>
<h4 id="如何保证唯一性"><a href="#如何保证唯一性" class="headerlink" title="如何保证唯一性"></a>如何保证唯一性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public HashSet() &#123;</div><div class="line">    map = new HashMap&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean add(E e) &#123;</div><div class="line">    return map.put(e, PRESENT)==null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化HashSet时，会初始化HashMap对象；新增元素时，通过HashMap新增(E,Object)的键值对，从而保证了Key的唯一性；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法&quot;&gt;&lt;a href=&quot;#常用方法&quot; class=&quot;headerlink&quot; title=&quot;常用方法&quot;&gt;&lt;/a&gt;常用方法&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.clouddn.com/18-3-29/4636358.jpg
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码学习</title>
    <link href="http://jianwl.com/2018/03/22/HashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/22/HashMap源码学习/</id>
    <published>2018-03-22T12:39:33.000Z</published>
    <updated>2018-03-27T00:45:45.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-常用方法-amp-字段"><a href="#1-常用方法-amp-字段" class="headerlink" title="1. 常用方法 &amp; 字段"></a>1. 常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-22/24207782.jpg" alt=""></p>
<p>JDK1.8之前，HashMap是一个数组 + 链表的数据结构；通过key的hash值与数组的长度取余，得到该键值对在数组中的索引位。如果该位置上，没有其他元素，就直接放进去；如果该位置上已经有数据了(不同的key值，hash值可能一样)，则通过链表的方式，将元素放到前一个元素的后面。如下图所示：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-22/22584621.jpg" alt="图1-1"></p>
<p>JDK1.8，引入了红黑树，当链表的长度大于等于8时，会将链表转化为红黑树，红黑树的查找时间复杂度是o(lgn)，极大加快了查询的效率。</p>
<h3 id="2-提问"><a href="#2-提问" class="headerlink" title="2. 提问"></a>2. 提问</h3><ol>
<li>HashMap是如何实现扩容的，resize();</li>
<li>为什么HashMap的容量要保持为2的幂次方;</li>
<li>HashMap如何实现新增一个键值对,put(K,V);</li>
<li>HashMap为什么是线程不安全的？</li>
</ol>
<h4 id="1）HashMap是如何实现扩容的"><a href="#1）HashMap是如何实现扩容的" class="headerlink" title="1）HashMap是如何实现扩容的"></a>1）HashMap是如何实现扩容的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</div><div class="line">    int oldThr = threshold;</div><div class="line">    int newCap, newThr = 0;</div><div class="line">    if (oldCap &gt; 0) &#123;</div><div class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 超过最大值不再扩容，随它碰撞去了;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            return oldTab;</div><div class="line">        &#125;</div><div class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 如果当前容量大于16，且扩容2倍之后小于最大整数，则将阈值扩大2倍；</div><div class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</div><div class="line">    &#125;</div><div class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold 如果当前阈值大于0，则新的容量为当前阈值；</div><div class="line">        newCap = oldThr;</div><div class="line">    else &#123;               // zero initial threshold signifies using defaults</div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    if (newThr == 0) &#123;</div><div class="line">        float ft = (float)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</div><div class="line">                  (int)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    if (oldTab != null) &#123;</div><div class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            if ((e = oldTab[j]) != null) &#123;</div><div class="line">                oldTab[j] = null;</div><div class="line">                if (e.next == null)</div><div class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</div><div class="line">                else if (e instanceof TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</div><div class="line">                else &#123; // preserve order</div><div class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</div><div class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        if ((e.hash &amp; oldCap) == 0) &#123; // 原索引</div><div class="line">                            if (loTail == null)</div><div class="line">                                loHead = e;</div><div class="line">                            else</div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        else &#123; // 原索引 + oldCap</div><div class="line">                            if (hiTail == null)</div><div class="line">                                hiHead = e;</div><div class="line">                            else</div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; while ((e = next) != null);</div><div class="line">                    if (loTail != null) &#123;</div><div class="line">                        loTail.next = null;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    if (hiTail != null) &#123;</div><div class="line">                        hiTail.next = null;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第2 ~ 25行：这十几行代码描述的是扩容时，如何确定新的容量和阈值；</p>
<table>
<thead>
<tr>
<th style="text-align:center">当前容量oldCap</th>
<th style="text-align:center">扩容后容量newCap</th>
<th style="text-align:center">扩容后阈值newThre</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">oldCap <code>&gt;=</code> Integer.MAX_VALUE</td>
<td style="text-align:center">oldCap</td>
<td style="text-align:center">Integer.MAX_VALUE</td>
</tr>
<tr>
<td style="text-align:center">16 <code>&lt;</code> oldCap <code>&lt;</code> Integer.MAX_VALUE / 2</td>
<td style="text-align:center">oldCap <code>*</code> 2</td>
<td style="text-align:center">oldThre <code>*</code> 2</td>
</tr>
<tr>
<td style="text-align:center">0 <code>&lt;</code> oldCap <code>&lt;=</code>16</td>
<td style="text-align:center">oldThre</td>
<td style="text-align:center">newCap <code>*</code> 0.75</td>
</tr>
<tr>
<td style="text-align:center">oldCap == 0</td>
<td style="text-align:center">16</td>
<td style="text-align:center">16 <code>*</code> 0.75 = 12</td>
</tr>
</tbody>
</table>
<p>扩容时有4种场景，① 当前容量大于最大整数时，此时不再扩容，随他进行碰撞；② 当前容量大于16且扩容后的容量小于最大整数时，新的容量和阈值都扩大2倍；③ 当容量小于等于16时，这种场景出现在：指定HashMap的初始容量，此时新容量等于当前阈值，新阈值等于新容量 <code>*</code> 加载因子。④ 当前容量为0时，默认初始化容量为16，阈值为12；</p>
<p>第28 ~ 72行：扩容之后，需要将原有的数据迁移到扩容后的结构中；分为三种场景：① 同一个哈希槽位上，只有一个元素；② 同一个哈希槽位上，不止一个元素但小于8个元素(这几个元素，已链表的结构存在)；③ 同一个哈希槽位上，超过8个元素，(此时为这些元素，已红黑树的结构存在)；这里我们重点分析前两种情况，对于红黑树，等后续研究透了，再来分析；</p>
<p>场景①分析：</p>
<p>对应代码为35 ~ 36行：很简单，如果当前哈希槽位只有一个元素，那么将当前元素的哈希值 取余 新数组容量，获取新数组中的索引位置即可；<code>e.hash &amp; (newcap - 1)</code> 等价于 <code>e.hash % newcap</code></p>
<p>场景②分析：</p>
<p>对应代码为39 ~ 68行：同一个哈希槽位上存在多个元素(小于8)，这些元素可分为两种情况：1、 元素的哈希值 &amp; oldCap == 0，其索引位置为原索引；2、元素的哈希值 &amp; oldCap != 0,其索引位置为原索引 + oldCap；举个例子说明下：oldCap = 8, newCap = 16;那么哈希值为15时，其在新数组中的位置为：7 + 8 = 15；哈希值为7时，在新数组中的位置为7跟原来的位置一样。</p>
<h4 id="2-HashMap的容量如何做到保持为2的幂次方"><a href="#2-HashMap的容量如何做到保持为2的幂次方" class="headerlink" title="2) HashMap的容量如何做到保持为2的幂次方"></a>2) HashMap的容量如何做到保持为2的幂次方</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</div><div class="line">    if (initialCapacity &lt; 0)</div><div class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</div><div class="line">                                           initialCapacity);</div><div class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</div><div class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</div><div class="line">                                           loadFactor);</div><div class="line">    this.loadFactor = loadFactor;</div><div class="line">    this.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 返回大于等于当前值，最接近2的n次方的数据；</div><div class="line"> * Returns a power of two size for the given target capacity.</div><div class="line"> */</div><div class="line">static final int tableSizeFor(int cap) &#123;</div><div class="line">    int n = cap - 1; // 为了避免刚好是2的n次方的情况，这样会返回 2 的n+1次方，跟预期不符合；</div><div class="line">    n |= n &gt;&gt;&gt; 1; // 前2位都是1；</div><div class="line">    n |= n &gt;&gt;&gt; 2; // 前4位都是1；</div><div class="line">    n |= n &gt;&gt;&gt; 4; // 前8位都是1</div><div class="line">    n |= n &gt;&gt;&gt; 8; // 前16位都是1；</div><div class="line">    n |= n &gt;&gt;&gt; 16;// 前32位都是1；</div><div class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化容量有两种方式：① newcap = 默认值16，loadfactor = 默认值0.75f; newthreshold = newcap <code>*</code> loadfactor; ② threshold = 最接近2的幂次方的初始化容量；之后在扩容阶段得到：newcap = threshold; newthreshold = loadfactor <code>*</code> newcap;</p>
<p>这里我们重点分析场景2：</p>
<p>核心代码为18 ~ 25行，初始化容量n，将 n - 1后的值进行移位或操作，可以保证从(n - 1)的二进制值，从高位1开始之后的二进制数都是1。这里举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">若初始化容量为6：</div><div class="line">n - 1 = 5 // 101</div><div class="line">n |= n &gt;&gt;&gt; 1 // 101 | 011 = 111 (保证1 ~ 2位，位移数都是1)</div><div class="line">n |= n &gt;&gt;&gt; 2 // 111 | 001 = 111 (保证3 ~ 4位，位移数都是1)</div><div class="line">n |= n &gt;&gt;&gt; 4 // 111 | 000 = 111 (保证5 ~ 8位，位移数都是1)</div><div class="line">n |= n &gt;&gt;&gt; 8 // 111 | 000 = 111 (保证9 ~ 16位，位移数都是1)</div><div class="line">n |= n &gt;&gt;&gt; 16 // 111 | 000 = 111 (保证17 ~ 32位，位移数都是1)</div><div class="line">最后将1加回去：</div><div class="line">n = n + 1 // 8,得到大于6，的最小2的幂次方的数值为2的3次方；</div></pre></td></tr></table></figure>
<h5 id="容量保持2的幂次方，有什么好处呢"><a href="#容量保持2的幂次方，有什么好处呢" class="headerlink" title="容量保持2的幂次方，有什么好处呢?"></a>容量保持2的幂次方，有什么好处呢?</h5><p>主要是跟HashMap的存储方式有关；这里简单介绍下：</p>
<p>1、hash(key)，得到插入元素的Key的哈希值;</p>
<p>2、hash(key) &amp; (n -1) , 得到元素在数组中的索引值；</p>
<p>这里重点说下步骤2，hash(key) &amp; (n -1)等价于 hash(key) % n,这个等价是有条件的，n必须是为n的幂次方。否则条件不成立；这里举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// n非2的幂次方</div><div class="line">hash(key): 11, n: 6</div><div class="line"></div><div class="line">hash(key) &amp; (n - 1) // 1011 &amp; 101 = 0001 明显不等于 11 % 6 = 5</div><div class="line"></div><div class="line">// n为2的幂次方</div><div class="line">hash(key): 11, n: 8</div><div class="line"></div><div class="line">hash(key) &amp; (n -1) // 1011 &amp; 111 = 0011 等于 11 % 8 = 3</div></pre></td></tr></table></figure>
<p>这就是为什么要保持容量为2的幂次方的原因。那么有人要问了，为什么要通过与操作进行求余，为什么不通过%操作符操作呢？因为与操作的执行效率高；</p>
<h4 id="3）HashMap如何实现新增一个键值对"><a href="#3）HashMap如何实现新增一个键值对" class="headerlink" title="3）HashMap如何实现新增一个键值对"></a>3）HashMap如何实现新增一个键值对</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">    return putVal(hash(key), key, value, false, true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">               boolean evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">    if ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">        n = (tab = resize()).length; // tab为空，初始化tab；</div><div class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null) // 没有hash冲突</div><div class="line">        tab[i] = newNode(hash, key, value, null); // 在指定哈希槽插入元素；</div><div class="line">    else &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        if (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // hash一直；key一致；覆盖元素；</div><div class="line">            e = p;</div><div class="line">        else if (p instanceof TreeNode) // 在指定hash位取出的元素是红黑树，往红黑树中插入元素；</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 红黑树插入元素</div><div class="line">        else &#123;</div><div class="line">            for (int binCount = 0; ; ++binCount) &#123;</div><div class="line">                if ((e = p.next) == null) &#123; // 首节点后 + 数据</div><div class="line">                    p.next = newNode(hash, key, value, null);</div><div class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 链表长度大于等于8</div><div class="line">                        treeifyBin(tab, hash); // 转化为红黑树</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 如果key值相当直接退出循环;</div><div class="line">                    break;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (e != null) &#123; // existing mapping for key</div><div class="line">            V oldValue = e.value;</div><div class="line">            if (!onlyIfAbsent || oldValue == null)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    if (++size &gt; threshold)</div><div class="line">        resize(); // 扩容</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第8 ~ 9行：当table的容量为空时，进行扩容；</p>
<p>第10 ~ 11行：获取新增元素在数组中的索引位置，若该位置上没有其他元素，则插入元素；</p>
<p>第12 ~ 40行: 这里着重解释，当存在hash冲突时(即新增元素的在数组中的索引存在其他元素)，如何解决； </p>
<p>第14 ~ 16行：当前元素与新增元素，key完全一样时，获取当前元素值；</p>
<p>第17 ~ 18行：当新增元素索引位，元素结构为红黑树时，往红黑树中插入元素；</p>
<p>第19 ~ 40行: 这里描述的是新增元素索引位，元素的结构为链表；</p>
<p>第20 ~ 26行：死循环，如果找到链表的尾部节点，则在链表后新增元素；判断链表长度 <code>&gt;=</code> 8，若是，则将链表转为红黑树；</p>
<p>第27 ~ 29行：若key与新增元素key相同，则直接退出死循环；</p>
<p>第30行：节点往后移动一位；</p>
<p>第33 ~ 38行：如何存在key相同的元素，是否需要覆盖键值；</p>
<p>第42 ~ 43行：如果元素长度大于扩容阈值，则进行扩容；</p>
<p>具体实现流程图如下：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-27/49558429.jpg" alt=""></p>
<h4 id="4）HashMap为什么是线程不安全的"><a href="#4）HashMap为什么是线程不安全的" class="headerlink" title="4）HashMap为什么是线程不安全的"></a>4）HashMap为什么是线程不安全的</h4><p>JDK1.7在并发情况下，在扩容时会造成环链问题，导致死循环，在JDK1.8版本中已经不存在了；但HashMap依旧不适用于多线程，HashMap的设计目标是简洁高效，没有采取任何措施保障put、remove操作的多线程安全；且在并发环境下，无法保障内存的可见性; </p>
<p>目前这个解释的比较含糊，后续给出具体实例，说明其线程不安全的情况；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#1-常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;1. 常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;1. 常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList源码学习</title>
    <link href="http://jianwl.com/2018/03/17/LinkedList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/17/LinkedList源码学习/</id>
    <published>2018-03-17T04:36:38.000Z</published>
    <updated>2018-03-18T05:22:34.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段梳理"><a href="#常用方法-amp-字段梳理" class="headerlink" title="常用方法 &amp; 字段梳理"></a>常用方法 &amp; 字段梳理</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-17/8479145.jpg" alt=""></p>
<p>LinkedList的底层数据结构是链表，链表是由许多个节点连接而成，每个节点包含三个部分,如图所示：<img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-18/30835149.jpg" alt=""></p>
<p>pre、next分别存放上一个节点的地址和下一个节点的地址，data存放该节点的数据。</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><ol>
<li>如何新增数据, add(E e)</li>
<li>如何在指定位置新增数据,add(int index,E e)</li>
<li>如何获取指定元素的位置，indexOf(Object o)</li>
<li>如何清空整个链表，clear()</li>
</ol>
<h4 id="1-如何新增数据"><a href="#1-如何新增数据" class="headerlink" title="1) 如何新增数据"></a>1) 如何新增数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line">    linkLast(e);</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void linkLast(E e) &#123;</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line">    last = newNode;</div><div class="line">    if (l == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static class Node&lt;E&gt; &#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node&lt;E&gt; prev;</div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        this.item = element;</div><div class="line">        this.next = next;</div><div class="line">        this.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第7行：首先获取链表当前的尾节点l；</p>
<p>第8行：初始化新增节点newNode，包含上一个节点位置、节点数据、下一个节点位置；</p>
<p>第9行：设置新的尾节点为新增节点,last = newNode</p>
<p>第10 ~ 13行：尾节点l为空，那么设置首节点为新节点；反之，设置尾节点l的下一个节点位置为newNode; </p>
<p>第7行 ~ 第13行描述用图示表示：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-18/1333450.jpg" alt=""></p>
<p>第18 ~ 27行：一个节点包括三部分：当前节点数据、上一个节点地址、下一个节点地址</p>
<h4 id="2-如何在指定位置新增数据"><a href="#2-如何在指定位置新增数据" class="headerlink" title="2) 如何在指定位置新增数据"></a>2) 如何在指定位置新增数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public void add(int index, E element) &#123;</div><div class="line">    checkPositionIndex(index);</div><div class="line"></div><div class="line">    if (index == size)</div><div class="line">        linkLast(element);</div><div class="line">    else</div><div class="line">        linkBefore(element, node(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void linkLast(E e) &#123;</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line">    last = newNode;</div><div class="line">    if (l == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Node&lt;E&gt; node(int index) &#123;</div><div class="line">    // assert isElementIndex(index);</div><div class="line"></div><div class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        for (int i = 0; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        return x;</div><div class="line">    &#125; else &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        for (int i = size - 1; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</div><div class="line">    // assert succ != null;</div><div class="line">    final Node&lt;E&gt; pred = succ.prev;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</div><div class="line">    succ.prev = newNode;</div><div class="line">    if (pred == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        pred.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第2行：检查新增的位置是否越界了(位置范围是：[0,size])</p>
<p>第4 ~ 5行：新增的位置为链表长度(size),链表尾节点所在位置为：(size -1)，所以在该位置(size位置)新增节点，类似在尾节点新增节点。上一个功能点已描述，这里就不赘述了。</p>
<p>第22 ~ 36行：二分法，判断新增位置处于size的左部分([0,size/2])还是右部分((size/2,size -1])，左部分，从首节点，头往后找；右部分，从尾节点，从后往前找。</p>
<p>第38 ~ 48行：新增位置的原来节点为：succ;如果succ的上一个节点为null，则说明新增位置为首节点；反之，新增位置为中间节点。首节点位置新增时，初始化新增节点，并将原首节点位置的上个节点地址设置为新增节点；中间节点位置新增时，初始化新增节点，并将上一个节点的下一个节点位置，设置为新增节点。</p>
<p>第38 ~ 48行图示如下：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-18/17702167.jpg" alt=""></p>
<h4 id="3-如何获取指定元素的位置"><a href="#3-如何获取指定元素的位置" class="headerlink" title="3) 如何获取指定元素的位置"></a>3) 如何获取指定元素的位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public int indexOf(Object o) &#123;</div><div class="line">    int index = 0;</div><div class="line">    if (o == null) &#123;</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (x.item == null)</div><div class="line">                return index;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (o.equals(x.item))</div><div class="line">                return index;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从首节点开始遍历，寻找的对象分两种：空对象和非空对象；若节点值等于寻找的对象，返回游标值；</p>
<h4 id="4）如何清空整个链表"><a href="#4）如何清空整个链表" class="headerlink" title="4）如何清空整个链表"></a>4）如何清空整个链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void clear() &#123;</div><div class="line">    // Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</div><div class="line">    // - helps a generational GC if the discarded nodes inhabit</div><div class="line">    //   more than one generation</div><div class="line">    // - is sure to free memory even if there is a reachable Iterator</div><div class="line">    for (Node&lt;E&gt; x = first; x != null; ) &#123;</div><div class="line">        Node&lt;E&gt; next = x.next;</div><div class="line">        x.item = null;</div><div class="line">        x.next = null;</div><div class="line">        x.prev = null;</div><div class="line">        x = next;</div><div class="line">    &#125;</div><div class="line">    first = last = null;</div><div class="line">    size = 0;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>遍历链表，将每一个节点的数据清空，最后将头结点和尾节点的数据清空，链表长度设置为0；</p>
<p>刚开始有个疑问，清空整个链表了，首、尾两节点已经为空了，为什么在第13行代码还需要再次清空呢？其实呢，首节点和尾节点单独存到变量里，所以在清空链表的时候，first、last节点都是有数据的，所以还需要单独清空。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段梳理&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段梳理&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段梳理&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段梳理&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码学习</title>
    <link href="http://jianwl.com/2018/03/15/ArrayList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/15/ArrayList源码学习/</id>
    <published>2018-03-15T15:05:33.000Z</published>
    <updated>2018-03-17T03:44:38.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-常用方法-amp-字段梳理"><a href="#1-常用方法-amp-字段梳理" class="headerlink" title="1. 常用方法 &amp; 字段梳理"></a>1. 常用方法 &amp; 字段梳理</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-15/41421167.jpg" alt=""></p>
<p>ArrayList底层的数据结构是数组，往列表中插入数据时，首先会检查列表的容量是否充足，当容量不够时，会自动扩容为当前容量的3倍，本节我们会带着问题，学习ArrayList的实现原理。</p>
<h3 id="2-提出问题"><a href="#2-提出问题" class="headerlink" title="2. 提出问题"></a>2. 提出问题</h3><ol>
<li>add(E)，新增元素时，如何实现自动扩容；</li>
<li>add(index,E)如何实现在指定位置插入元素，指定位置之后的元素如何处理？</li>
<li>clear(), 避免内存溢出，在移除元素时，我们应该注意些什么？</li>
</ol>
<h4 id="1）新增元素"><a href="#1）新增元素" class="headerlink" title="1）新增元素"></a>1）新增元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"># 新增元素入口</div><div class="line">   public boolean add(E e) &#123;</div><div class="line">       ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div class="line">       elementData[size++] = e;</div><div class="line">       return true;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   private void ensureCapacityInternal(int minCapacity) &#123;</div><div class="line">       if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       ensureExplicitCapacity(minCapacity);</div><div class="line">   &#125;</div><div class="line">       </div><div class="line">   private void ensureExplicitCapacity(int minCapacity) &#123;</div><div class="line">       modCount++;</div><div class="line"></div><div class="line">       // overflow-conscious code</div><div class="line">       if (minCapacity - elementData.length &gt; 0)</div><div class="line">           grow(minCapacity);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   private void grow(int minCapacity) &#123;</div><div class="line">       // overflow-conscious code</div><div class="line">       int oldCapacity = elementData.length;</div><div class="line">       int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 为原来的3倍；</div><div class="line">       if (newCapacity - minCapacity &lt; 0)</div><div class="line">           newCapacity = minCapacity;</div><div class="line">       if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</div><div class="line">           newCapacity = hugeCapacity(minCapacity);</div><div class="line">       // minCapacity is usually close to size, so this is a win:</div><div class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   private static int hugeCapacity(int minCapacity) &#123;</div><div class="line">       if (minCapacity &lt; 0) // overflow</div><div class="line">           throw new OutOfMemoryError();</div><div class="line">       return (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">           Integer.MAX_VALUE :</div><div class="line">           MAX_ARRAY_SIZE;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>第3 ~ 4行：新增一个元素之前，需要先确保元素加进去之后，容量是否会溢出;如果容量够用，则往数组中插入数据；</p>
<p>第9 ~ 11行：如果是一个空列表，当前最小的容量(size + 1)为默认值10；</p>
<p>第 20 ~ 21行：如果新增元素后，元素的数量(size + 1) <strong>大于</strong> 数组的长度(elementData.length),则扩容；</p>
<p>第26 ~ 33行：扩容的逻辑，将列表的容量扩大为原来的3倍即(3 elementData.length),如果扩容后的容量 <strong>仍旧小于</strong> 元素的数量(size + 1),则将列表容量设置为(size + 1)，之后判断扩容后的容量是否大于「最大的整数 - 8」，如果大于，则等于最大整数；最后将原来的数组迁移到扩容后的数组；</p>
<p>第37 ~ 38行：为了防止当容量大于整数最大值即(大于Integer.MAX_VALUE)，此时会出现整型数据溢出，为负值，此时报内存溢出异常。</p>
<h4 id="2-指定位置新增元素"><a href="#2-指定位置新增元素" class="headerlink" title="2) 指定位置新增元素"></a>2) 指定位置新增元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void add(int index, E element) &#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div class="line">    System.arraycopy(elementData, index, elementData, index + 1,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void rangeCheckForAdd(int index) &#123;</div><div class="line">    if (index &gt; size || index &lt; 0)</div><div class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第12 ~ 13行：判断索引位置会不会越界即(大于数组大小和小于0)；</p>
<p>第 4 行：新增元素前，进行容量预估，容量不足时则扩容。上一个模块已描述，这里就不赘述了；</p>
<p>第 5 行：用图示的方式来说明，如果往元素2的位置插入元素，需要将元素2及之后的元素均向后挪动一位，这行代码就是执行这样的功能。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-17/23285668.jpg" alt=""></p>
<p>第7 ~ 8行：把元素放到数组中的指定位置，同时将列表的长度加1。</p>
<h4 id="3）清空数组"><a href="#3）清空数组" class="headerlink" title="3）清空数组"></a>3）清空数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void clear() &#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    // clear to let GC do its work</div><div class="line">    for (int i = 0; i &lt; size; i++)</div><div class="line">        elementData[i] = null;</div><div class="line"></div><div class="line">    size = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第5 ~ 6行：遍历数组中的每一个元素，将其设置为null，方便后续GC回收内存。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-常用方法-amp-字段梳理&quot;&gt;&lt;a href=&quot;#1-常用方法-amp-字段梳理&quot; class=&quot;headerlink&quot; title=&quot;1. 常用方法 &amp;amp; 字段梳理&quot;&gt;&lt;/a&gt;1. 常用方法 &amp;amp; 字段梳理&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;ht
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
</feed>
