<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录点滴成长</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianwl.com/"/>
  <updated>2018-05-15T13:53:09.646Z</updated>
  <id>http://jianwl.com/</id>
  
  <author>
    <name>流云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于「数据库架构」和「查询优化」的分享</title>
    <link href="http://jianwl.com/2018/05/15/%E5%85%B3%E4%BA%8E%E3%80%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E3%80%8D%E5%92%8C%E3%80%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E3%80%8D%E7%9A%84%E5%88%86%E4%BA%AB/"/>
    <id>http://jianwl.com/2018/05/15/关于「数据库架构」和「查询优化」的分享/</id>
    <published>2018-05-14T23:58:14.000Z</published>
    <updated>2018-05-15T13:53:09.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>部门技术分享，选了个数据库专题，做完KeyNote，顺便整理成文，方便后续查阅和补充；本次分享囊括数据库架构、存储引擎功能对比、常用InnoDB日志以及InnoDB逻辑储存结构、索引相关和模拟线上并发问题；</p>
<h3 id="1-MySQL体系结构"><a href="#1-MySQL体系结构" class="headerlink" title="1. MySQL体系结构"></a>1. MySQL体系结构</h3><p> <img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/89852452.jpg" alt=""></p>
<p> MySQL由以下几部分组成： 连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、优化器组件、缓冲组件、插件式存储引擎、物理文件。</p>
<p> MySQL数据库与其他数据库不一样的地方，最重要的一点就是其「插件式的表存储引擎」。特别注意，存储引擎是基于表的，而不是数据库。</p>
<h3 id="2-存储引擎功能对比"><a href="#2-存储引擎功能对比" class="headerlink" title="2. 存储引擎功能对比"></a>2. 存储引擎功能对比</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/94396221.jpg" alt=""></p>
<h4 id="2-1-MyISAM"><a href="#2-1-MyISAM" class="headerlink" title="2-1 MyISAM"></a>2-1 MyISAM</h4><p>不支持事务、表锁设计、支持全文索引，主要面向线上分析处理(OLAP)数据库应用。MyISAM另一个与众不同的地方是它的缓冲池只缓存「索引文件」，而不缓存「数据文件」。</p>
<h4 id="2-2-InnoDB"><a href="#2-2-InnoDB" class="headerlink" title="2-2 InnoDB"></a>2-2 InnoDB</h4><p>支持数据、行锁设计、支持B+树索引、哈希索引、全文索引、支持外键，设计目标主要面向在线事务处理(OLTP)应用。InnoDB通过多版本并发控制(MVCC)来获得并发，并且实现SQL标准的4个隔离级别。默认隔离级别是「REPEATABLE-READ」</p>
<h4 id="2-3-NDB"><a href="#2-3-NDB" class="headerlink" title="2-3 NDB"></a>2-3 NDB</h4><p>NDB是个「集群式」存储引擎，其将数据全部放在内存中(MySQL5.1版本开始，可以将索引数据放在磁盘上)，因此通过主键查询速度极快，且通过增加NDB数据存储节点，可以线性提高数据库性能。</p>
<p>有个问题值得注意：NDB存储引擎的连接操作是在MySQL数据库层完成，而不是在存储引擎层完成。这意味着，复杂的连接操作需要巨大的网络开销。</p>
<h4 id="2-4-Memory"><a href="#2-4-Memory" class="headerlink" title="2-4 Memory"></a>2-4 Memory</h4><p>将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据将消失。它非常使用于存储临时数据的临时表。默认使用「哈希索引」</p>
<h4 id="2-5-Archive"><a href="#2-5-Archive" class="headerlink" title="2-5 Archive"></a>2-5 Archive</h4><p>只持此INSERT和SELECT操作，从MySQL5.1开始支持索引。Archive存储引擎使用zlib算法将数据行进行压缩后存储，应用场景主要是「存储归档数据」。</p>
<h4 id="2-6-Federated"><a href="#2-6-Federated" class="headerlink" title="2-6 Federated"></a>2-6 Federated</h4><p>表不存放数据，它只是指向一台远程MySQL数据库服务器上的表。</p>
<h4 id="2-7-Maria"><a href="#2-7-Maria" class="headerlink" title="2-7 Maria"></a>2-7 Maria</h4><p>Maria是新开发的引擎，设计目标是取代原有的MyISAM存储引擎。其特点是: 支持缓存数据和索引文件，应用行锁设计，提供MVCC功能，支持事务和非事务的安全选项，以及更好的BLOB字符类型的处理性能。</p>
<h3 id="3-InnoDB"><a href="#3-InnoDB" class="headerlink" title="3. InnoDB"></a>3. InnoDB</h3><h4 id="3-1-日志文件"><a href="#3-1-日志文件" class="headerlink" title="3-1 日志文件"></a>3-1 日志文件</h4><p>用来记录MySQL实例对某种条件做出响应时写入的文件，如错误日志文件、二进制文件、慢查询日志。</p>
<h5 id="1）错误日志文件"><a href="#1）错误日志文件" class="headerlink" title="1）错误日志文件"></a>1）错误日志文件</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/248741.jpg" alt=""></p>
<p>可以得到错误日志文件在本地存储的位置；</p>
<h5 id="2）慢查询日志文件"><a href="#2）慢查询日志文件" class="headerlink" title="2）慢查询日志文件"></a>2）慢查询日志文件</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/83986237.jpg" alt=""></p>
<p>默认情况下，慢查询日志不是开启的，通过slow_query_log查看，如果未开启，需要通过以下命令开启。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set global slow_query_log = ON</div></pre></td></tr></table></figure>
<p>long_query_time是查询时间超过这个值，就认为是慢查询；slow_query_log_file是慢查询在本地存储的位置。</p>
<h5 id="3）二进制文件"><a href="#3）二进制文件" class="headerlink" title="3）二进制文件"></a>3）二进制文件</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/8138280.jpg" alt=""></p>
<p>二进制文件记录了MySQL数据库执行更改的所有操作，不包括SELECT 和 SHOW这类操作，因为这类操作对数据本身没有修改。</p>
<h4 id="3-2-逻辑存储结构"><a href="#3-2-逻辑存储结构" class="headerlink" title="3-2 逻辑存储结构"></a>3-2 逻辑存储结构</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/22066716.jpg" alt=""></p>
<p>存储引擎是基于表，所有数据都被逻辑存放在一个空间，称为表空间(tableSpace)。表空间又由段(segment)、区(extent)和页(page)组成。</p>
<h5 id="1-表空间"><a href="#1-表空间" class="headerlink" title="1) 表空间"></a>1) 表空间</h5><p>用于存放数据、索引和插入缓冲页；</p>
<h5 id="2-段"><a href="#2-段" class="headerlink" title="2) 段"></a>2) 段</h5><p>表空间由各个段组成，常见的段有数据段、索引段、回滚段；</p>
<h5 id="3）区"><a href="#3）区" class="headerlink" title="3）区"></a>3）区</h5><p>区是由连续页组成，在任何情况下每个区的大小都是1MB。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4 ~ 5个区，在默认情况下, 页的大小为16K，即一个区有64个连续的页。</p>
<h4 id="3-3-由慢查询引发的思考"><a href="#3-3-由慢查询引发的思考" class="headerlink" title="3-3 由慢查询引发的思考"></a>3-3 由慢查询引发的思考</h4><h5 id="1-什么是慢查询？"><a href="#1-什么是慢查询？" class="headerlink" title="1) 什么是慢查询？"></a>1) 什么是慢查询？</h5><p>Innodb会设置<code>long_query_time</code>参数，查询时间超过这个数值，则判定这个查询为慢查询；</p>
<h5 id="2）如何解决慢查询？"><a href="#2）如何解决慢查询？" class="headerlink" title="2）如何解决慢查询？"></a>2）如何解决慢查询？</h5><p>从三个层面上解决，① 优化查询本身；② 调优表包括增加索引； ③ 调优服务器</p>
<h6 id="优化查询本身"><a href="#优化查询本身" class="headerlink" title="优化查询本身"></a>优化查询本身</h6><p> ① 是否向数据请求了不需要的数据；② 大查询切分为小查询；③ 分解关联查询，可增加缓存命中概率；</p>
<h6 id="优化表"><a href="#优化表" class="headerlink" title="优化表"></a>优化表</h6><p>① 创建表时字段够用就好，越小越好；② 字段不能为空, 字段加索引需要额外空间，含NULL的复合索引无效；③ 加索引，后文会详细接受；</p>
<h6 id="调优服务器"><a href="#调优服务器" class="headerlink" title="调优服务器"></a>调优服务器</h6><p>调节缓冲区参数；</p>
<h5 id="3）联合索引"><a href="#3）联合索引" class="headerlink" title="3）联合索引"></a>3）联合索引</h5><h6 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h6><p>① 联合索引，最左匹配原则；</p>
<h6 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h6><p>① <code>=</code>可以向后传递 ② <code>in</code>如果后面是<code>=</code>或<code>in</code>可以传递 ③ <code>&gt;</code>、<code>&lt;</code>、<code>GROUP BY</code>、<code>ORDER BY</code>、<code>LIKE</code>不向后传递；</p>
<h5 id="4）索引原理"><a href="#4）索引原理" class="headerlink" title="4）索引原理"></a>4）索引原理</h5><p>索引是用B+树的数据结构；B+树包含「索引页」和「数据页」；索引页为非叶子节点，不存数据，只存指向；数据页为叶子节点，只存数据；B+树有一些特性：① 左树小于中间数；② 右树大于中间数；③ 数据页之间是通过双向链表连接的；</p>
<h6 id="B-树插入3种情况"><a href="#B-树插入3种情况" class="headerlink" title="B+树插入3种情况"></a>B+树插入3种情况</h6><p>① 叶子节点(数据页)和非叶子节点(索引页)都未满，插入数据直接插入到叶子节点；（插入28）</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/77745979.jpg" alt=""></p>
<p>② 非叶子节点未满，叶子节点满了；拆分叶子节点，将中间的节点放入Index Page中，小于中间节点的记录放左边，大于或等于中间节点的记录放右边；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/66912616.jpg" alt=""></p>
<p>③ 叶子节点和非叶子节点都满了；拆分叶子节点，小于中间节点的记录放左边，大于或等于中间节点的记录放右边，拆分Index Page，小于中间节点的记录放左边，大于中间节点的记录放右边，中间节点放上一层Index Page。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-5-15/30209172.jpg" alt=""></p>
<h4 id="3-4-模拟并发问题"><a href="#3-4-模拟并发问题" class="headerlink" title="3-4 模拟并发问题"></a>3-4 模拟并发问题</h4><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `parent` (</div><div class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</div><div class="line">  PRIMARY KEY (`id`)</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=67 DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure>
<h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><p>1) 客户端1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">insert into parent values(2);</div><div class="line"></div><div class="line">select * from parent;</div><div class="line"></div><div class="line">update parent set id = sleep(30) where id = 2;</div></pre></td></tr></table></figure>
<p>2) 客户端2</p>
<p>因为行锁，以下SQL耗时27.55秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update parent set id = 22 where id = 2;</div></pre></td></tr></table></figure>
<p>3) 客户端3</p>
<p>查看当前执行的线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show processlist \G;</div></pre></td></tr></table></figure>
<h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>1）客户端1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">insert into parent values(3);</div><div class="line"></div><div class="line">begin;</div><div class="line"></div><div class="line">update parent set id = 33 where id = 3;</div></pre></td></tr></table></figure>
<p>2) 客户端2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select * from parent;</div><div class="line"></div><div class="line">begin;</div><div class="line"></div><div class="line">update parent set id = 333 where id = 3;</div></pre></td></tr></table></figure>
<p>3) 客户端3</p>
<p>查看事务情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show engine innodb status \G;</div></pre></td></tr></table></figure>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>1) 客户端1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">begin; // 步骤1</div><div class="line">insert into parent values(4); // 步骤2</div><div class="line">update parent set id = 5 where id = 4; // 步骤5</div></pre></td></tr></table></figure>
<p>2) 客户端2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">begin；// 步骤3</div><div class="line">insert into parent values(5); // 步骤4</div><div class="line">update parent set id = 4 where id = 5; // 步骤6</div></pre></td></tr></table></figure>
<p>3) 客户端</p>
<p>查看死锁情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show engine innodb status \G;</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" target="_blank" rel="external">执行计划explain各个参数含义</a></li>
<li>MySQL排查指南</li>
<li>InnoDB存储引擎</li>
<li>高性能MySQL</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;部门技术分享，选了个数据库专题，做完KeyNote，顺便整理成文，方便后续查阅和补充；本次分享囊括数据库架构、存储引擎功能对比、常用Inno
    
    </summary>
    
      <category term="MYSQL" scheme="http://jianwl.com/categories/MYSQL/"/>
    
    
      <category term="MYSQL" scheme="http://jianwl.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>Thread源码学习</title>
    <link href="http://jianwl.com/2018/05/04/Thread%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/05/04/Thread源码学习/</id>
    <published>2018-05-03T22:47:52.000Z</published>
    <updated>2018-05-04T00:19:01.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Thread内部有个State枚举，表示线程的状态"><a href="#1、Thread内部有个State枚举，表示线程的状态" class="headerlink" title="1、Thread内部有个State枚举，表示线程的状态"></a>1、Thread内部有个State枚举，表示线程的状态</h3><ul>
<li>NEW, 新建未开始</li>
<li>RUNNABLE，可执行，但他可能处于等待系统资源状态，因为CPU此时别其他线程占用；</li>
<li>BLOCKED，阻塞状态，等待一个monitor lock，在调用wait方法后，进入synchronized同步块或方法</li>
<li>WAITING, 等待状态，调用以下方法导致进入等待状态，object.wait()、Thread.join()、LockSupport.park()</li>
<li>TIMED_WAITING, 带超时时间的等待，调用以下方法会处于这个状态 Thread.sleep()、Object.wait()、Thread.join()、LockSupport.parkNanos()、LockSupport.parkUntil()</li>
<li>TERMINATED, 终止状态</li>
</ul>
<p>2、接着看下Thread的构造函数及其他几个相关的成员变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">/* 带目标run对象. */</div><div class="line">   private Runnable target;</div><div class="line"></div><div class="line">   /* 线程组 */</div><div class="line">   private ThreadGroup group;</div><div class="line">   </div><div class="line">   /* 此线程的类加载器 */</div><div class="line">   private ClassLoader contextClassLoader;</div><div class="line">   </div><div class="line">   /* 想要的栈大小，为0时此参数被忽略，且有VM不支持此参数 */</div><div class="line">    private long stackSize;</div><div class="line">    </div><div class="line">   /* 状态标识，0代表新建未开始*/</div><div class="line">   private volatile int threadStatus = 0;</div><div class="line">   </div><div class="line">   /* 静态native方法，返回当前线程*/</div><div class="line">   public static native Thread currentThread();</div><div class="line"></div><div class="line"></div><div class="line">   public Thread() &#123;</div><div class="line">       init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</div><div class="line">   &#125;</div><div class="line">   public Thread(Runnable target) &#123;</div><div class="line">       init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);</div><div class="line">   &#125;</div><div class="line">    Thread(Runnable target, AccessControlContext acc) &#123;</div><div class="line">       init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0, acc);</div><div class="line">   &#125;</div><div class="line">    public Thread(ThreadGroup group, Runnable target) &#123;</div><div class="line">       init(group, target, &quot;Thread-&quot; + nextThreadNum(), 0);</div><div class="line">   &#125;</div><div class="line">    public Thread(String name) &#123;</div><div class="line">       init(null, null, name, 0);</div><div class="line">   &#125;</div><div class="line">   public Thread(ThreadGroup group, String name) &#123;</div><div class="line">       init(group, null, name, 0);</div><div class="line">   &#125;</div><div class="line">   public Thread(Runnable target, String name) &#123;</div><div class="line">       init(null, target, name, 0);</div><div class="line">   &#125;</div><div class="line">   public Thread(ThreadGroup group, Runnable target, String name) &#123;</div><div class="line">       init(group, target, name, 0);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   /**</div><div class="line">    * Initializes a Thread.</div><div class="line">    *</div><div class="line">    * @param g 线程组</div><div class="line">    * @param target 要执行的带run的目标对象</div><div class="line">    * @param name 线程名</div><div class="line">    * @param stackSize 新线程的栈大小，等于0时可忽略此参数</div><div class="line">    * @param acc 接入控制上下文</div><div class="line">    */</div><div class="line">   private void init(ThreadGroup g, Runnable target, String name,</div><div class="line">                     long stackSize, AccessControlContext acc) &#123;</div><div class="line">       if (name == null) &#123;</div><div class="line">           throw new NullPointerException(&quot;name cannot be null&quot;);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       this.name = name;</div><div class="line"></div><div class="line">       Thread parent = currentThread();</div><div class="line">       SecurityManager security = System.getSecurityManager();</div><div class="line">       //获取线程组</div><div class="line">       if (g == null) &#123;</div><div class="line"></div><div class="line">           /* 从SecurityManager拿线程组  */</div><div class="line">           if (security != null) &#123;</div><div class="line">               g = security.getThreadGroup();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           /* 如果还没拿到从当前线程拿*/</div><div class="line">           if (g == null) &#123;</div><div class="line">               g = parent.getThreadGroup();</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /* 检查是否可获取 */</div><div class="line">       g.checkAccess();</div><div class="line"></div><div class="line">       /*</div><div class="line">        * 还是权限控制检查</div><div class="line">        */</div><div class="line">       if (security != null) &#123;</div><div class="line">           if (isCCLOverridden(getClass())) &#123;</div><div class="line">               security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       g.addUnstarted();</div><div class="line"></div><div class="line">       this.group = g;</div><div class="line">       this.daemon = parent.isDaemon();</div><div class="line">       this.priority = parent.getPriority();</div><div class="line">       if (security == null || isCCLOverridden(parent.getClass()))</div><div class="line">           this.contextClassLoader = parent.getContextClassLoader();</div><div class="line">       else</div><div class="line">           this.contextClassLoader = parent.contextClassLoader;</div><div class="line">       this.inheritedAccessControlContext =</div><div class="line">               acc != null ? acc : AccessController.getContext();</div><div class="line">       this.target = target;</div><div class="line">       setPriority(priority);</div><div class="line">       //从父线程继承可继承的ThreadLocal</div><div class="line">       if (parent.inheritableThreadLocals != null)</div><div class="line">           this.inheritableThreadLocals =</div><div class="line">               ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</div><div class="line">     </div><div class="line">       this.stackSize = stackSize;</div><div class="line"></div><div class="line">       /* 设置线程ID */</div><div class="line">       tid = nextThreadID();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>不同的构造函数很多，最终都调init方法，init主要实现的就是把相应的参数放入成员变量里，线程ID为自增长方式；</p>
<h3 id="3、调用线程执行的主方法start与run方法"><a href="#3、调用线程执行的主方法start与run方法" class="headerlink" title="3、调用线程执行的主方法start与run方法"></a>3、调用线程执行的主方法start与run方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/* 线程启动方法 */</div><div class="line"> public synchronized void start() &#123;</div><div class="line">        /**</div><div class="line">         * 如果线程不是NEW状态，则抛异常</div><div class="line">         */</div><div class="line">        if (threadStatus != 0)</div><div class="line">            throw new IllegalThreadStateException();</div><div class="line"></div><div class="line">        /*</div><div class="line">        通知线程组此线程准备运行里，所以它可以加入到线程组列表中，线程组的未开始数量可以减少了 */</div><div class="line">        group.add(this);</div><div class="line"></div><div class="line">        boolean started = false;</div><div class="line">        try &#123;</div><div class="line">            start0();</div><div class="line">            started = true;</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (!started) &#123;</div><div class="line">                    group.threadStartFailed(this);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">                /*什么都不做，如果start0排除一个异常，它已经可以被调用栈知道 */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private native void start0();</div></pre></td></tr></table></figure>
<p>特别注意：start方法会创建一个新的线程，之后在执行run方法里的逻辑；而run方法只会在当前线程中执行逻辑；</p>
<h3 id="4、join方法-等待线程挂掉的方法"><a href="#4、join方法-等待线程挂掉的方法" class="headerlink" title="4、join方法, 等待线程挂掉的方法"></a>4、join方法, 等待线程挂掉的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/*如果这个线程还活着就一直等待*/</div><div class="line"> public final void join() throws InterruptedException &#123;</div><div class="line">        join(0);</div><div class="line">    &#125;</div><div class="line">/*如果这个线程还活着就一直等待millis时间*/</div><div class="line">public final synchronized void join(long millis)</div><div class="line">    throws InterruptedException &#123;</div><div class="line">        long base = System.currentTimeMillis();</div><div class="line">        long now = 0;</div><div class="line"></div><div class="line">        if (millis &lt; 0) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (millis == 0) &#123;</div><div class="line">            while (isAlive()) &#123;</div><div class="line">                wait(0);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            while (isAlive()) &#123;</div><div class="line">                long delay = millis - now;</div><div class="line">                if (delay &lt;= 0) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                wait(delay);</div><div class="line">                now = System.currentTimeMillis() - base;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过自旋方法检验线程是否活着，如果活着，则wait释放锁；</p>
<h3 id="5、sleep方法，native实现，会抛出InterruptedException"><a href="#5、sleep方法，native实现，会抛出InterruptedException" class="headerlink" title="5、sleep方法，native实现，会抛出InterruptedException"></a>5、sleep方法，native实现，会抛出InterruptedException</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* 睡眠指定毫秒，并不释放monitor*/</div><div class="line">public static native void sleep(long millis) throws InterruptedException;</div></pre></td></tr></table></figure>
<h3 id="6、yield方法"><a href="#6、yield方法" class="headerlink" title="6、yield方法"></a>6、yield方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/*使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了*/</div><div class="line">public static native void yield();</div></pre></td></tr></table></figure>
<h3 id="7、interrupted-方法与isInterrupted方法的区别？"><a href="#7、interrupted-方法与isInterrupted方法的区别？" class="headerlink" title="7、interrupted()方法与isInterrupted方法的区别？"></a>7、interrupted()方法与isInterrupted方法的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static boolean interrupted() &#123;</div><div class="line">    return currentThread().isInterrupted(true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean isInterrupted() &#123;</div><div class="line">    return isInterrupted(false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码上看，这两个方法都是调用<code>isInterrupted(boolean ClearInterrupted)</code>,只不过一个带的参数是true，另一个带的参数是false;</p>
<p>所以他们之间的区别是：</p>
<p>1、<code>interrupted</code>方法会清除中断标识符，<code>isInterrupted</code>方法不会清除中断标识符；</p>
<p>2、<code>interrupted</code>测试的是当前线程的中断状态，<code>isInterrupted</code>测试的是调用该方法对象所表示的线程。</p>
<p>3、<code>interrupted</code>为静态方法，Thread对象调用，<code>isInterrupted</code>为普通方法，Thread实例化对象调用</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、Thread内部有个State枚举，表示线程的状态&quot;&gt;&lt;a href=&quot;#1、Thread内部有个State枚举，表示线程的状态&quot; class=&quot;headerlink&quot; title=&quot;1、Thread内部有个State枚举，表示线程的状态&quot;&gt;&lt;/a&gt;1、Thr
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL索引原理</title>
    <link href="http://jianwl.com/2018/04/24/MYSQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
    <id>http://jianwl.com/2018/04/24/MYSQL索引原理/</id>
    <published>2018-04-24T09:51:23.000Z</published>
    <updated>2018-04-24T15:27:55.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-索引目的"><a href="#1-索引目的" class="headerlink" title="1. 索引目的"></a>1. 索引目的</h3><p>索引的目的在于提高查询效率，可以类比字典，如果要查<code>mysql</code>这个单词，我们肯定需要定位到m字母，然后从往下找到y字母，再找到剩下的sql。如果没有索引，那么你很可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p>
<h3 id="2-索引原理"><a href="#2-索引原理" class="headerlink" title="2. 索引原理"></a>2. 索引原理</h3><p>除了字典，生活中随处可见索引的例子，如火车站的车次表，图书的目录等，他们的原理都是一样的，通过不断的缩小想要获得的范围来筛选出最终想要的结果，同时把随机事件变成顺序的时间，也就是我们总是通过同一种查找方式来锁定数据。</p>
<p>数据库也是一样，但显然要复杂许多，因为不仅面临这等值查询、还有范围查询(<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>in</code>)、模糊查询(like)、并集查询(or)等。数据库应该选择怎么样的方式来应对所有问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段、201到300分成第三段…这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但是如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN,具有不错的查询性能。但这里我们忽略一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p>
<h3 id="3-磁盘IO和预读"><a href="#3-磁盘IO和预读" class="headerlink" title="3. 磁盘IO和预读"></a>3. 磁盘IO和预读</h3><p>前面提高了访问磁盘，那么这里先简单介绍一些磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分、寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们常说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是1秒转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错，但要知道一台500 - MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万数据，每次9毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图，供大家参考；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-24/44660032.jpg" alt=""></p>
<p>考虑到磁盘IO是非常高昂的操作计算机操作系统做了一些优化，当一次IO是，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<h3 id="4-索引的数据结构"><a href="#4-索引的数据结构" class="headerlink" title="4. 索引的数据结构"></a>4. 索引的数据结构</h3><p>前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有他的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足要求呢？就这样，b+树应运而生。</p>
<h3 id="5-详解B-树"><a href="#5-详解B-树" class="headerlink" title="5. 详解B+树"></a>5. 详解B+树</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-24/6850674.jpg" alt=""></p>
<p>如上图，是一颗B+树，这里只说一些重点，浅蓝色的块我们称之为磁盘块，可以看到每个磁盘块包含几个数据项(深蓝色所示)和指针(黄色所示)，如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示17和35之间的磁盘块，P3表示大于35的磁盘块，真实的数据存于<strong>叶子节点</strong>即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<h4 id="B-树的查找过程"><a href="#B-树的查找过程" class="headerlink" title="B+树的查找过程"></a>B+树的查找过程</h4><p>如图所示，如果要查找数据项是29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分法查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短(相比磁盘的IO)可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘块8加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的B+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总计共需要百万次IO，显然成本非常高。</p>
<h4 id="B-树性质"><a href="#B-树性质" class="headerlink" title="B+树性质"></a>B+树性质</h4><p>1、通过上面的分析，我们知道IO次数取决于B+数的高度H，假设当前数据表的数据为N，每个磁盘块的数据项的数据是m，则有h=log(m+1)N,当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段尽量要小，比如int占4字节，要比bigint8字节少一半，这也是为什么B+树要求吧真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时，会将退化成线性表。</p>
<p>2、 当B+树的数据项是符合的数据，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三，20，F)这样的数据来检索的时候，B+树会优先比较name来确定下一步的搜索方向，如果name相同再一次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，B+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才知道下一步去哪里查询。比如当(张三，F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后在匹配性别F的数据了，这个是非常重要的性质，即索引最左匹配特性。</p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>1、 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a、b、c、d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<p>2、 = 和 in 可以乱序，比如 a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>
<p>3、 尽量寻找区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录越少，唯一键的区分度是1，而一些状态，性别字段可能在大数据面前区分度就是0，一般需要join的字段我们要求是0.1以上，平均1条扫描10条记录</p>
<p>4、 索引项不能参与计算，保持干净列，比如 from_unixtime(create_time) = ‘2018-04-20’就不能使用索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(‘2018-04-20’)</p>
<p>5、 尽量的扩展索引，不要新建索引，比如表中已经有a的索引，现在要加(a,b)索引，那么只需要修改原来的索引即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-索引目的&quot;&gt;&lt;a href=&quot;#1-索引目的&quot; class=&quot;headerlink&quot; title=&quot;1. 索引目的&quot;&gt;&lt;/a&gt;1. 索引目的&lt;/h3&gt;&lt;p&gt;索引的目的在于提高查询效率，可以类比字典，如果要查&lt;code&gt;mysql&lt;/code&gt;这个单词，我们肯定
    
    </summary>
    
      <category term="MYSQL" scheme="http://jianwl.com/categories/MYSQL/"/>
    
    
      <category term="MYSQL" scheme="http://jianwl.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码学习</title>
    <link href="http://jianwl.com/2018/04/19/ThreadLocal%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/19/ThreadLocal源码学习/</id>
    <published>2018-04-18T22:44:09.000Z</published>
    <updated>2018-04-22T23:00:00.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段"><a href="#常用方法-amp-字段" class="headerlink" title="常用方法 &amp; 字段"></a>常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-19/34870755.jpg" alt=""></p>
<h3 id="1、使用ThreadLocal的好处"><a href="#1、使用ThreadLocal的好处" class="headerlink" title="1、使用ThreadLocal的好处"></a>1、使用ThreadLocal的好处</h3><p>可以实现多线程，变量间互不干扰；举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class ThreadLocalDemo &#123;</div><div class="line">    public static class MyTask implements Runnable&#123;</div><div class="line">        private ThreadLocal&lt;Double&gt; threadLocal = new ThreadLocal&lt;&gt;();</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            threadLocal.set(Math.random());</div><div class="line">            System.out.println(String.format(&quot;thread name : %s, threadlocal: %.2f&quot;,Thread.currentThread().getName(), threadLocal.get()));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MyTask task = new MyTask();</div><div class="line">        new Thread(task,&quot;测试线程1&quot;).start();</div><div class="line">        new Thread(task,&quot;测试线程2&quot;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">thread name : 测试线程2, threadlocal: 0.38</div><div class="line">thread name : 测试线程1, threadlocal: 0.85</div></pre></td></tr></table></figure>
<p>由结果可以看出，每个线程的变量是独立互不干扰的，如果把<code>ThreadLocal</code>换成Double等其他对象，每个线程的变量结果应该是一样的。</p>
<h3 id="2、提出问题"><a href="#2、提出问题" class="headerlink" title="2、提出问题"></a>2、提出问题</h3><ol>
<li>ThreadLocal为多线程共享变量，如何实现变量在多线程中互不干扰的？set()，get()</li>
<li>每个线程变量的存储方式，ThreadLocalMap</li>
<li>ThreadLocalMap是如何解决Hash冲突的；</li>
<li>ThreadLocal放置在Entry数组的索引位置，如何确定；</li>
<li>什么场景下会发生内存泄露，如何防止内存泄露；</li>
<li>为什么ThreadLocalMap是一个Entry数组的数据结构？明明一个threadlocal在一个线程中只能存入一个值；</li>
</ol>
<h4 id="1）如何实现变量在多线程中互不干扰的"><a href="#1）如何实现变量在多线程中互不干扰的" class="headerlink" title="1）如何实现变量在多线程中互不干扰的"></a>1）如何实现变量在多线程中互不干扰的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public void set(T value) &#123;</div><div class="line">    Thread t = Thread.currentThread(); // 获取当前线程</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value); </div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ThreadLocalMap getMap(Thread t) &#123;</div><div class="line">    return t.threadLocals;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public T get() &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">        if (e != null) &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            T result = (T)e.value;</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，每个线程中都有一个<code>ThreadLocalMap</code>数据结构，当执行set方法时，其值是保存在当前线程的<code>threadLocals</code>变量中，当执行get方法时，是从当前线程的<code>threadLocals</code>变量获取的，所以线程1中set的值，对线程2来说是拿不到的，而且在线程2中重新set的话，也不会影响到线程1中的值，保证了线程之间不会相互干扰；</p>
<p>那每个线程中的<code>ThreadLocalMap</code>究竟是什么？</p>
<h4 id="2）-每个线程变量的存储方式，ThreadLocalMap"><a href="#2）-每个线程变量的存储方式，ThreadLocalMap" class="headerlink" title="2） 每个线程变量的存储方式，ThreadLocalMap"></a>2） 每个线程变量的存储方式，ThreadLocalMap</h4><p>从名字上看，可以猜到它也是一个类似<code>HashMap</code>的数据结构，但是在ThreadLocal中，并没实现Map接口。</p>
<p>在ThreadLocalMap中，也是初始化一个大小16的Entry数组，Entry对象用来保存每一个key-value键值对，只不过这里的key永远都是ThreadLocal对象，通过ThreadLocal的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLocalMap中。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-23/56990974.jpg" alt=""></p>
<p>这里需要注意的是，ThreadLocalMap的Entry继承WeakReference和HashMap很大的区别是，Entry中没有next字段，所以就不存在链表的情况；</p>
<h4 id="3）Hash冲突"><a href="#3）Hash冲突" class="headerlink" title="3）Hash冲突"></a>3）Hash冲突</h4><p>没有链表结构，那发生Hash冲突了怎么办？</p>
<p>先看看ThreadLocalMap中插入一个key-value的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</div><div class="line">   Entry[] tab = table;</div><div class="line">   int len = tab.length;</div><div class="line">   int i = key.threadLocalHashCode &amp; (len-1);</div><div class="line"></div><div class="line">   for (Entry e = tab[i];</div><div class="line">         e != null;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">         ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">         if (k == key) &#123;</div><div class="line">             e.value = value;</div><div class="line">             return;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          if (k == null) &#123;</div><div class="line">              replaceStaleEntry(key, value, i);</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tab[i] = new Entry(key, value);</div><div class="line">    int sz = ++size;</div><div class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">          rehash();</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>每个ThreadLocal对象都有一个hash值<code>threadLocalHashCode</code>, <strong>每初始化一个ThreadLocal对象，hash值就增加一个固定的大小0x61c88647</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private final int threadLocalHashCode = nextHashCode();</div><div class="line"></div><div class="line">private static AtomicInteger nextHashCode =</div><div class="line">    new AtomicInteger();</div><div class="line">    </div><div class="line">private static final int HASH_INCREMENT = 0x61c88647;</div><div class="line"></div><div class="line">private static int nextHashCode() &#123;</div><div class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-ThreadLocal如何定位到Entry数组的索引位的"><a href="#4-ThreadLocal如何定位到Entry数组的索引位的" class="headerlink" title="4) ThreadLocal如何定位到Entry数组的索引位的"></a>4) ThreadLocal如何定位到Entry数组的索引位的</h4><p>在插入过程中，根据ThreadLocal对象的Hash值，定位到table中的位置i，过程如下：</p>
<p>1、如果当前位置是空的，那么正好，就初始化一个Entry对象放置位置i上，位置i通过threadlocal的hashcode与table的长度的取余得到；</p>
<p>2、不巧，位置i已经有Entry对象了，如果这个Entry对象的key正好是即将设置的key，那么重新设置Entry中的value；</p>
<p>3、很不巧，位置i的Entry对象和即将设置的key没有关系，那么只能找到下一个空位置；</p>
<p>这样的话，在get的时候，也会根据ThreadLocal对象的hash值，定位table中的位置，然后判断位置Entry中的key是否和get的key一致，如果不一致，就判断下一个位置。</p>
<p>可以发现，set和get如果冲突严重的话，效率很低，因为ThreadLocalMap是Thread的一个属性，所以即使在自己的代码中控制了设置的元素个数，但还是不能控制其代码的行为；</p>
<h4 id="5）内存泄露"><a href="#5）内存泄露" class="headerlink" title="5）内存泄露"></a>5）内存泄露</h4><p>ThreadLocal可能导致内存泄露，为什么？</p>
<p>先看看Entry的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;     Object value;</div><div class="line">     Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">         super(k);</div><div class="line">         value = v;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过之前的分析已经知道，当使用ThreadLocal保存一个value时，会在ThreadLocalMap中的数组插入一个Entry对象，按理说key-value都应该以强引用保存在Entry对象中，但在ThreadLocalMap的实现中，key被保存到了WeakReference对象中。</p>
<p>这就导致了一个问题，ThreadLocal在没有外部强引用是，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露；</p>
<h5 id="如何避免内存泄露"><a href="#如何避免内存泄露" class="headerlink" title="如何避免内存泄露"></a>如何避免内存泄露</h5><p>既然已经发现有内存泄露的隐患，自然有应对的策略，在调用ThreadLocal的get()、set()可能会清楚ThreadLocalMap中key为null的Entry对象，这样对应的value就没有GC Roots可达了，下次GC的时候就可以被回收，当然如果调用remove方法，肯定会删除对应的Entry对象；</p>
<p>如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test_002()&#123;</div><div class="line">    ThreadLocal&lt;String&gt; hello = new ThreadLocal&lt;&gt;();</div><div class="line">    try &#123;</div><div class="line">        hello.set(&quot;Hello World!&quot;);</div><div class="line">    &#125;finally &#123;</div><div class="line">        hello.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-为什么ThreadLocalMap是一个Entry数组的数据结构？"><a href="#6-为什么ThreadLocalMap是一个Entry数组的数据结构？" class="headerlink" title="6. 为什么ThreadLocalMap是一个Entry数组的数据结构？"></a>6. 为什么ThreadLocalMap是一个Entry数组的数据结构？</h4><p>我们知道，每个线程都有一个ThreadLocalMap；之前一直困扰为什么它的数据结构是Entry数组，而不是Entry对象呢？</p>
<p>因为同一个线程中，可以设置多个ThreadLocal，每个threadLocal都会存入到线程的ThreadLocalMap对象中，所以是Entry数组的数据结构；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor线程池源码学习</title>
    <link href="http://jianwl.com/2018/04/18/ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/18/ThreadPoolExecutor线程池源码学习/</id>
    <published>2018-04-18T00:24:37.000Z</published>
    <updated>2018-04-18T01:10:06.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-使用线程池的好处"><a href="#1-使用线程池的好处" class="headerlink" title="1. 使用线程池的好处"></a>1. 使用线程池的好处</h3><p>合理利用线程池能够带来三个好处。</p>
<p>① 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</p>
<p>② 提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
<p>③ 提高线程的可管理性。线程时稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h3 id="2-线程池的工作原理"><a href="#2-线程池的工作原理" class="headerlink" title="2. 线程池的工作原理"></a>2. 线程池的工作原理</h3><p>首先我们看下当一个新的任务提交到线程池之后，线程池是如何处理的；</p>
<p>① 线程池判断核心线程池里的线程是否都在执行任务；如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步；</p>
<p>② 线程池判断工作队列是否已经满。如果工作队列已经满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步；</p>
<p>③ 线程池判断线程池的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务</p>
<h4 id="线程池饱和策略"><a href="#线程池饱和策略" class="headerlink" title="线程池饱和策略"></a>线程池饱和策略</h4><p>这里提到了线程池的饱和策略，那我们就简单介绍下有哪些饱和策略</p>
<table>
<thead>
<tr>
<th style="text-align:center">策略类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AbortPolicy</td>
<td style="text-align:center">直接抛出异常，线程池默认处理策略；切记ThreadPoolExecutor.execute需要try catch，否则程序会直接退出</td>
</tr>
<tr>
<td style="text-align:center">DiscardPolicy</td>
<td style="text-align:center">不处理，丢弃掉</td>
</tr>
<tr>
<td style="text-align:center">DiscardOldestPolicy</td>
<td style="text-align:center">丢弃队里里最近一个任务，并执行当前任务</td>
</tr>
<tr>
<td style="text-align:center">CallerRusPolicy</td>
<td style="text-align:center">只用调用者所在线程来运行任务</td>
</tr>
<tr>
<td style="text-align:center">自定义策略</td>
<td style="text-align:center">可以根据引用场景需要来实现RejectedExecutionHandler接口自定义策略，如记录日志或持久化不能处理的任务</td>
</tr>
</tbody>
</table>
<h3 id="3-线程池工作流程图"><a href="#3-线程池工作流程图" class="headerlink" title="3. 线程池工作流程图"></a>3. 线程池工作流程图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-12/20324843.jpg" alt=""></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-12/82099386.jpg" alt=""></p>
<p>① 如果当前运行的线程小于corePoolSize,则创建新线程来执行任务（注意执行这一步需要获取全局锁）</p>
<p>② 如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue；</p>
<p>③ 如果BlockingQueue队列已满，则在非corePool中创建新的线程来处理任务（注意执行这一步需要获取全局锁）</p>
<p>④ 如果创建新线程将使当前运行的线程超出maximumPoolSize,任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</p>
<h3 id="4-线程池的使用"><a href="#4-线程池的使用" class="headerlink" title="4. 线程池的使用"></a>4. 线程池的使用</h3><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><p>我们可以通过ThreadPoolExecutor来创建一个线程池；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds, runnableTaskQueue,threadFactory, handler);</div></pre></td></tr></table></figure>
<p>创建一个线程池需要输入几个参数：</p>
<h5 id="1）corePoolSize（线程池的基本大小）"><a href="#1）corePoolSize（线程池的基本大小）" class="headerlink" title="1）corePoolSize（线程池的基本大小）"></a>1）corePoolSize（线程池的基本大小）</h5><p>当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程池</p>
<h5 id="2）runnableTaskQueue（任务队列）"><a href="#2）runnableTaskQueue（任务队列）" class="headerlink" title="2）runnableTaskQueue（任务队列）"></a>2）runnableTaskQueue（任务队列）</h5><p>用于保存等待执行的任务的阻塞队列，可以选择一下几个阻塞队列</p>
<p>① ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO(先进先出)原则对元素进行排序；</p>
<p>② LinkedBlockingQueue: 一个基于链表结构的阻塞队列，此队列按FIFO(先进先出)排序元素，吞吐量通常高于ArrayBlockingQueue，静态工厂方法Executors.newFixedThreadPool()使用这个队列</p>
<p>③ SyschronousQueue: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常高于LinkedBlockingQueue，静态工作方法 Executors.newCachedThreadPool使用这个队列；</p>
<p>④ PriorityBlockingQueue： 一个具有优先级的无限阻塞队列；</p>
<h5 id="3）maxmumPoolSize（线程池最大大小）"><a href="#3）maxmumPoolSize（线程池最大大小）" class="headerlink" title="3）maxmumPoolSize（线程池最大大小）"></a>3）maxmumPoolSize（线程池最大大小）</h5><p>线程池允许创建的最大线程数，如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的队列这个参数就没有效果了；</p>
<h5 id="4-ThreadFactory"><a href="#4-ThreadFactory" class="headerlink" title="4) ThreadFactory"></a>4) ThreadFactory</h5><p>用于设置创建线程工厂，可以通过线程工厂给创建出来的线程设置有语义的名字</p>
<h5 id="5）RejectedExecutionHandler（饱和策略）"><a href="#5）RejectedExecutionHandler（饱和策略）" class="headerlink" title="5）RejectedExecutionHandler（饱和策略）"></a>5）RejectedExecutionHandler（饱和策略）</h5><p>参考上述步骤2中的，饱和策略分析</p>
<h5 id="6）keepAliveTime（线程活动保持时间）"><a href="#6）keepAliveTime（线程活动保持时间）" class="headerlink" title="6）keepAliveTime（线程活动保持时间）"></a>6）keepAliveTime（线程活动保持时间）</h5><p>大于corePool(线程池基本大小)的空闲工作线程，保持存活的时间<strong>(在存活时间内，如果没有接受新任务，就会被销毁)</strong>。如果任务很多，每个任务执行的时间比较短，可以调整这个时间，提高线程的利用率；</p>
<h5 id="7）TimeUnit（线程活动保持时间的单位）"><a href="#7）TimeUnit（线程活动保持时间的单位）" class="headerlink" title="7）TimeUnit（线程活动保持时间的单位）"></a>7）TimeUnit（线程活动保持时间的单位）</h5><p>可选单位有天(DAYS)、小时(HOURS)、分钟(MINUTES)、毫秒(MILLISECONDS)、微秒(MICROSECONDS)</p>
<h3 id="5-源码分析"><a href="#5-源码分析" class="headerlink" title="5. 源码分析"></a>5. 源码分析</h3><h4 id="1）提问"><a href="#1）提问" class="headerlink" title="1）提问"></a>1）提问</h4><p>1、线程池新增任务的流程；execute(Runnable command)</p>
<p>2、线程池如何实现，在RUNING状态下，接受新任务，且处理队列里的任务；在SHUTDOWN状态下，不接受新任务，但处理新任务的 ;以及在STOP、TIDYING和TERMINATE状态下的处理方式；</p>
<p>3、线程池如何处理新增任务时，出现异常的；addWorkerFailed(Worker w)</p>
<p>4、线程池如何实现关闭的；</p>
<h5 id="1-1-execute-Runnable-command"><a href="#1-1-execute-Runnable-command" class="headerlink" title="1-1) execute(Runnable command)"></a>1-1) execute(Runnable command)</h5><p><code>execute</code>方法三个主要步骤：① 活动线程小于<code>corePoolSize</code>的时候创建新的线程；②活动线程大于<code>corePoolSize</code>先加入到任务队列当中；③ 任务队列满了再去启动新的线程，如果线程数达到最大值就拒绝任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void execute(Runnable command) &#123; </div><div class="line">    if (command == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">  </div><div class="line">    int c = ctl.get();</div><div class="line"></div><div class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        if (addWorker(command, true))</div><div class="line">            return;</div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        int recheck = ctl.get();</div><div class="line"></div><div class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line"></div><div class="line">        else if (workerCountOf(recheck) == 0)</div><div class="line">            addWorker(null, false);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    else if (!addWorker(command, false))</div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第 5 行：ctl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</div></pre></td></tr></table></figure>
<p><code>ThreadPoolExecutor</code>用这一变量保存了两个内容：① 所有有效线程数量「workerCount」② 线程池运行状态「runState」; 低29位存<code>workerCounter</code>，高3位存<code>runState</code>, 这样<code>runState</code>有5个值；</p>
<ul>
<li>RUNNING: -1 &lt;&lt; 29</li>
<li>SHOTDOWN: 0 &lt;&lt; 29</li>
<li>STOP: 1 &lt;&lt; 29</li>
<li>TIDYING: 2 &lt;&lt; 29</li>
<li>TERMINATED: 3 &lt;&lt; 29</li>
</ul>
<p>线程池各状态转换比较复杂，记住下面内容就可以了：</p>
<ul>
<li>RUNNING状态：线程池正常运行，可以接受新的任务并处理队列中的任务；</li>
<li>SHUTDOWN状态：不再接受新的任务，但是会执行队列中的任务；</li>
<li>STOP状态：不再接受新任务，不处理队列中的任务，中断正在进行中的任务；</li>
<li>TIDYING: 所有任务都已关闭，有效线程数为0，将运行<code>terminated()</code>钩子方法；</li>
<li>TERMINATED: <code>terminated()</code>方法执行完毕；</li>
</ul>
<p>第 7 行：当有效线程数 小于 核心线程数时；</p>
<p><code>workerCountOf(ctl.get())</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private static final int COUNT_BITS = 29;</div><div class="line"></div><div class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</div><div class="line"></div><div class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</div></pre></td></tr></table></figure>
<p>ctl的低29位存着有效线程数，通过 <code>c &amp; 00011111111111111111111111111</code>的方式得到<code>有效线程数</code></p>
<p>第 8 行：线程池有效线程数小于核心线程数时，新增任务成功，则退出；</p>
<p>源码中：<code>Worker类</code>、<code>addWorkerFailed()方法</code>在后文继续分析</p>
<p><code>addWorker(command,true)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</div><div class="line">    retry:</div><div class="line">    for (;;) &#123;</div><div class="line">        int c = ctl.get();</div><div class="line">        int rs = runStateOf(c); // 当前线程池状态</div><div class="line"></div><div class="line">        // 线程池状态为：SHUTDOWN STOP TIDYING TERMINATED 均不在接受新任务；</div><div class="line">        // 但是当状态为SHUTDOWN时，若此时队列不为空，为了保证队列中的任务能够被执行完；</div><div class="line">        // SHUTDOWN时通过addWoker(null,false)方法,新增有效线程数；「执行addWorker(null,false)，此时workerCounter == 0」</div><div class="line">        // 所以当线程池的状态为SHUTDOWN，firstTask == null，队列不为空时，将继续往下执行；</div><div class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">            ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">               firstTask == null &amp;&amp;</div><div class="line">               ! workQueue.isEmpty()))</div><div class="line">            return false;</div><div class="line"></div><div class="line">        for (;;) &#123;</div><div class="line">            int wc = workerCountOf(c); // 有效线程数</div><div class="line"></div><div class="line">            if (wc &gt;= CAPACITY ||</div><div class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                return false;</div><div class="line"></div><div class="line">            if (compareAndIncrementWorkerCount(c)) // 原子操作递增workerCount</div><div class="line">                break retry; // 操作成功跳出重试循环</div><div class="line">            c = ctl.get();  // Re-read ctl</div><div class="line">            if (runStateOf(c) != rs) // 如果线程池的状态发生变化则重试</div><div class="line">                continue retry;</div><div class="line">            // else CAS failed due to workerCount change; retry inner loop</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // workerCount递增成功</div><div class="line">    boolean workerStarted = false;</div><div class="line">    boolean workerAdded = false;</div><div class="line">    Worker w = null;</div><div class="line">    try &#123;</div><div class="line">        w = new Worker(firstTask);</div><div class="line">        final Thread t = w.thread;</div><div class="line">        if (t != null) &#123;</div><div class="line">            final ReentrantLock mainLock = this.mainLock;</div><div class="line">            // 并发的访问线程池workers对象必须加锁</div><div class="line">            mainLock.lock();</div><div class="line">            try &#123;</div><div class="line">                // Recheck while holding lock.</div><div class="line">                // Back out on ThreadFactory failure or if</div><div class="line">                // shut down before lock acquired.</div><div class="line">                int rs = runStateOf(ctl.get());</div><div class="line"></div><div class="line">                // RUNNING 状态 || SHUTDOWN状态下清理队列中剩余的任务</div><div class="line">                if (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</div><div class="line">                    if (t.isAlive()) // precheck that t is startable</div><div class="line">                        throw new IllegalThreadStateException();</div><div class="line">                    // 将线程放到线程列表中</div><div class="line">                    workers.add(w);</div><div class="line">                    int s = workers.size();</div><div class="line">                    if (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = true;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            // 启动新添加的线程，这个线程首先执行firstTask，然后不停的从队列中取任务执行；</div><div class="line">            if (workerAdded) &#123;</div><div class="line">                t.start(); // 最终执行的是ThreadPoolExecutor的runWorker方法</div><div class="line">                workerStarted = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        // 线程启动失败，则从workers中移除w并递减workerCount</div><div class="line">        if (! workerStarted)</div><div class="line">            // 递减workerCount会触发tryTerminate方法</div><div class="line">            addWorkerFailed(w);</div><div class="line">    &#125;</div><div class="line">    return workerStarted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第13 ~ 21行：</p>
<p><code>runState</code>为RUNNING状态且队列未满，双重检查，再次获取线程池ctl，判断当前线程池状态；若线程池为非RUNNING状态，则从workQueue中移除任务，并执行线程池拒绝任务策略；若当前有效线程数为0，则添加一个空任务到队列里；「理由是：当线程池状态为SHUTDOWN时，若队列不为空，有效线程数为0，需要通过添加空任务的方法，增加有效线程数」</p>
<p>第 23 ~ 25行：</p>
<p>① 线程池非RUNNING状态，拒绝新任务，执行拒绝策略 ② 队列满了且当且有效线程数大于最大线程数时，执行拒绝策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final void reject(Runnable command) &#123;</div><div class="line">    handler.rejectedExecution(command, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-2-Worker"><a href="#1-2-Worker" class="headerlink" title="1-2 Worker"></a>1-2 Worker</h5><p>任务添加成功后，实际执行的是runWorker(this)的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">private final class Worker</div><div class="line">    extends AbstractQueuedSynchronizer</div><div class="line">    implements Runnable</div><div class="line">&#123;</div><div class="line">    private static final long serialVersionUID = 6138294804551838833L;</div><div class="line"></div><div class="line">    final Thread thread;</div><div class="line"></div><div class="line">    Runnable firstTask;</div><div class="line"></div><div class="line">    volatile long completedTasks;</div><div class="line"></div><div class="line">    Worker(Runnable firstTask) &#123;</div><div class="line">        setState(-1); // inhibit interrupts until runWorker</div><div class="line">        this.firstTask = firstTask;</div><div class="line">        this.thread = getThreadFactory().newThread(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void run() &#123;</div><div class="line">        runWorker(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean isHeldExclusively() &#123;</div><div class="line">        return getState() != 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean tryAcquire(int unused) &#123;</div><div class="line">        if (compareAndSetState(0, 1)) &#123;</div><div class="line">            setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean tryRelease(int unused) &#123;</div><div class="line">        setExclusiveOwnerThread(null);</div><div class="line">        setState(0);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void lock()        &#123; acquire(1); &#125;</div><div class="line">    public boolean tryLock()  &#123; return tryAcquire(1); &#125;</div><div class="line">    public void unlock()      &#123; release(1); &#125;</div><div class="line">    public boolean isLocked() &#123; return isHeldExclusively(); &#125;</div><div class="line"></div><div class="line">    void interruptIfStarted() &#123;</div><div class="line">        Thread t;</div><div class="line">        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;</div><div class="line">            try &#123;</div><div class="line">                t.interrupt();</div><div class="line">            &#125; catch (SecurityException ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第 20 行：runWorker简单来说做了两件事：</p>
<p>① 第一次启动会执行传进来的任务firstTask;</p>
<p>② 如果firstTask为空，则从workQueue中取任务，如果队列为空则等待<code>keepAliveTime</code>这么长的时间；</p>
<p>runWorker的核心代码为第10行代码中的<code>getTask()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">final void runWorker(Worker w) &#123;</div><div class="line">        Thread wt = Thread.currentThread();</div><div class="line">        Runnable task = w.firstTask;</div><div class="line">        w.firstTask = null;</div><div class="line">        // 任务被锁住了，需要解锁才能被中断？「这个解释需要验证」</div><div class="line">        w.unlock(); // allow interrupts</div><div class="line">        boolean completedAbruptly = true;</div><div class="line">        try &#123;</div><div class="line">            // 先执行firstTask，若firstTask为空，则从队列里取任务执行；</div><div class="line">            while (task != null || (task = getTask()) != null) &#123;</div><div class="line">                w.lock();</div><div class="line">                if ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                     (Thread.interrupted() &amp;&amp;</div><div class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                    !wt.isInterrupted())</div><div class="line">                    wt.interrupt();</div><div class="line">                try &#123;</div><div class="line">                    // 任务执行前可以插入一些处理、子类重载该方法</div><div class="line">                    beforeExecute(wt, task);</div><div class="line">                    Throwable thrown = null;</div><div class="line">                    try &#123;</div><div class="line">                        task.run(); // 执行用户任务</div><div class="line">                    &#125; catch (RuntimeException x) &#123;</div><div class="line">                        thrown = x; throw x;</div><div class="line">                    &#125; catch (Error x) &#123;</div><div class="line">                        thrown = x; throw x;</div><div class="line">                    &#125; catch (Throwable x) &#123;</div><div class="line">                        thrown = x; throw new Error(x);</div><div class="line">                    &#125; finally &#123;</div><div class="line">                        // 和beforeExecute一样，留给子类去重载；</div><div class="line">                        afterExecute(task, thrown);</div><div class="line">                    &#125;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    task = null;</div><div class="line">                    w.completedTasks++;</div><div class="line">                    w.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            completedAbruptly = false;</div><div class="line">        &#125; finally &#123;</div><div class="line">            // 结束线程的一些清理工作</div><div class="line">            processWorkerExit(w, completedAbruptly);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="1-3-runWorker-中的getTask-方法"><a href="#1-3-runWorker-中的getTask-方法" class="headerlink" title="1-3 runWorker()中的getTask()方法"></a>1-3 runWorker()中的getTask()方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private Runnable getTask() &#123;</div><div class="line">    boolean timedOut = false; // Did the last poll() time out?</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line">        int c = ctl.get();</div><div class="line">        int rs = runStateOf(c);</div><div class="line"></div><div class="line">        // SHUTDOWN状态：队列不为空，不接受新任务，但有队列中的任务需要执行；</div><div class="line">        // Check if queue empty only if necessary.</div><div class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">            decrementWorkerCount();</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int wc = workerCountOf(c);</div><div class="line"></div><div class="line">        // Are workers subject to culling?</div><div class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">        // timed == false 不允许核心线程超时，即使核心线程处于闲置装填也不会被回收；</div><div class="line">        // timed == true 允许核心线程超时,只要核心线程处于闲置状态就会被回收;</div><div class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</div><div class="line">            if (compareAndDecrementWorkerCount(c))</div><div class="line">                return null;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            Runnable r = timed ?</div><div class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                workQueue.take();</div><div class="line">            if (r != null)</div><div class="line">                return r;</div><div class="line">            timedOut = true;</div><div class="line">        &#125; catch (InterruptedException retry) &#123;</div><div class="line">            timedOut = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-4-addWorkerFailed"><a href="#1-4-addWorkerFailed" class="headerlink" title="1-4 addWorkerFailed"></a>1-4 addWorkerFailed</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private void addWorkerFailed(Worker w) &#123;</div><div class="line">    final ReentrantLock mainLock = this.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    try &#123;</div><div class="line">        if (w != null)</div><div class="line">            workers.remove(w); // 移除任务</div><div class="line">        decrementWorkerCount(); // 递减workerCount</div><div class="line">        tryTerminate();</div><div class="line">    &#125; finally &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在addWorker时，出现异常时，需要做回滚操作，① 将任务从队列中移除； ② 将有效线程数减1 ③ 因为有效线程数发生变化了，所有需要尝试调用<code>tryTerminate</code>来终止线程池;</p>
<p><code>tryTerminate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">final void tryTerminate() &#123;</div><div class="line">    for (;;) &#123;</div><div class="line">        int c = ctl.get();</div><div class="line">        // 以下状态直接返回</div><div class="line">        // 1. 线程池还处于RUNNING状态</div><div class="line">        // 2. runState &gt;= TIDYING 线程池已经停止了或正在停止了</div><div class="line">        // 3. SHUTDOWN状态但队列非空</div><div class="line">        if (isRunning(c) ||</div><div class="line">            runStateAtLeast(c, TIDYING) ||</div><div class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</div><div class="line">            return;</div><div class="line"></div><div class="line">        // workerCount不为0，则还不能停止线程池，</div><div class="line">        if (workerCountOf(c) != 0) &#123; // Eligible to terminate</div><div class="line">            // ONLY_ONE: 只需中断1个线程去处理shutdown信号就可以了；</div><div class="line">            interruptIdleWorkers(ONLY_ONE);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final ReentrantLock mainLock = this.mainLock;</div><div class="line">        mainLock.lock();</div><div class="line">        try &#123;</div><div class="line">            // 进入TIDYING状态</div><div class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</div><div class="line">                try &#123;</div><div class="line">                    // 子类重载：一些资源清理工作</div><div class="line">                    terminated();</div><div class="line">                &#125; finally &#123;</div><div class="line">                    // TERMINATED状态</div><div class="line">                    ctl.set(ctlOf(TERMINATED, 0));</div><div class="line">                    // 进行awaitTermination</div><div class="line">                    termination.signalAll();</div><div class="line">                &#125;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line">        // else retry on failed CAS</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-5-关闭线程池shutdown"><a href="#1-5-关闭线程池shutdown" class="headerlink" title="1-5 关闭线程池shutdown"></a>1-5 关闭线程池shutdown</h5><p>shutdown这个方法会将<code>runState</code>置为SHUTDOWN，会终止所有空闲的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void shutdown() &#123;</div><div class="line">    final ReentrantLock mainLock = this.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    try &#123;</div><div class="line">        checkShutdownAccess();</div><div class="line">        // 线程池状态设为SHUTDOWN，如果已经至少是这个状态那么则直接返回</div><div class="line">        advanceRunState(SHUTDOWN);</div><div class="line">        // 注意这里是中断所有空闲的线程：runWorker中等待的线程被中断 → 进入processWorkerExit →</div><div class="line">        // tryTerminate方法中会保证队列中剩余的任务得到执行。</div><div class="line">        interruptIdleWorkers();</div><div class="line">        onShutdown(); // hook for ScheduledThreadPoolExecutor</div><div class="line">    &#125; finally &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">    tryTerminate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-使用线程池的好处&quot;&gt;&lt;a href=&quot;#1-使用线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;1. 使用线程池的好处&quot;&gt;&lt;/a&gt;1. 使用线程池的好处&lt;/h3&gt;&lt;p&gt;合理利用线程池能够带来三个好处。&lt;/p&gt;
&lt;p&gt;① 降低资源消耗。通过重
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>StringBuilder源码学习</title>
    <link href="http://jianwl.com/2018/04/02/StringBuilder%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/02/StringBuilder源码学习/</id>
    <published>2018-04-02T14:06:55.000Z</published>
    <updated>2018-04-04T00:39:36.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段"><a href="#常用方法-amp-字段" class="headerlink" title="常用方法 &amp; 字段"></a>常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-3/88149991.jpg" alt=""></p>
<p>StringBuilder常用于单线程字符串的拼接，可以减小堆内存的开销；</p>
<p>StringBuilder继承<code>AbstractStringBuilder</code>抽象类，且实现了<code>CharSequence</code>、<code>Serializable</code>接口</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>通过append方法拼接字符串，为什么能够减少内存的开销呢，append();</li>
<li>StringBuffer和StringBuilder有什么区别？</li>
</ol>
<h4 id="1-如何拼接字符串"><a href="#1-如何拼接字符串" class="headerlink" title="1) 如何拼接字符串"></a>1) 如何拼接字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">    @Override</div><div class="line">    public StringBuilder append(String str) &#123;</div><div class="line">        super.append(str);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// AbstractStringBuilder类   </div><div class="line">    public AbstractStringBuilder append(String str) &#123;</div><div class="line">        if (str == null)</div><div class="line">            return appendNull();</div><div class="line">        int len = str.length();</div><div class="line">        ensureCapacityInternal(count + len);</div><div class="line">        str.getChars(0, len, value, count);</div><div class="line">        count += len;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private AbstractStringBuilder appendNull() &#123;</div><div class="line">        int c = count;</div><div class="line">        ensureCapacityInternal(c + 4);</div><div class="line">        final char[] value = this.value;</div><div class="line">        value[c++] = &apos;n&apos;;</div><div class="line">        value[c++] = &apos;u&apos;;</div><div class="line">        value[c++] = &apos;l&apos;;</div><div class="line">        value[c++] = &apos;l&apos;;</div><div class="line">        count = c;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line">      </div><div class="line">    private void ensureCapacityInternal(int minimumCapacity) &#123;</div><div class="line">        // overflow-conscious code</div><div class="line">        if (minimumCapacity - value.length &gt; 0)</div><div class="line">            expandCapacity(minimumCapacity);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void expandCapacity(int minimumCapacity) &#123;</div><div class="line">        int newCapacity = value.length * 2 + 2;</div><div class="line">        if (newCapacity - minimumCapacity &lt; 0)</div><div class="line">            newCapacity = minimumCapacity;</div><div class="line">        if (newCapacity &lt; 0) &#123;</div><div class="line">            if (minimumCapacity &lt; 0) // overflow</div><div class="line">                throw new OutOfMemoryError();</div><div class="line">            newCapacity = Integer.MAX_VALUE;</div><div class="line">        &#125;</div><div class="line">        value = Arrays.copyOf(value, newCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// Arrays类</div><div class="line">    public static char[] copyOf(char[] original, int newLength) &#123;</div><div class="line">        char[] copy = new char[newLength];</div><div class="line">        System.arraycopy(original, 0, copy, 0,</div><div class="line">                         Math.min(original.length, newLength));</div><div class="line">        return copy;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">// String类</div><div class="line">    public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123;</div><div class="line">        if (srcBegin &lt; 0) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcBegin);</div><div class="line">        &#125;</div><div class="line">        if (srcEnd &gt; value.length) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd);</div><div class="line">        &#125;</div><div class="line">        if (srcBegin &gt; srcEnd) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</div><div class="line">        &#125;</div><div class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="1、拼接元素为null"><a href="#1、拼接元素为null" class="headerlink" title="1、拼接元素为null"></a>1、拼接元素为null</h5><p>第 9 ~ 10 行：如果拼接字符串为<code>null值</code>，则拼接<code>null</code>字符串；</p>
<p>第 20 行：确保当前字符数组数量加4，小于字符数组长度，否则扩容；</p>
<p>第 36 ~ 45行: 执行扩容；新容量为当前字符数组长度的2倍 + 2；如果新容量仍然小于，实际字符数量，则新容量等于实际字符数量；如果新容量溢出，则新容量赋值为Integer.MAX_VALUE;将原字符数组，赋值到扩容后的数组中；</p>
<p>第 49 ~ 53行：新建容量为扩容后的长度的字符数组，将原数组元素赋值到新数组中;</p>
<h5 id="2-新增元素不为null"><a href="#2-新增元素不为null" class="headerlink" title="2 新增元素不为null"></a>2 新增元素不为null</h5><p>第 11 ~12行: 获取新增字符串的长度，确保当前字符数量 + 新增字符串长度，在字符数组容量范围内，否则执行扩容；</p>
<p>第 13行: 将新增字符串转为字符数组，将其赋值到当前字符数组中实际元素的尾部，具体如图所示；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-4/53045816.jpg" alt=""></p>
<h5 id="3-为什么可以减少堆内存的开销？"><a href="#3-为什么可以减少堆内存的开销？" class="headerlink" title="3 为什么可以减少堆内存的开销？"></a>3 为什么可以减少堆内存的开销？</h5><p>因为字符串是不可变类，每次通过new的方式创建一个不同的字符串，都会在堆内存开辟一个空间；而通过StringBuilder的append方式拼接字符串，只会开辟一个字符数组内存空间，拼接的字符串将添加到字符数组中；从而减少了堆内存的开销；</p>
<h4 id="2）StringBuffer和StringBuilder有什么区别"><a href="#2）StringBuffer和StringBuilder有什么区别" class="headerlink" title="2）StringBuffer和StringBuilder有什么区别"></a>2）StringBuffer和StringBuilder有什么区别</h4><p>StringBuffer是线程安全的，在拼接元素方法中添加了同步锁；其他实现方式与StringBuilder一致；这里就不再赘述了；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">    @Override</div><div class="line">    public synchronized StringBuffer append(String str) &#123;</div><div class="line">        toStringCache = null;</div><div class="line">        super.append(str);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">// AbstractStringBuilder类</div><div class="line">    public AbstractStringBuilder append(String str) &#123;</div><div class="line">        if (str == null)</div><div class="line">            return appendNull();</div><div class="line">        int len = str.length();</div><div class="line">        ensureCapacityInternal(count + len);</div><div class="line">        str.getChars(0, len, value, count);</div><div class="line">        count += len;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void ensureCapacityInternal(int minimumCapacity) &#123;</div><div class="line">        // overflow-conscious code</div><div class="line">        if (minimumCapacity - value.length &gt; 0)</div><div class="line">            expandCapacity(minimumCapacity);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void expandCapacity(int minimumCapacity) &#123;</div><div class="line">        int newCapacity = value.length * 2 + 2;</div><div class="line">        if (newCapacity - minimumCapacity &lt; 0)</div><div class="line">            newCapacity = minimumCapacity;</div><div class="line">        if (newCapacity &lt; 0) &#123;</div><div class="line">            if (minimumCapacity &lt; 0) // overflow</div><div class="line">                throw new OutOfMemoryError();</div><div class="line">            newCapacity = Integer.MAX_VALUE;</div><div class="line">        &#125;</div><div class="line">        value = Arrays.copyOf(value, newCapacity);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line"> // String类</div><div class="line">     public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123;</div><div class="line">        if (srcBegin &lt; 0) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcBegin);</div><div class="line">        &#125;</div><div class="line">        if (srcEnd &gt; value.length) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd);</div><div class="line">        &#125;</div><div class="line">        if (srcBegin &gt; srcEnd) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</div><div class="line">        &#125;</div><div class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>String源码学习</title>
    <link href="http://jianwl.com/2018/04/01/String%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/01/String源码学习/</id>
    <published>2018-04-01T04:32:28.000Z</published>
    <updated>2018-04-01T05:59:09.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>从一段代码说起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void stringTest()&#123;</div><div class="line">    String str1 = &quot;a&quot; + &quot;b&quot; + 1;</div><div class="line">    String str2 = &quot;ab1&quot;;</div><div class="line">    System.out.println(str1 == str2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大家猜猜结果如何？如果你的结论是<code>true</code>，再来一段代码；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void stringTest2()&#123;</div><div class="line">    String str1 = new String(&quot;ab1&quot;);</div><div class="line">    String str2 = &quot;ab1&quot;;</div><div class="line">    System.out.println(str1 == str2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如何呢？正确答案是false。</p>
<p>让我们看看经过编译器编译后的代码如何：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 第一段代码</div><div class="line">    public static void stringTest()&#123;</div><div class="line">        String str1 = &quot;ab1&quot;;</div><div class="line">        String str2 = &quot;ab1&quot;;</div><div class="line">        System.out.println(str1 == str2);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">// 第二段代码  </div><div class="line">    public static void stringTest2()&#123;</div><div class="line">        String str1 = new String(&quot;ab1&quot;);</div><div class="line">        String str2 = &quot;ab1&quot;;</div><div class="line">        System.out.println(str1 == str2);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>也就是说第一段代码经过了编译器优化，原因是编译器发现”a”+”b”+1和”ab1”的效果一样，都是不可变量组成，但是为什么他们的内存地址会相同呢？如果你对此还有兴趣，那就一起来看看String类源码；</p>
<h3 id="1-String类"><a href="#1-String类" class="headerlink" title="1 String类"></a>1 String类</h3><p>String类被<code>final</code>所修饰，也就是说String对象是不可变类。String类实现了<code>Serializable</code>、<code>Comparable&lt;String&gt;</code>、<code>CharSequence</code>接口。</p>
<p>Comparable接口有compareTo(String s)方法，CharSequence接口有lengh()、chatAt(int index)、subSequence(int start,int end)方法。</p>
<h3 id="2-String属性"><a href="#2-String属性" class="headerlink" title="2 String属性"></a>2 String属性</h3><p>String类中包含一个不可变的char数组来存放字符串，一个int型的变量hash用来存放计算后的哈希值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/** The value is used for character storage. */</div><div class="line">private final char value[];</div><div class="line"></div><div class="line">/** Cache the hash code for the string */</div><div class="line">private int hash; // Default to 0</div></pre></td></tr></table></figure>
<h3 id="3-String构造函数"><a href="#3-String构造函数" class="headerlink" title="3 String构造函数"></a>3 String构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//不含参数的构造函数，一般没什么用，因为value是不可变量</div><div class="line">    public String() &#123;</div><div class="line">        this.value = &quot;&quot;.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> </div><div class="line">//参数为String类型</div><div class="line">    public String(String original) &#123;</div><div class="line">        this.value = original.value;</div><div class="line">        this.hash = original.hash;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// 声明编码类型    </div><div class="line">    public String(byte bytes[], Charset charset) &#123;</div><div class="line">        this(bytes, 0, bytes.length, charset);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">//参数为char数组，使用java.utils包中的Arrays类复制</div><div class="line">    public String(char value[]) &#123;</div><div class="line">        this.value = Arrays.copyOf(value, value.length);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">//从bytes数组中的offset位置开始，将长度为length的字节，以charsetName格式编码，拷贝到value</div><div class="line">    public String(byte bytes[], int offset, int length, Charset charset) &#123;</div><div class="line">        if (charset == null)</div><div class="line">            throw new NullPointerException(&quot;charset&quot;);</div><div class="line">        checkBounds(bytes, offset, length);</div><div class="line">        this.value =  StringCoding.decode(charset, bytes, offset, length);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="4-String-常用方法"><a href="#4-String-常用方法" class="headerlink" title="4 String 常用方法"></a>4 String 常用方法</h3><h4 id="1-equals"><a href="#1-equals" class="headerlink" title="1) equals()"></a>1) equals()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object anObject) &#123;</div><div class="line">    // 如果引用的是同一个对象，则为真</div><div class="line">    if (this == anObject) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (anObject instanceof String) &#123;</div><div class="line">        String anotherString = (String)anObject;</div><div class="line">        int n = value.length;</div><div class="line">        if (n == anotherString.value.length) &#123;</div><div class="line">            char v1[] = value;</div><div class="line">            char v2[] = anotherString.value;</div><div class="line">            int i = 0;</div><div class="line">            // 比较每一个字符是否相等</div><div class="line">            while (n-- != 0) &#123;</div><div class="line">                if (v1[i] != v2[i])</div><div class="line">                    return false;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>equals方法经常用得到，它用来判断两个对象内容是否相等，String对象判断流程：</p>
<blockquote>
<p>内存地址相同，则为真</p>
<p>如果对象类型不是String类型，则为假；否则继续判断</p>
<p>如果对象长度不相等，则为假，否则继续判断。</p>
<p>从后往前，判断String类中的char数组value的单个字符是否相等，有不相等则为假，如果一直相等直到一个数，则返回真。</p>
<p>由此可以看出，如果对两个超长的字符进行比较还是比较费时间的。</p>
</blockquote>
<h4 id="2-compareTo"><a href="#2-compareTo" class="headerlink" title="2) compareTo"></a>2) compareTo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public int compareTo(String anotherString) &#123;</div><div class="line">    // 自身字符串的长度</div><div class="line">    int len1 = value.length;</div><div class="line"></div><div class="line">    // 比较字符串的长度</div><div class="line">    int len2 = anotherString.value.length;</div><div class="line"></div><div class="line">    // 获取两个字符串的最小长度</div><div class="line">    int lim = Math.min(len1, len2);</div><div class="line">    char v1[] = value;</div><div class="line">    char v2[] = anotherString.value;</div><div class="line"></div><div class="line">    // 从头往后遍历，如果相同位置的字符不相等，则进行比较字符大小；</div><div class="line">    int k = 0;</div><div class="line">    while (k &lt; lim) &#123;</div><div class="line">        char c1 = v1[k];</div><div class="line">        char c2 = v2[k];</div><div class="line">        if (c1 != c2) &#123;</div><div class="line">            return c1 - c2;</div><div class="line">        &#125;</div><div class="line">        k++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 如果前面都相等，就等于当前字符长度 减去 比较字符长度</div><div class="line">    return len1 - len2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法写的很巧妙，先从0开始判断字符大小，如果两个对象能比较字符的地方比较完了还相等，就直接返回自身长度减比较对象长度，如果两个字符串长度相同，则返回0，巧妙地判断了三种情况。</p>
<h4 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3) hashCode()"></a>3) hashCode()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public int hashCode() &#123;</div><div class="line">    int h = hash;</div><div class="line">    if (h == 0 &amp;&amp; value.length &gt; 0) &#123;</div><div class="line">        char val[] = value;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</div><div class="line">            h = 31 * h + val[i];</div><div class="line">        &#125;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div><div class="line">    return h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>String类重写了hashCode方法，Object中的hashCode方法是一个Native调动。String类的hash采用多项式计算。不同的字符串，hashcode是有可能相同的。</p>
<h4 id="4-intern"><a href="#4-intern" class="headerlink" title="4) intern()"></a>4) intern()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public native String intern();</div></pre></td></tr></table></figure>
<p>intern方法是Native调用，它的作用是在方法区中的常量池里通过equals方法寻找字面值相等的对象，如果没有找到则在常量池中开辟一片空间存放字符串并返回字符串引用，否则直接返回常量池中已存在String对象的引用。</p>
<p>将引言中第二段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// String a = new String(&quot;ab1&quot;);</div><div class="line">// 改为</div><div class="line">String a = new String(&quot;ab1&quot;).intern();</div></pre></td></tr></table></figure>
<p>则结果为<code>true</code>，原因在于a所指向的地址来源于常量池，而b所指向的字符串默认会调用这个方法，所以a和b都指向同一个地址。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;从一段代码说起&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hashtable源码学习</title>
    <link href="http://jianwl.com/2018/03/29/Hashtable%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/29/Hashtable源码学习/</id>
    <published>2018-03-28T22:55:24.000Z</published>
    <updated>2018-03-29T23:37:47.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段"><a href="#常用方法-amp-字段" class="headerlink" title="常用方法 &amp; 字段"></a>常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-30/94194717.jpg" alt=""></p>
<p>Hashtable底层是一个数组 + 链表的数据结构，与HashMap的区别在于，其是线程安全、插入的键值对均不能为空、插入元素时，若发生哈希碰撞，Hashtable是从头结点插入，而HashMap1.8版本是从尾部插入；</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><ol>
<li>新增元素时，如何保证线程安全, put()</li>
<li>扩容与数据迁移机制，rehash()</li>
</ol>
<h4 id="1-新增元素时，如何保证线程安全"><a href="#1-新增元素时，如何保证线程安全" class="headerlink" title="1) 新增元素时，如何保证线程安全"></a>1) 新增元素时，如何保证线程安全</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public synchronized V put(K key, V value) &#123;</div><div class="line">    // Make sure the value is not null</div><div class="line">    if (value == null) &#123;</div><div class="line">        throw new NullPointerException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Makes sure the key is not already in the hashtable.</div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    int hash = key.hashCode();</div><div class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</div><div class="line">    for(; entry != null ; entry = entry.next) &#123;</div><div class="line">        if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</div><div class="line">            V old = entry.value;</div><div class="line">            entry.value = value;</div><div class="line">            return old;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addEntry(hash, key, value, index);</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void addEntry(int hash, K key, V value, int index) &#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    if (count &gt;= threshold) &#123;</div><div class="line">        // Rehash the table if the threshold is exceeded</div><div class="line">        rehash();</div><div class="line"></div><div class="line">        tab = table;</div><div class="line">        hash = key.hashCode();</div><div class="line">        index = (hash &amp; 0x7FFFFFFF) % tab.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Creates the new entry.</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</div><div class="line">    tab[index] = new Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    count++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第1行：<code>synchronized</code>关键字用于普通方法时，获取到对象实例的锁才能执行，所以在多线程环境下是线程安全的；</p>
<p>第3 ~ 9行：保证插入的键值对，key和value均不为空，否则抛出空指针异常；</p>
<p>第10行：获取插入元素，在数组中的索引位置；</p>
<p>第11 ~ 19行：获取索引位置的元素(元素为链表头结点)，遍历链表，若新增元素的key，在链表中已存在，则替换键值；</p>
<p>第28 ~ 36行: 如果当前的容量(count) 大于 扩容阈值(threshold),则进行扩容（rehash），得到插入元素在扩容后数组的索引位置；</p>
<p>第39 ~ 42行：获取索引位置的元素(链表头结点)，在头结点之前插入元素，容量 + 1；</p>
<h4 id="2-扩容与数据迁移机制"><a href="#2-扩容与数据迁移机制" class="headerlink" title="2) 扩容与数据迁移机制"></a>2) 扩容与数据迁移机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"> @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line"> protected void rehash() &#123;</div><div class="line"> 	  // ① 当前数组容量</div><div class="line">     int oldCapacity = table.length;</div><div class="line">     Entry&lt;?,?&gt;[] oldMap = table;</div><div class="line"></div><div class="line">     // overflow-conscious code ② 数组扩容为原数组的2倍 + 1</div><div class="line">     int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</div><div class="line">     // ③ 判断新容量是否溢出</div><div class="line">     if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; </div><div class="line">         if (oldCapacity == MAX_ARRAY_SIZE)</div><div class="line">             // Keep running with MAX_ARRAY_SIZE buckets</div><div class="line">             return;</div><div class="line">         newCapacity = MAX_ARRAY_SIZE;</div><div class="line">     &#125;</div><div class="line">     Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];</div><div class="line"></div><div class="line">     modCount++;</div><div class="line">     // ④ 计算出新的扩容阈值</div><div class="line">     threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</div><div class="line">     table = newMap;</div><div class="line">// ⑤ 遍历数组，将数据迁移到新数组中</div><div class="line">     for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;</div><div class="line">         for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123;</div><div class="line">             Entry&lt;K,V&gt; e = old;</div><div class="line">             old = old.next;</div><div class="line"></div><div class="line">             int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</div><div class="line">             e.next = (Entry&lt;K,V&gt;)newMap[index];</div><div class="line">             newMap[index] = e;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>第23 ~ 31行：从后往前遍历数组，得到链表首结点；若首结点不为空，继续遍历链表，将链表中的元素迁移到新容器，发生哈希碰撞时，采用从头结点插入的方式；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HashSet源码学习</title>
    <link href="http://jianwl.com/2018/03/27/HashSet%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/27/HashSet源码学习/</id>
    <published>2018-03-27T00:52:55.000Z</published>
    <updated>2018-03-28T22:51:10.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-29/4636358.jpg" alt=""></p>
<p>HashSet是以HashMap为基础类封装的对象，在新增元素E时，往HashMap中插入(E,Object)的键值对，因为在HashMap中Key是不存在重复的，所以保证了HashSet的唯一性。</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><ol>
<li>如何保证唯一性；</li>
</ol>
<h4 id="如何保证唯一性"><a href="#如何保证唯一性" class="headerlink" title="如何保证唯一性"></a>如何保证唯一性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public HashSet() &#123;</div><div class="line">    map = new HashMap&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean add(E e) &#123;</div><div class="line">    return map.put(e, PRESENT)==null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化HashSet时，会初始化HashMap对象；新增元素时，通过HashMap新增(E,Object)的键值对，从而保证了Key的唯一性；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法&quot;&gt;&lt;a href=&quot;#常用方法&quot; class=&quot;headerlink&quot; title=&quot;常用方法&quot;&gt;&lt;/a&gt;常用方法&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.clouddn.com/18-3-29/4636358.jpg
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码学习</title>
    <link href="http://jianwl.com/2018/03/22/HashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/22/HashMap源码学习/</id>
    <published>2018-03-22T12:39:33.000Z</published>
    <updated>2018-03-27T00:45:45.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-常用方法-amp-字段"><a href="#1-常用方法-amp-字段" class="headerlink" title="1. 常用方法 &amp; 字段"></a>1. 常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-22/24207782.jpg" alt=""></p>
<p>JDK1.8之前，HashMap是一个数组 + 链表的数据结构；通过key的hash值与数组的长度取余，得到该键值对在数组中的索引位。如果该位置上，没有其他元素，就直接放进去；如果该位置上已经有数据了(不同的key值，hash值可能一样)，则通过链表的方式，将元素放到前一个元素的后面。如下图所示：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-22/22584621.jpg" alt="图1-1"></p>
<p>JDK1.8，引入了红黑树，当链表的长度大于等于8时，会将链表转化为红黑树，红黑树的查找时间复杂度是o(lgn)，极大加快了查询的效率。</p>
<h3 id="2-提问"><a href="#2-提问" class="headerlink" title="2. 提问"></a>2. 提问</h3><ol>
<li>HashMap是如何实现扩容的，resize();</li>
<li>为什么HashMap的容量要保持为2的幂次方;</li>
<li>HashMap如何实现新增一个键值对,put(K,V);</li>
<li>HashMap为什么是线程不安全的？</li>
</ol>
<h4 id="1）HashMap是如何实现扩容的"><a href="#1）HashMap是如何实现扩容的" class="headerlink" title="1）HashMap是如何实现扩容的"></a>1）HashMap是如何实现扩容的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</div><div class="line">    int oldThr = threshold;</div><div class="line">    int newCap, newThr = 0;</div><div class="line">    if (oldCap &gt; 0) &#123;</div><div class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 超过最大值不再扩容，随它碰撞去了;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            return oldTab;</div><div class="line">        &#125;</div><div class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 如果当前容量大于16，且扩容2倍之后小于最大整数，则将阈值扩大2倍；</div><div class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</div><div class="line">    &#125;</div><div class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold 如果当前阈值大于0，则新的容量为当前阈值；</div><div class="line">        newCap = oldThr;</div><div class="line">    else &#123;               // zero initial threshold signifies using defaults</div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    if (newThr == 0) &#123;</div><div class="line">        float ft = (float)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</div><div class="line">                  (int)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    if (oldTab != null) &#123;</div><div class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            if ((e = oldTab[j]) != null) &#123;</div><div class="line">                oldTab[j] = null;</div><div class="line">                if (e.next == null)</div><div class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</div><div class="line">                else if (e instanceof TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</div><div class="line">                else &#123; // preserve order</div><div class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</div><div class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        if ((e.hash &amp; oldCap) == 0) &#123; // 原索引</div><div class="line">                            if (loTail == null)</div><div class="line">                                loHead = e;</div><div class="line">                            else</div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        else &#123; // 原索引 + oldCap</div><div class="line">                            if (hiTail == null)</div><div class="line">                                hiHead = e;</div><div class="line">                            else</div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; while ((e = next) != null);</div><div class="line">                    if (loTail != null) &#123;</div><div class="line">                        loTail.next = null;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    if (hiTail != null) &#123;</div><div class="line">                        hiTail.next = null;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第2 ~ 25行：这十几行代码描述的是扩容时，如何确定新的容量和阈值；</p>
<table>
<thead>
<tr>
<th style="text-align:center">当前容量oldCap</th>
<th style="text-align:center">扩容后容量newCap</th>
<th style="text-align:center">扩容后阈值newThre</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">oldCap <code>&gt;=</code> Integer.MAX_VALUE</td>
<td style="text-align:center">oldCap</td>
<td style="text-align:center">Integer.MAX_VALUE</td>
</tr>
<tr>
<td style="text-align:center">16 <code>&lt;</code> oldCap <code>&lt;</code> Integer.MAX_VALUE / 2</td>
<td style="text-align:center">oldCap <code>*</code> 2</td>
<td style="text-align:center">oldThre <code>*</code> 2</td>
</tr>
<tr>
<td style="text-align:center">0 <code>&lt;</code> oldCap <code>&lt;=</code>16</td>
<td style="text-align:center">oldThre</td>
<td style="text-align:center">newCap <code>*</code> 0.75</td>
</tr>
<tr>
<td style="text-align:center">oldCap == 0</td>
<td style="text-align:center">16</td>
<td style="text-align:center">16 <code>*</code> 0.75 = 12</td>
</tr>
</tbody>
</table>
<p>扩容时有4种场景，① 当前容量大于最大整数时，此时不再扩容，随他进行碰撞；② 当前容量大于16且扩容后的容量小于最大整数时，新的容量和阈值都扩大2倍；③ 当容量小于等于16时，这种场景出现在：指定HashMap的初始容量，此时新容量等于当前阈值，新阈值等于新容量 <code>*</code> 加载因子。④ 当前容量为0时，默认初始化容量为16，阈值为12；</p>
<p>第28 ~ 72行：扩容之后，需要将原有的数据迁移到扩容后的结构中；分为三种场景：① 同一个哈希槽位上，只有一个元素；② 同一个哈希槽位上，不止一个元素但小于8个元素(这几个元素，已链表的结构存在)；③ 同一个哈希槽位上，超过8个元素，(此时为这些元素，已红黑树的结构存在)；这里我们重点分析前两种情况，对于红黑树，等后续研究透了，再来分析；</p>
<p>场景①分析：</p>
<p>对应代码为35 ~ 36行：很简单，如果当前哈希槽位只有一个元素，那么将当前元素的哈希值 取余 新数组容量，获取新数组中的索引位置即可；<code>e.hash &amp; (newcap - 1)</code> 等价于 <code>e.hash % newcap</code></p>
<p>场景②分析：</p>
<p>对应代码为39 ~ 68行：同一个哈希槽位上存在多个元素(小于8)，这些元素可分为两种情况：1、 元素的哈希值 &amp; oldCap == 0，其索引位置为原索引；2、元素的哈希值 &amp; oldCap != 0,其索引位置为原索引 + oldCap；举个例子说明下：oldCap = 8, newCap = 16;那么哈希值为15时，其在新数组中的位置为：7 + 8 = 15；哈希值为7时，在新数组中的位置为7跟原来的位置一样。</p>
<h4 id="2-HashMap的容量如何做到保持为2的幂次方"><a href="#2-HashMap的容量如何做到保持为2的幂次方" class="headerlink" title="2) HashMap的容量如何做到保持为2的幂次方"></a>2) HashMap的容量如何做到保持为2的幂次方</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</div><div class="line">    if (initialCapacity &lt; 0)</div><div class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</div><div class="line">                                           initialCapacity);</div><div class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</div><div class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</div><div class="line">                                           loadFactor);</div><div class="line">    this.loadFactor = loadFactor;</div><div class="line">    this.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 返回大于等于当前值，最接近2的n次方的数据；</div><div class="line"> * Returns a power of two size for the given target capacity.</div><div class="line"> */</div><div class="line">static final int tableSizeFor(int cap) &#123;</div><div class="line">    int n = cap - 1; // 为了避免刚好是2的n次方的情况，这样会返回 2 的n+1次方，跟预期不符合；</div><div class="line">    n |= n &gt;&gt;&gt; 1; // 前2位都是1；</div><div class="line">    n |= n &gt;&gt;&gt; 2; // 前4位都是1；</div><div class="line">    n |= n &gt;&gt;&gt; 4; // 前8位都是1</div><div class="line">    n |= n &gt;&gt;&gt; 8; // 前16位都是1；</div><div class="line">    n |= n &gt;&gt;&gt; 16;// 前32位都是1；</div><div class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化容量有两种方式：① newcap = 默认值16，loadfactor = 默认值0.75f; newthreshold = newcap <code>*</code> loadfactor; ② threshold = 最接近2的幂次方的初始化容量；之后在扩容阶段得到：newcap = threshold; newthreshold = loadfactor <code>*</code> newcap;</p>
<p>这里我们重点分析场景2：</p>
<p>核心代码为18 ~ 25行，初始化容量n，将 n - 1后的值进行移位或操作，可以保证从(n - 1)的二进制值，从高位1开始之后的二进制数都是1。这里举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">若初始化容量为6：</div><div class="line">n - 1 = 5 // 101</div><div class="line">n |= n &gt;&gt;&gt; 1 // 101 | 011 = 111 (保证1 ~ 2位，位移数都是1)</div><div class="line">n |= n &gt;&gt;&gt; 2 // 111 | 001 = 111 (保证3 ~ 4位，位移数都是1)</div><div class="line">n |= n &gt;&gt;&gt; 4 // 111 | 000 = 111 (保证5 ~ 8位，位移数都是1)</div><div class="line">n |= n &gt;&gt;&gt; 8 // 111 | 000 = 111 (保证9 ~ 16位，位移数都是1)</div><div class="line">n |= n &gt;&gt;&gt; 16 // 111 | 000 = 111 (保证17 ~ 32位，位移数都是1)</div><div class="line">最后将1加回去：</div><div class="line">n = n + 1 // 8,得到大于6，的最小2的幂次方的数值为2的3次方；</div></pre></td></tr></table></figure>
<h5 id="容量保持2的幂次方，有什么好处呢"><a href="#容量保持2的幂次方，有什么好处呢" class="headerlink" title="容量保持2的幂次方，有什么好处呢?"></a>容量保持2的幂次方，有什么好处呢?</h5><p>主要是跟HashMap的存储方式有关；这里简单介绍下：</p>
<p>1、hash(key)，得到插入元素的Key的哈希值;</p>
<p>2、hash(key) &amp; (n -1) , 得到元素在数组中的索引值；</p>
<p>这里重点说下步骤2，hash(key) &amp; (n -1)等价于 hash(key) % n,这个等价是有条件的，n必须是为n的幂次方。否则条件不成立；这里举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// n非2的幂次方</div><div class="line">hash(key): 11, n: 6</div><div class="line"></div><div class="line">hash(key) &amp; (n - 1) // 1011 &amp; 101 = 0001 明显不等于 11 % 6 = 5</div><div class="line"></div><div class="line">// n为2的幂次方</div><div class="line">hash(key): 11, n: 8</div><div class="line"></div><div class="line">hash(key) &amp; (n -1) // 1011 &amp; 111 = 0011 等于 11 % 8 = 3</div></pre></td></tr></table></figure>
<p>这就是为什么要保持容量为2的幂次方的原因。那么有人要问了，为什么要通过与操作进行求余，为什么不通过%操作符操作呢？因为与操作的执行效率高；</p>
<h4 id="3）HashMap如何实现新增一个键值对"><a href="#3）HashMap如何实现新增一个键值对" class="headerlink" title="3）HashMap如何实现新增一个键值对"></a>3）HashMap如何实现新增一个键值对</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">    return putVal(hash(key), key, value, false, true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">               boolean evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">    if ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">        n = (tab = resize()).length; // tab为空，初始化tab；</div><div class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null) // 没有hash冲突</div><div class="line">        tab[i] = newNode(hash, key, value, null); // 在指定哈希槽插入元素；</div><div class="line">    else &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        if (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // hash一直；key一致；覆盖元素；</div><div class="line">            e = p;</div><div class="line">        else if (p instanceof TreeNode) // 在指定hash位取出的元素是红黑树，往红黑树中插入元素；</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 红黑树插入元素</div><div class="line">        else &#123;</div><div class="line">            for (int binCount = 0; ; ++binCount) &#123;</div><div class="line">                if ((e = p.next) == null) &#123; // 首节点后 + 数据</div><div class="line">                    p.next = newNode(hash, key, value, null);</div><div class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 链表长度大于等于8</div><div class="line">                        treeifyBin(tab, hash); // 转化为红黑树</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 如果key值相当直接退出循环;</div><div class="line">                    break;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (e != null) &#123; // existing mapping for key</div><div class="line">            V oldValue = e.value;</div><div class="line">            if (!onlyIfAbsent || oldValue == null)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    if (++size &gt; threshold)</div><div class="line">        resize(); // 扩容</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第8 ~ 9行：当table的容量为空时，进行扩容；</p>
<p>第10 ~ 11行：获取新增元素在数组中的索引位置，若该位置上没有其他元素，则插入元素；</p>
<p>第12 ~ 40行: 这里着重解释，当存在hash冲突时(即新增元素的在数组中的索引存在其他元素)，如何解决； </p>
<p>第14 ~ 16行：当前元素与新增元素，key完全一样时，获取当前元素值；</p>
<p>第17 ~ 18行：当新增元素索引位，元素结构为红黑树时，往红黑树中插入元素；</p>
<p>第19 ~ 40行: 这里描述的是新增元素索引位，元素的结构为链表；</p>
<p>第20 ~ 26行：死循环，如果找到链表的尾部节点，则在链表后新增元素；判断链表长度 <code>&gt;=</code> 8，若是，则将链表转为红黑树；</p>
<p>第27 ~ 29行：若key与新增元素key相同，则直接退出死循环；</p>
<p>第30行：节点往后移动一位；</p>
<p>第33 ~ 38行：如何存在key相同的元素，是否需要覆盖键值；</p>
<p>第42 ~ 43行：如果元素长度大于扩容阈值，则进行扩容；</p>
<p>具体实现流程图如下：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-27/49558429.jpg" alt=""></p>
<h4 id="4）HashMap为什么是线程不安全的"><a href="#4）HashMap为什么是线程不安全的" class="headerlink" title="4）HashMap为什么是线程不安全的"></a>4）HashMap为什么是线程不安全的</h4><p>JDK1.7在并发情况下，在扩容时会造成环链问题，导致死循环，在JDK1.8版本中已经不存在了；但HashMap依旧不适用于多线程，HashMap的设计目标是简洁高效，没有采取任何措施保障put、remove操作的多线程安全；且在并发环境下，无法保障内存的可见性; </p>
<p>目前这个解释的比较含糊，后续给出具体实例，说明其线程不安全的情况；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#1-常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;1. 常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;1. 常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList源码学习</title>
    <link href="http://jianwl.com/2018/03/17/LinkedList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/17/LinkedList源码学习/</id>
    <published>2018-03-17T04:36:38.000Z</published>
    <updated>2018-03-18T05:22:34.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段梳理"><a href="#常用方法-amp-字段梳理" class="headerlink" title="常用方法 &amp; 字段梳理"></a>常用方法 &amp; 字段梳理</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-17/8479145.jpg" alt=""></p>
<p>LinkedList的底层数据结构是链表，链表是由许多个节点连接而成，每个节点包含三个部分,如图所示：<img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-18/30835149.jpg" alt=""></p>
<p>pre、next分别存放上一个节点的地址和下一个节点的地址，data存放该节点的数据。</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><ol>
<li>如何新增数据, add(E e)</li>
<li>如何在指定位置新增数据,add(int index,E e)</li>
<li>如何获取指定元素的位置，indexOf(Object o)</li>
<li>如何清空整个链表，clear()</li>
</ol>
<h4 id="1-如何新增数据"><a href="#1-如何新增数据" class="headerlink" title="1) 如何新增数据"></a>1) 如何新增数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line">    linkLast(e);</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void linkLast(E e) &#123;</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line">    last = newNode;</div><div class="line">    if (l == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static class Node&lt;E&gt; &#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node&lt;E&gt; prev;</div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        this.item = element;</div><div class="line">        this.next = next;</div><div class="line">        this.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第7行：首先获取链表当前的尾节点l；</p>
<p>第8行：初始化新增节点newNode，包含上一个节点位置、节点数据、下一个节点位置；</p>
<p>第9行：设置新的尾节点为新增节点,last = newNode</p>
<p>第10 ~ 13行：尾节点l为空，那么设置首节点为新节点；反之，设置尾节点l的下一个节点位置为newNode; </p>
<p>第7行 ~ 第13行描述用图示表示：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-18/1333450.jpg" alt=""></p>
<p>第18 ~ 27行：一个节点包括三部分：当前节点数据、上一个节点地址、下一个节点地址</p>
<h4 id="2-如何在指定位置新增数据"><a href="#2-如何在指定位置新增数据" class="headerlink" title="2) 如何在指定位置新增数据"></a>2) 如何在指定位置新增数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public void add(int index, E element) &#123;</div><div class="line">    checkPositionIndex(index);</div><div class="line"></div><div class="line">    if (index == size)</div><div class="line">        linkLast(element);</div><div class="line">    else</div><div class="line">        linkBefore(element, node(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void linkLast(E e) &#123;</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line">    last = newNode;</div><div class="line">    if (l == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Node&lt;E&gt; node(int index) &#123;</div><div class="line">    // assert isElementIndex(index);</div><div class="line"></div><div class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        for (int i = 0; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        return x;</div><div class="line">    &#125; else &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        for (int i = size - 1; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</div><div class="line">    // assert succ != null;</div><div class="line">    final Node&lt;E&gt; pred = succ.prev;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</div><div class="line">    succ.prev = newNode;</div><div class="line">    if (pred == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        pred.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第2行：检查新增的位置是否越界了(位置范围是：[0,size])</p>
<p>第4 ~ 5行：新增的位置为链表长度(size),链表尾节点所在位置为：(size -1)，所以在该位置(size位置)新增节点，类似在尾节点新增节点。上一个功能点已描述，这里就不赘述了。</p>
<p>第22 ~ 36行：二分法，判断新增位置处于size的左部分([0,size/2])还是右部分((size/2,size -1])，左部分，从首节点，头往后找；右部分，从尾节点，从后往前找。</p>
<p>第38 ~ 48行：新增位置的原来节点为：succ;如果succ的上一个节点为null，则说明新增位置为首节点；反之，新增位置为中间节点。首节点位置新增时，初始化新增节点，并将原首节点位置的上个节点地址设置为新增节点；中间节点位置新增时，初始化新增节点，并将上一个节点的下一个节点位置，设置为新增节点。</p>
<p>第38 ~ 48行图示如下：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-18/17702167.jpg" alt=""></p>
<h4 id="3-如何获取指定元素的位置"><a href="#3-如何获取指定元素的位置" class="headerlink" title="3) 如何获取指定元素的位置"></a>3) 如何获取指定元素的位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public int indexOf(Object o) &#123;</div><div class="line">    int index = 0;</div><div class="line">    if (o == null) &#123;</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (x.item == null)</div><div class="line">                return index;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (o.equals(x.item))</div><div class="line">                return index;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从首节点开始遍历，寻找的对象分两种：空对象和非空对象；若节点值等于寻找的对象，返回游标值；</p>
<h4 id="4）如何清空整个链表"><a href="#4）如何清空整个链表" class="headerlink" title="4）如何清空整个链表"></a>4）如何清空整个链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void clear() &#123;</div><div class="line">    // Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</div><div class="line">    // - helps a generational GC if the discarded nodes inhabit</div><div class="line">    //   more than one generation</div><div class="line">    // - is sure to free memory even if there is a reachable Iterator</div><div class="line">    for (Node&lt;E&gt; x = first; x != null; ) &#123;</div><div class="line">        Node&lt;E&gt; next = x.next;</div><div class="line">        x.item = null;</div><div class="line">        x.next = null;</div><div class="line">        x.prev = null;</div><div class="line">        x = next;</div><div class="line">    &#125;</div><div class="line">    first = last = null;</div><div class="line">    size = 0;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>遍历链表，将每一个节点的数据清空，最后将头结点和尾节点的数据清空，链表长度设置为0；</p>
<p>刚开始有个疑问，清空整个链表了，首、尾两节点已经为空了，为什么在第13行代码还需要再次清空呢？其实呢，首节点和尾节点单独存到变量里，所以在清空链表的时候，first、last节点都是有数据的，所以还需要单独清空。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段梳理&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段梳理&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段梳理&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段梳理&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码学习</title>
    <link href="http://jianwl.com/2018/03/15/ArrayList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/15/ArrayList源码学习/</id>
    <published>2018-03-15T15:05:33.000Z</published>
    <updated>2018-03-17T03:44:38.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-常用方法-amp-字段梳理"><a href="#1-常用方法-amp-字段梳理" class="headerlink" title="1. 常用方法 &amp; 字段梳理"></a>1. 常用方法 &amp; 字段梳理</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-15/41421167.jpg" alt=""></p>
<p>ArrayList底层的数据结构是数组，往列表中插入数据时，首先会检查列表的容量是否充足，当容量不够时，会自动扩容为当前容量的3倍，本节我们会带着问题，学习ArrayList的实现原理。</p>
<h3 id="2-提出问题"><a href="#2-提出问题" class="headerlink" title="2. 提出问题"></a>2. 提出问题</h3><ol>
<li>add(E)，新增元素时，如何实现自动扩容；</li>
<li>add(index,E)如何实现在指定位置插入元素，指定位置之后的元素如何处理？</li>
<li>clear(), 避免内存溢出，在移除元素时，我们应该注意些什么？</li>
</ol>
<h4 id="1）新增元素"><a href="#1）新增元素" class="headerlink" title="1）新增元素"></a>1）新增元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"># 新增元素入口</div><div class="line">   public boolean add(E e) &#123;</div><div class="line">       ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div class="line">       elementData[size++] = e;</div><div class="line">       return true;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   private void ensureCapacityInternal(int minCapacity) &#123;</div><div class="line">       if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       ensureExplicitCapacity(minCapacity);</div><div class="line">   &#125;</div><div class="line">       </div><div class="line">   private void ensureExplicitCapacity(int minCapacity) &#123;</div><div class="line">       modCount++;</div><div class="line"></div><div class="line">       // overflow-conscious code</div><div class="line">       if (minCapacity - elementData.length &gt; 0)</div><div class="line">           grow(minCapacity);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   private void grow(int minCapacity) &#123;</div><div class="line">       // overflow-conscious code</div><div class="line">       int oldCapacity = elementData.length;</div><div class="line">       int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 为原来的3倍；</div><div class="line">       if (newCapacity - minCapacity &lt; 0)</div><div class="line">           newCapacity = minCapacity;</div><div class="line">       if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</div><div class="line">           newCapacity = hugeCapacity(minCapacity);</div><div class="line">       // minCapacity is usually close to size, so this is a win:</div><div class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   private static int hugeCapacity(int minCapacity) &#123;</div><div class="line">       if (minCapacity &lt; 0) // overflow</div><div class="line">           throw new OutOfMemoryError();</div><div class="line">       return (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">           Integer.MAX_VALUE :</div><div class="line">           MAX_ARRAY_SIZE;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>第3 ~ 4行：新增一个元素之前，需要先确保元素加进去之后，容量是否会溢出;如果容量够用，则往数组中插入数据；</p>
<p>第9 ~ 11行：如果是一个空列表，当前最小的容量(size + 1)为默认值10；</p>
<p>第 20 ~ 21行：如果新增元素后，元素的数量(size + 1) <strong>大于</strong> 数组的长度(elementData.length),则扩容；</p>
<p>第26 ~ 33行：扩容的逻辑，将列表的容量扩大为原来的3倍即(3 elementData.length),如果扩容后的容量 <strong>仍旧小于</strong> 元素的数量(size + 1),则将列表容量设置为(size + 1)，之后判断扩容后的容量是否大于「最大的整数 - 8」，如果大于，则等于最大整数；最后将原来的数组迁移到扩容后的数组；</p>
<p>第37 ~ 38行：为了防止当容量大于整数最大值即(大于Integer.MAX_VALUE)，此时会出现整型数据溢出，为负值，此时报内存溢出异常。</p>
<h4 id="2-指定位置新增元素"><a href="#2-指定位置新增元素" class="headerlink" title="2) 指定位置新增元素"></a>2) 指定位置新增元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void add(int index, E element) &#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div class="line">    System.arraycopy(elementData, index, elementData, index + 1,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void rangeCheckForAdd(int index) &#123;</div><div class="line">    if (index &gt; size || index &lt; 0)</div><div class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第12 ~ 13行：判断索引位置会不会越界即(大于数组大小和小于0)；</p>
<p>第 4 行：新增元素前，进行容量预估，容量不足时则扩容。上一个模块已描述，这里就不赘述了；</p>
<p>第 5 行：用图示的方式来说明，如果往元素2的位置插入元素，需要将元素2及之后的元素均向后挪动一位，这行代码就是执行这样的功能。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-17/23285668.jpg" alt=""></p>
<p>第7 ~ 8行：把元素放到数组中的指定位置，同时将列表的长度加1。</p>
<h4 id="3）清空数组"><a href="#3）清空数组" class="headerlink" title="3）清空数组"></a>3）清空数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void clear() &#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    // clear to let GC do its work</div><div class="line">    for (int i = 0; i &lt; size; i++)</div><div class="line">        elementData[i] = null;</div><div class="line"></div><div class="line">    size = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第5 ~ 6行：遍历数组中的每一个元素，将其设置为null，方便后续GC回收内存。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-常用方法-amp-字段梳理&quot;&gt;&lt;a href=&quot;#1-常用方法-amp-字段梳理&quot; class=&quot;headerlink&quot; title=&quot;1. 常用方法 &amp;amp; 字段梳理&quot;&gt;&lt;/a&gt;1. 常用方法 &amp;amp; 字段梳理&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;ht
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>如何定位消耗CPU最多的线程</title>
    <link href="http://jianwl.com/2018/03/15/%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%B6%88%E8%80%97CPU%E6%9C%80%E5%A4%9A%E7%9A%84%E7%BA%BF%E7%A8%8B/"/>
    <id>http://jianwl.com/2018/03/15/如何定位消耗CPU最多的线程/</id>
    <published>2018-03-15T12:28:13.000Z</published>
    <updated>2018-03-15T13:14:48.828Z</updated>
    
    <content type="html"><![CDATA[<p>话不多说，先上代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class CpuMax &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        for(int i =0 ; i &lt; 10 ; i ++)&#123;</div><div class="line">            new Thread(() -&gt; &#123;</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(1000L);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Thread t = new Thread(() -&gt; &#123;</div><div class="line">            int i = 0;</div><div class="line">            while (true)&#123;</div><div class="line">                i = (i++) /100;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        t.setName(&quot;Business Thread&quot;);</div><div class="line">        t.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有11个线程，其中10个线程啥也不做，1个线程执行死循环操作。那么如何定位消耗CPU最多的这个线程呢？且看以下解决思路：</p>
<h4 id="1-运行程序"><a href="#1-运行程序" class="headerlink" title="1. 运行程序"></a>1. 运行程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 编译</div><div class="line">javac CpuMax.java</div><div class="line"></div><div class="line"># 运行</div><div class="line">java CpuMax</div></pre></td></tr></table></figure>
<h4 id="2-获取进程PID"><a href="#2-获取进程PID" class="headerlink" title="2. 获取进程PID"></a>2. 获取进程PID</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep &quot;CpuMax&quot;</div></pre></td></tr></table></figure>
<p>得到进程PID: 5055</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-15/8443081.jpg" alt=""></p>
<h4 id="3-获取进程中各线程所占CPU的占比"><a href="#3-获取进程中各线程所占CPU的占比" class="headerlink" title="3. 获取进程中各线程所占CPU的占比"></a>3. 获取进程中各线程所占CPU的占比</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">top -Hp 5505</div></pre></td></tr></table></figure>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-15/33928406.jpg" alt=""></p>
<p>根据图片信息，我们可以得到：CPU占比99.9%的线程PID为5084。线程PID转为16进制为：ox13dc</p>
<h4 id="4-打印进程中各个线程栈信息"><a href="#4-打印进程中各个线程栈信息" class="headerlink" title="4. 打印进程中各个线程栈信息"></a>4. 打印进程中各个线程栈信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstack 5055</div></pre></td></tr></table></figure>
<p>得到以下信息:</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-15/57356621.jpg" alt=""></p>
<p>步骤3中，我们得到CPU最大的线程的PID，16进制为：0x13dc，在线程栈中，我们可以根据16进制的PID得到一些关键信息。<strong>得到线程名为「Business Thread」为CPU占比最高的线程</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话不多说，先上代码。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div 
    
    </summary>
    
      <category term="Java进阶" scheme="http://jianwl.com/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java进阶" scheme="http://jianwl.com/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码学习计划</title>
    <link href="http://jianwl.com/2018/03/14/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://jianwl.com/2018/03/14/JDK源码学习计划/</id>
    <published>2018-03-14T03:45:33.000Z</published>
    <updated>2018-05-04T00:33:04.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学习源码是非常重要的，列出几个感触比较深的地方：</p>
<ol>
<li>学习Java多年，如果连平时最常用的API的实现原理都不知道，说明这个人没什么好奇心，基础不扎实。</li>
<li>1年的经验，重复使用多年，自身的经验并没有随着年限而增长，个人成长处于停滞状态。</li>
<li>只有接触多了优秀的源码，才知道进步的方向，只是埋头苦干，很容易迷失自我。</li>
<li>沉淀的重要性，切记样样通，样样半桶水的状态。知道怎么做，问你原理半天憋不出的糗样。探究精神尤其重要；</li>
</ol>
<h3 id="1-JDK1期-学习计划"><a href="#1-JDK1期-学习计划" class="headerlink" title="1. JDK1期 学习计划"></a>1. JDK1期 学习计划</h3><h4 id="1）集合类"><a href="#1）集合类" class="headerlink" title="1）集合类"></a>1）集合类</h4><ul>
<li><a href="http://jianwl.com/2018/03/15/ArrayList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">ArrayList</a> [√]</li>
<li><a href="http://jianwl.com/2018/03/17/LinkedList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">LinkedList</a> [√]</li>
<li><a href="http://jianwl.com/2018/03/22/HashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">HashMap</a>「√」</li>
<li><a href="http://jianwl.com/2018/03/27/HashSet%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">HashSet</a>「√」</li>
<li><a href="http://jianwl.com/2018/03/29/Hashtable%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Hashtable</a>「√」</li>
</ul>
<h4 id="2）String相关"><a href="#2）String相关" class="headerlink" title="2）String相关"></a>2）String相关</h4><ul>
<li><a href="http://jianwl.com/2018/04/01/String%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">String</a>「√」</li>
<li><a href="http://jianwl.com/2018/04/02/StringBuilder%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">StringBuilder</a>「√」</li>
<li><a href="http://jianwl.com/2018/04/02/StringBuilder%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">StringBuffer</a>「√」</li>
</ul>
<h4 id="3-多线程-amp-线程池"><a href="#3-多线程-amp-线程池" class="headerlink" title="3) 多线程 &amp; 线程池"></a>3) 多线程 &amp; 线程池</h4><ul>
<li><a href="http://jianwl.com/2018/05/04/Thread%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">Thread</a>「√」</li>
<li><a href="http://jianwl.com/2018/04/19/ThreadLocal%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">ThreadLocal</a>「√」</li>
<li>ConcurrentHashMap</li>
<li><a href="http://jianwl.com/2018/04/18/ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">ThreadPoolExecutor</a>「√」</li>
</ul>
<h4 id="4-原子操作"><a href="#4-原子操作" class="headerlink" title="4) 原子操作"></a>4) 原子操作</h4><ul>
<li>AtomicInteger</li>
<li>AtomicBoolean</li>
<li>AtomicLong</li>
<li>AtomicReference</li>
</ul>
<h4 id="5-锁"><a href="#5-锁" class="headerlink" title="5) 锁"></a>5) 锁</h4><ul>
<li>ReentrantLock</li>
<li>ReentrantReadWriteLock</li>
</ul>
<h4 id="6）队列"><a href="#6）队列" class="headerlink" title="6）队列"></a>6）队列</h4><ul>
<li>ArrayBlockingQueue</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;学习源码是非常重要的，列出几个感触比较深的地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学习Java多年，如果连平时最常用的API的实现原理都不知道，说
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载的那些事</title>
    <link href="http://jianwl.com/2018/03/04/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://jianwl.com/2018/03/04/JVM类加载的那些事/</id>
    <published>2018-03-04T13:56:36.000Z</published>
    <updated>2018-03-07T14:01:18.489Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java源代码被编译成class字节码，最终需要加载到虚拟机中才能运行。整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-5/76059548.jpg" alt=""></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol>
<li>通过一个类的全限定名获取描述此类的二进制字节流</li>
<li>通过这个字节流锁代表的静态存储结构保存为方法区的运行时数据结构；</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为范文方法区的入口；</li>
</ol>
<p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，实现这个动作的代码称为“类加载器”，JVM提供了3种类加载器：</p>
<ol>
<li>启动类加载器（Bootstrap ClassLoader）： 负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。</li>
<li>扩展类加载器（Extension ClassLoader）: 负责加载JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</li>
<li>应用程序类加载器（Application ClassLoader）:负责加载用户路径(classpath)上的类库。</li>
</ol>
<p>JVM基于上述类加载器，通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-6/33598419.jpg" alt=""></p>
<p>双亲委派模型工作过程：当一个类加载器收到类加载任务,优先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。</p>
<p>双亲委派模型有什么好处？</p>
<p>比如位于rt.jar包中的类java.lang.Object,无论哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，确保了Object类在各种加载器环境中都是同一个类。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>为了确保Class文件符合当前虚拟机要求，需要对其字节流数据进行验证，主要包括格式验证、元数据验证、字节码验证和符号引用验证。</p>
<h4 id="1、格式校验"><a href="#1、格式校验" class="headerlink" title="1、格式校验"></a>1、格式校验</h4><p>验证字节流是否符合class文件格式的规范，并且能被当前虚拟机处理，如：是否以魔数0xCAFEBABE开头、主次版本号是否在当前虚拟机处理范围内、常量池是否有不支持的常量类型等。只有经过格式验证的字节流，才会存储到方法区的数据结构，剩余3个验证都基于方法区的数据进行。</p>
<h4 id="2、元数据验证"><a href="#2、元数据验证" class="headerlink" title="2、元数据验证"></a>2、元数据验证</h4><p>对字节码描述的数据进行语义分析，以保证符合Java语言规范，如是否继承了final修饰的类、是否实现了父类的抽象方法、是否覆盖了父类的final方法或final字段等。</p>
<h4 id="3、字节码验证"><a href="#3、字节码验证" class="headerlink" title="3、字节码验证"></a>3、字节码验证</h4><p>对类的方法体进行分析，确保在方法运行时不会有危害虚拟机的事件发生，如保证操作数栈的数据类型和指令代码序列的匹配、保证跳转指令的正确性、保证类型转换的有效性等。</p>
<h4 id="4、符号引用验证"><a href="#4、符号引用验证" class="headerlink" title="4、符号引用验证"></a>4、符号引用验证</h4><p>为了确保后续的解析动作能够正常执行，对符号引用进行验证，如通过字符串描述的全限定名是能找到对应的类、在指定类中是否存在符合方法的字段描述等。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在准备阶段，为类变量(static修饰)在方法区中分配内存并设置初始值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static int var = 100;</div></pre></td></tr></table></figure>
<p>准备阶段完成后，var值为0，而不是100。在初始化阶段，才会把100赋值给val，但是有个特殊情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static final int VAL = 100;</div></pre></td></tr></table></figure>
<p>在编译阶段会为VAL生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将VAL赋值为100。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是将常量池中的符号引用替换为直接引用的过程，符号引用和直接引用有什么不同？</p>
<ol>
<li>符号引用使用一组符号来描述所引用的目标，可以是任何形式的字面常量，定义在Class文件格式中。</li>
<li>直接引用可以是直接指向目标的指针，相对偏移量或者能间接定位目标的句柄。</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是执行类构造器<clinit>方法的过程，<clinit>方法由类变量的赋值动作和静态语句块按照在源文件出现的顺序合并而成，该合并操作由编译器完成。</clinit></clinit></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private static int value = 100;</div><div class="line">static int a = 100;</div><div class="line">static int b = 100;</div><div class="line">static int c;</div><div class="line"></div><div class="line">static &#123;</div><div class="line">	c = a + b;</div><div class="line">	System.out.println(&quot;it only run once&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><clinit>方法对于类和接口不是必须的，如果一个类中没有静态代码块，也没有静态变量的赋值操作，那么编译器不会生成<clinit>；</clinit></clinit></li>
<li><clinit>方法与实例构造器不同，不需要显式的调用父类的<clinit>方法，虚拟机会保证父类的<clinit>优先执行。</clinit></clinit></clinit></li>
<li>为了防止多次执行<clinit>,虚拟机会确保<clinit>方法在多线程环境下被正确的加锁同步执行，如果有多个线程同时初始化一个类，那么只有一个线程能够执行<clinit>方法，其他线程进行阻塞等待，直到<clinit>执行完成。</clinit></clinit></clinit></clinit></li>
<li>注意：执行接口的<clinit>方法不需要先执行父接口的<clinit>，只有使用父接口中定义的变量时，才会执行。</clinit></clinit></li>
</ol>
<h3 id="类初始化场景"><a href="#类初始化场景" class="headerlink" title="类初始化场景"></a>类初始化场景</h3><p>虚拟机中严格规定了有且只有5种情况必须对类初始化。</p>
<ul>
<li>执行new、getstatic、putstatic和invokestatic指令；</li>
<li>使用reflect对类进行反射调用；</li>
<li>初始化一个类的时候，父类还没有初始化，会事先初始化父类；</li>
<li>启动虚拟机时，需要初始化包含main方法的类；</li>
<li>在JDK1.7中，如果java.lang.invoke.MethodHandler实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化；</li>
</ul>
<p>一下几种情况，不会触发类初始化：</p>
<p>1、通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Parent&#123;</div><div class="line">	static int a = 100;</div><div class="line">	static&#123;</div><div class="line">		System.out.println(&quot;parent int !&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Child extends Parent&#123;</div><div class="line">	static &#123;</div><div class="line">	 	System.out.println(&quot;child init!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Init&#123;</div><div class="line">	public static void main(String args[]) &#123;</div><div class="line">		System.out.println(Child.a);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果为：<br>parent init !<br>100</p>
<p>2、定义对象数组，不会触发该类的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Init&#123;</div><div class="line">	public static void main(String args[]) &#123;</div><div class="line">		Parent[] parents = new Parent[10];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无输出，说明没有触发类Parent的初始化，但是这段代码做了什么？先看看生成的字节码指令；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-7/40936913.jpg" alt=""></p>
<p>anewarray指令为新数组分配空间，并触发Parent类的初始化，这个类由虚拟机自动生成。</p>
<p>3、常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Const&#123;</div><div class="line">	static final int A = 100;</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;Const init&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Init&#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		System.out.println(Const.A);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：100</p>
<p>说明没有触发类Const的初始化，在编译阶段，Const类中常量A的值100存储到Init类的常量池中，这两个类在编译成class文件之后就没有联系了。</p>
<p>4、通过类名获取Class对象，不会触发类的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">	public static void main(String args[]) &#123;</div><div class="line">		Class cDog = Dog.class;</div><div class="line">		Class clazz = Class.forName(&quot;zzzzzzz.Cat&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Class Cat &#123;</div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	static&#123;</div><div class="line">		System.out.println(&quot;Cat is load&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog&#123;</div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	static&#123;</div><div class="line">		System.out.println(&quot;Dog is load&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：Cat is load, 所以通过Dog.class并不会触发Dog类的初始化动作。</p>
<p>5、通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否亚欧对类进行初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">	public static void main(String args[]) &#123;</div><div class="line">		Class clazz = Class.forName(&quot;zzzzzz.Cat&quot;,false,Cat.class.getClassLoader());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat&#123;</div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;Cat is load&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>6、通过ClassLoader默认的loadClass方法，也不会触发初始化动作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ClassLoader()&#123;&#125;.loadClass(&quot;zzzzzz.Cat&quot;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Java源代码被编译成class字节码，最终需要加载到虚拟机中才能运行。整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段
    
    </summary>
    
      <category term="JVM专题" scheme="http://jianwl.com/categories/JVM%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JVM专题" scheme="http://jianwl.com/tags/JVM%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存的那些事</title>
    <link href="http://jianwl.com/2018/03/04/JVM%E5%86%85%E5%AD%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://jianwl.com/2018/03/04/JVM内存的那些事/</id>
    <published>2018-03-04T08:46:45.000Z</published>
    <updated>2018-04-01T03:33:47.409Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于C语言开发的程序员来说，在内存管理方面，必须负责每一个对象的生命周期，从有到无。对于Java程序员来说，在虚拟机内存管理的帮助下，不需要为每个new对象都匹配free操作，内存泄露和内存溢出等问题也不太容易出现，不过也正是把内存管理交给了虚拟机，一旦运行中的程序出现了内存泄露问题，给排查过程造成很大困难。所以只有理解了Java虚拟机的运行机制，才能够运筹帷幄于各种代码。本文以HotSpot为例说说虚拟机的那些事。</p>
<p>Java虚拟机把管理的内存划分为几个不同的数据区。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-4/82705423.jpg" alt=""></p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，Java虚拟机规范中有这样一段描述：所有的对象实例和数据都要在堆上进行分配。为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，通常有两种方法实现：</p>
<h4 id="1、指针碰撞法"><a href="#1、指针碰撞法" class="headerlink" title="1、指针碰撞法"></a>1、指针碰撞法</h4><p>假设Java堆中内存是完整的，已分配的内存和空闲内存分别在不同的一侧，通过一个指针作为分界点，需要分配内存时，仅仅需要把指针往空闲的一端移动与对象大小相等的距离。</p>
<h4 id="2、空闲列表法"><a href="#2、空闲列表法" class="headerlink" title="2、空闲列表法"></a>2、空闲列表法</h4><p>事实上，Java堆的内存并不是完整的，已分配的内存和空闲内存相互交错，JVM通过维护一个列表，记录可用的内存块信息，当分配操作发生时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录。</p>
<p>对象创建时一个非常频繁的行为，进行堆内存分配时还需要考虑多线程并发问题，可能出现正在给对象A分配内存，指针或记录还未更新，对象B又同时分配到原来的内存，解决这个问题有两种方案：</p>
<p>1、采用CAS保证数据更新操作的原子性；</p>
<p>2、把内存分配的行为按照线程进行划分，在不同的空间中进行，每个线程在Java堆中预先分配一个内存块，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB);</p>
<h4 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h4><p>堆内存由年轻代和老年代组成，而年轻代又被分为三部分：Eden空间、From Survivor空间、To Survivor空间，默认情况下年轻代安装8：1：1的比例来分配；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-1/86769879.jpg" alt=""></p>
<h3 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h3><p>Java栈是线程私有的，每个线程对应一个Java栈，每个线程在执行一个方法时会创建一个对应的栈帧(Stack Frame)，栈帧负责存储局部变量表、操作数栈、动态链接和方法返回地址等信息。每个方法的调用过程，相当于栈帧在Java栈的入栈和出栈的过程。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-4/89188723.jpg" alt=""></p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>用于存放方法参数和方法内部定义的局部变量，其大小在代码编译期间已经确定，在方法运行期间不会改变。局部变量表以变量槽(Slot)为最小存储单位，每个Slot能够存放一个boolean、byte、char、short、int、float、reference和return address类型的32位数据，对于64位的数据类型long和double，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。</p>
<p>在方法执行时，如果是实例方法，即非static方法，局部变量表中第0位Slot默认存放对象实例的引用，在方法中可以通过关键字this进行访问，方法参数按照参数列表顺序，从第1位Slot开始分配，方法内部变量则按照定义顺序进行分配其余的Slot。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区和Java堆一样，是所有线程共享的内存区域，用于存放已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据。运行时常量池是方法区的一部分，用于存放编译期间产生的各种字面常量和符号引用。</p>
<h3 id="指令计数器"><a href="#指令计数器" class="headerlink" title="指令计数器"></a>指令计数器</h3><p>指令计数器是线程私有的，每个线程都有独立的指令计数器，计数器记录着虚拟机正在执行的字节码指令的地址，分支、循环、跳转、异常处理和线程恢复等操作都依赖这个计数器完成。如果线程执行的是native方法，这个计数器则为空。</p>
<h3 id="通过参数控制各区域的大小"><a href="#通过参数控制各区域的大小" class="headerlink" title="通过参数控制各区域的大小"></a>通过参数控制各区域的大小</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-1/7809771.jpg" alt=""></p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在内存中布局可以分成三块区域：对象头、实例数据和对齐填充。</p>
<h5 id="1、对象头"><a href="#1、对象头" class="headerlink" title="1、对象头"></a>1、对象头</h5><p>对象头包括两部分信息：运行时数据和类型指针，如果对象是一个数组，还需要一块用于记录数组长度的数据。</p>
<p>1.1、运行时数据包括哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向锁和偏向时间戳等，这部分数据在32位和64位虚拟机中的长度分别为32bit和64bit，官方称为“Mark Word”。Mark Word被设计成非固定的数据结构，以实现在有限空间内保存尽可能多的数据。</p>
<p>32为虚拟机中，对象未被锁定的状态下，Mark Word的32bit中25bit存储对象的HashCode、4bit存储对象分代年龄、2bit存储锁标志位、1bit固定为0，具体如下：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-4/80147108.jpg" alt=""></p>
<p>其他状态(轻量级锁定、重量级锁定、GC锁、可偏向锁)下Mark Word的存储内容如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">存储内容</th>
<th style="text-align:center">标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">轻量级锁定</td>
<td style="text-align:center">指向锁记录的指针</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">重量级锁定</td>
<td style="text-align:center">指向重量级的指针</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">GC标志</td>
<td style="text-align:center">空</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">可偏向</td>
<td style="text-align:center">偏向线程ID、时间戳、分代年龄</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">未锁定</td>
<td style="text-align:center">对象哈希码、分代年龄</td>
<td style="text-align:center">01</td>
</tr>
</tbody>
</table>
<p>1.2 、对象头的类型指针指向该对象的类元数据、虚拟机通过这个指针可以确定该对象是哪个类的实例。</p>
<h5 id="2、实例数据"><a href="#2、实例数据" class="headerlink" title="2、实例数据"></a>2、实例数据</h5><p>实例数据就是在程序代码中所定义的各种类型的字段，包括从父类继承的，这部分的存储顺序会受到虚拟机分配策略和字段在源码中定义顺序的影响。</p>
<h5 id="3、对齐填充"><a href="#3、对齐填充" class="headerlink" title="3、对齐填充"></a>3、对齐填充</h5><p>由于HotSpot的自动内存管理要求对象的起始地址必须是8字节的整数倍，即对象的大小必须是8字节的整数倍，对象头的数据正好是8的整数倍，所以当实例数据不够8字节整数倍时，需要通过对齐填充进行补全。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>深入理解Java虚拟机</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;对于C语言开发的程序员来说，在内存管理方面，必须负责每一个对象的生命周期，从有到无。对于Java程序员来说，在虚拟机内存管理的帮助下，不需要
    
    </summary>
    
      <category term="JVM专题" scheme="http://jianwl.com/categories/JVM%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JVM专题" scheme="http://jianwl.com/tags/JVM%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>用ELK搭建自己的日志分析系统</title>
    <link href="http://jianwl.com/2017/11/05/%E7%94%A8ELK%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://jianwl.com/2017/11/05/用ELK搭建自己的日志分析系统/</id>
    <published>2017-11-05T00:25:09.000Z</published>
    <updated>2017-11-05T03:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p>不管用于记录、监控，日志对于任何系统来说都是一个极其重要的部分，但一般的日志的数据量会比较大，并且分散在各个地方，当管理的服务器比较少，我们还可以逐一登录到各个服务器去查看、分析。但如果服务器比较多，这种方法就显得力不从心了。基于这种场景，一些集中式的日志系统也就产生了。比较成熟<a href="https://www.splunk.com/zh-hans_cn" target="_blank" rel="external">Splunk</a>、Facebook的Scribe、Apache的Chukwa、Cloudera的Fluentd和ELK等。</p>
<h3 id="2-概述"><a href="#2-概述" class="headerlink" title="2 概述"></a>2 概述</h3><p>ELK不是一款软件，是三个软件产品的首字母缩写：ElasticSearc、Logstash和Kibana，这三款都是开源的，目前归于<code>Elastic.co</code>公司。三者之间的关系如图所示：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-5/58949300.jpg" alt=""></p>
<h4 id="1）Elasticsearch"><a href="#1）Elasticsearch" class="headerlink" title="1）Elasticsearch"></a>1）Elasticsearch</h4><p>Elasticsearch是一个实时的分布式搜索和分析引擎，它可以用于全文搜索、结构化搜索以及分析，它是基于Apache Lucence基础上开发搜索引擎，使用Java语言编写。作为ELK协议栈的核心，它用于集中存储数据。</p>
<p>特点：</p>
<ul>
<li>实时</li>
<li>分布式</li>
<li>面向文档</li>
<li>高可用性、易扩展、支持集群、分片、复制</li>
<li>接口友好，RestFUL接口风格；</li>
</ul>
<h4 id="2）Logstash"><a href="#2）Logstash" class="headerlink" title="2）Logstash"></a>2）Logstash</h4><p>Logstash是一个具有实时渠道能力的数据收集引擎，是用JRuby语言编写，其作者是世界上著名的运维工程师乔丹西塞。</p>
<p>特点：</p>
<ul>
<li>几乎可以访问任何数据</li>
<li>可以和多种外部应用结合</li>
<li>支持弹性扩展</li>
</ul>
<p>组成部分</p>
<ul>
<li>INPUTS，从各个服务器获取数据</li>
<li>FILTERS，过滤处理获取到的数据</li>
<li>OUTPUTS，将处理完的数据输出到指定地方</li>
</ul>
<h4 id="3）Kibana"><a href="#3）Kibana" class="headerlink" title="3）Kibana"></a>3）Kibana</h4><p>Kibana是一款基于Apache开源协议，使用Javascript语言编写，为Elasticsearch提供分析和可视化的Web平台。它可以在Elasticsearch的搜索中查找、交互数据，并生成各种维度的表图。</p>
<h3 id="3-ELK平台搭建-MacOS"><a href="#3-ELK平台搭建-MacOS" class="headerlink" title="3 ELK平台搭建(MacOS)"></a>3 ELK平台搭建(MacOS)</h3><h4 id="1-Elasticsearch搭建"><a href="#1-Elasticsearch搭建" class="headerlink" title="1) Elasticsearch搭建"></a>1) Elasticsearch搭建</h4><p>1 下载Elasticsearch &amp; 解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.3.zip</div><div class="line">unzip elasticsearch-5.6.3.zip</div></pre></td></tr></table></figure>
<p>2 启动Elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./$&#123;ES_HOME&#125;/bin/elasticsearch</div></pre></td></tr></table></figure>
<p>3 检查是否启动成功</p>
<p>健康值绿色: 所有主、复制分片都是正常的；</p>
<p>健康值黄色: 所有主分片正常，部分或全部复制分片数有问题；</p>
<p>健康值红色: 部分或全部主分片有问题 </p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-5/55815051.jpg" alt=""></p>
<p>4 安装elastic-head</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git clone git://github.com/mobz/elasticsearch-head.git</div><div class="line">cd elasticsearch-head</div><div class="line">npm install</div><div class="line">npm run start</div></pre></td></tr></table></figure>
<p>通过elastic-head查看elasticsearch的数据：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-5/4570828.jpg" alt=""></p>
<h4 id="2）Logstash搭建"><a href="#2）Logstash搭建" class="headerlink" title="2）Logstash搭建"></a>2）Logstash搭建</h4><p>1 下载Logstash &amp; 解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-5.6.3.zip</div><div class="line">unzip logstash-5.6.3.zip</div></pre></td></tr></table></figure>
<p>2 Logstash管道测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd logstash-5.6.3</div><div class="line">bin/logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&apos;</div></pre></td></tr></table></figure>
<p><code>-e</code>表示能够在命令行中配置logstash的配置(一次性的),通过上述命令启动logstash，当你看到<code>Pipeline main started</code>，在命令行中输入<code>hello world</code>，会得到一个输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello world!</div><div class="line">2017-11-05T01:53:55.571Z jianweilindeMacBook-Pro.local hello world!</div></pre></td></tr></table></figure>
<p>3 配置Filebeat发送日志到Logstash</p>
<p>1) 下载Filebeat &amp; 解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-5.6.3-darwin-x86_64.tar.gz</div><div class="line">tar zxvf filebeat-5.6.3-darwin-x86_64.tar.gz</div></pre></td></tr></table></figure>
<p>2) 配置filebeat.yml</p>
<ul>
<li><p>下载<a href="http://oc5a5l0a0.bkt.clouddn.com/logstash-tutorial.log" target="_blank" rel="external">logstash-tutorial.log</a></p>
</li>
<li><p>配置filebeat.yml</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">filebeat.prospectors:</div><div class="line">- input_type: log</div><div class="line">  paths:</div><div class="line">    - /Users/jianweilin/Downloads/logstash-tutorial.log</div><div class="line">    - /var/log/*.log</div><div class="line">output.logstash:</div><div class="line">  hosts: [&quot;localhost:5043&quot;]</div></pre></td></tr></table></figure>
<p>特别注意：logstash-tutorial.log的路径是刚刚下载的文件，在你本地的路径。</p>
<p>3）配置Logstash配置文件</p>
<p>在${LOGSTASH_HOME}目录下创建一个配置文件<code>first-pipeline.conf</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">    beats &#123;</div><div class="line">        port =&gt; &quot;5043&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output &#123;</div><div class="line">    elasticsearch &#123;</div><div class="line">        hosts =&gt; [ &quot;localhost:9200&quot; ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述配置的意思是：从filebeat中接收数据，之后发送到elasticsearch中</p>
<p>4) 启动logstash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/logstash -f first-pipeline.conf --config.reload.automatic</div></pre></td></tr></table></figure>
<p><code>--config.reload.automatic</code>表示之后如果first-pipeline.conf配置文件更新规则，会自动更新生效，不需要重启logstash；</p>
<p>5) 启动filebeat将日志发送到logstash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./filebeat -e -c filebeat.yml -d &quot;publish&quot;</div></pre></td></tr></table></figure>
<p>6) 在elastic-head中查看数据</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-5/18364515.jpg" alt=""></p>
<p>elasticsearch健康值为黄色，是因为只有一个主分片，没有复制分片；</p>
<h4 id="3-Kibana搭建"><a href="#3-Kibana搭建" class="headerlink" title="3) Kibana搭建"></a>3) Kibana搭建</h4><p>1 Kibana下载 &amp; 解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-5.6.3-darwin-x86_64.tar.gz</div><div class="line">tar zxvf kibana-5.6.3-darwin-x86_64.tar.gz</div></pre></td></tr></table></figure>
<p>2 启动Kibana</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$&#123;KIBANA_HOME&#125;/bin/kibana</div></pre></td></tr></table></figure>
<p>3 使用Kibana连接Elasticsearch</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-5/96019826.jpg" alt=""></p>
<ul>
<li>访问<code>localhost:5601</code>进入Kibana的UI界面</li>
<li>在Kibana中配置Elasticsearch中索引的配置规则，符合配置规则的索引才会在Kibana中搜索到</li>
<li>在Kibana中配置，数据以什么维度进行展示，通常来说设置为时间维度；</li>
<li>在Kibana中点击create按钮创建索引匹配规则；</li>
</ul>
<p>4 在Kibana中搜索日志</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-5/5428734.jpg" alt=""></p>
<p>至此ELK平台搭建完毕。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs.html" target="_blank" rel="external">Elasticsearch官方文档</a></li>
<li><a href="https://www.elastic.co/guide/en/logstash/5.6/index.html" target="_blank" rel="external">Logstash官方文档</a></li>
<li><a href="https://www.elastic.co/guide/en/kibana/5.6/install.html" target="_blank" rel="external">Kibana官方文档</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1 前言&quot;&gt;&lt;/a&gt;1 前言&lt;/h3&gt;&lt;p&gt;不管用于记录、监控，日志对于任何系统来说都是一个极其重要的部分，但一般的日志的数据量会比较大，并且分散在各个地方，当管理的服
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://jianwl.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://jianwl.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite源码分析---作业配置</title>
    <link href="http://jianwl.com/2017/11/01/Elastic-Job-Lite%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BD%9C%E4%B8%9A%E9%85%8D%E7%BD%AE/"/>
    <id>http://jianwl.com/2017/11/01/Elastic-Job-Lite源码分析-作业配置/</id>
    <published>2017-11-01T08:30:37.000Z</published>
    <updated>2017-11-02T09:43:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p>涉及到主要类的类图如下：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-1/79872342.jpg" alt=""></p>
<h3 id="2-作业配置"><a href="#2-作业配置" class="headerlink" title="2 作业配置"></a>2 作业配置</h3><p>一个作业(ElasticJob)的调度，需要配置独有的一个作业调度器(JobScheduler),两者是1:1的关系，这点大家要注意下，当然下文看代码也会看到。</p>
<p>作业调度器的创建可以配置四个参数：</p>
<ol>
<li>注册中心(CoordinatorRegistryCenter): 用于协调分布式服务，必填；</li>
<li>Lite作业配置(LiteJobConfiguration): 必填</li>
<li>作业事件总线(JobEventBus): 对作业事件异步监听。选填</li>
<li>作业监听器(ElasticJobListener): 对作业执行前，执行后进行同步监听。选填</li>
</ol>
<h3 id="2-1-注册中心配置"><a href="#2-1-注册中心配置" class="headerlink" title="2.1 注册中心配置"></a>2.1 注册中心配置</h3><p>Elastic-Job抽象了注册中心接口(RegistryCenter),并提供了基于Zookeeper的注册中心实现(ZookeeperRegistryCenter)。</p>
<p>ZookeeperRegistryCenter对应配置类为ZookeeperConfiguration，该类注释很完整，这里我们重点说下<code>namespace</code>属性。如果你有多个不同Elastic-Job集群时，使用相同Zookeeper，可以配置不同的<code>namespace</code>进行隔离。</p>
<p>注册中心的初始化，我们会在后文<code>Elastic-Job-Lite源码解析---注册中心</code>详细分享。</p>
<h3 id="2-2-Lite作业配置"><a href="#2-2-Lite作业配置" class="headerlink" title="2.2 Lite作业配置"></a>2.2 Lite作业配置</h3><p><code>LiteJobConfiguration</code>继承自接口<code>JobRootConfiguration</code>，作为<code>Elastic-Job-Lite</code>里的作业(LiteJob)配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public final class LiteJobConfiguration implements JobRootConfiguration &#123;</div><div class="line">    private final JobTypeConfiguration typeConfig;</div><div class="line">    private final boolean monitorExecution;</div><div class="line">    private final int maxTimeDiffSeconds;</div><div class="line">    private final int monitorPort;</div><div class="line">    private final String jobShardingStrategyClass;</div><div class="line">    private final int reconcileIntervalMinutes;</div><div class="line">    private final boolean disabled;</div><div class="line">    private final boolean overwrite;</div><div class="line">    </div><div class="line">    // ... 省略部分get方法</div><div class="line">    public static class Builder &#123;</div><div class="line">	    // ... 省略部分属性</div><div class="line">	    public final LiteJobConfiguration build() &#123;</div><div class="line">	            return new LiteJobConfiguration(jobConfig, monitorExecution, maxTimeDiffSeconds, monitorPort, jobShardingStrategyClass, reconcileIntervalMinutes, disabled, overwrite);</div><div class="line">	        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>typeConfig</code>:作业类型配置，必填</li>
<li><code>monitorExecution</code>: 监控作业运行时状态，默认为<code>false</code>，选填。</li>
</ul>
<blockquote>
<p>每次作业执行时间和间隔时间均非常短的情况, 建议不监控作业运行时状态以提升效率, 因为是瞬时状态, 所以无必要监控. 请用户自行增加数据堆积监控. 并且不能保证数据重复选取, 应在作业中实现幂等性. 也无法实现作业失效转移.</p>
<p> 每次作业执行时间和间隔时间均较长短的情况, 建议监控作业运行时状态, 可保证数据不会重复选取.每次作业执行时间和间隔均较长的情况，建议监控作业运行时状态，可保证数据不会重复选取。</p>
</blockquote>
<ul>
<li><code>maxTimeDiffSeconds</code>: 设置最大容忍的本机与注册中心的时间误差秒数。默认为-1，不检查时间误差。选填</li>
<li><code>monitorPort</code>: 作业监控端口，默认为-1，不开启作业监控端口。选填</li>
<li><code>jobShardingStrategyClass</code>：作业分片策略实现类全路径，默认为使用分配侧路。</li>
<li><code>reconcileIntervalMinutes</code>：修复作业服务器不一致状态服务调度间隔时间，配置为小于1的任意值，默认为10.</li>
<li><code>disabled</code>: 作业是否禁用执行。默认为false，选填。</li>
<li><code>overwrite</code>: 设置使用本地配置覆盖注册中心的作业配置。默认为false，选填。建议使用运维平台console配置作业配置，统一管理。</li>
<li>Builder类：使用该类配置LiteJobConfiguration属性，调用<code>#build()</code>方法最终生成作业配置。</li>
</ul>
<h3 id="2-2-1-作业类型配置"><a href="#2-2-1-作业类型配置" class="headerlink" title="2.2.1 作业类型配置"></a>2.2.1 作业类型配置</h3><p>作业类型配置接口(JobTypeConfiguration)有三种配置实现，针对三种作业类型：</p>
<table>
<thead>
<tr>
<th>配置实现</th>
<th>作业</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SimpleJobConfiguration</td>
<td>SimpleJob</td>
<td>简单作业。例如：订单过期作业</td>
</tr>
<tr>
<td>DataflowJobConfiguration</td>
<td>DataflowJob</td>
<td>数据流作业。TODO:暂未了解流式处理数据</td>
</tr>
<tr>
<td>ScriptJobConfiguration</td>
<td>ScriptJob</td>
<td>脚本作业。例如：调用shell脚本备份数据库作业</td>
</tr>
</tbody>
</table>
<p>三种配置类属性对比如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">SimpleJob</th>
<th style="text-align:center">DataflowJob</th>
<th style="text-align:center">ScriptJob</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">coreConfig</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">作业核心配置</td>
</tr>
<tr>
<td style="text-align:center">jobType</td>
<td style="text-align:center">JobType.SIMPLE</td>
<td style="text-align:center">JobType.DATAFLOW</td>
<td style="text-align:center">JobType.SCRIPT</td>
<td style="text-align:center">作业类型</td>
</tr>
<tr>
<td style="text-align:center">jobClass</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️(默认：ScriptJob.class)</td>
<td style="text-align:center">作业实现类全路径</td>
</tr>
<tr>
<td style="text-align:center">streamingProcess</td>
<td style="text-align:center"></td>
<td style="text-align:center">✔️</td>
<td style="text-align:center"></td>
<td style="text-align:center">是否流式处理数据</td>
</tr>
<tr>
<td style="text-align:center">scriptCommandLine</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">脚本型作业执行命令行</td>
</tr>
</tbody>
</table>
<h3 id="2-2-2-作业核心配置"><a href="#2-2-2-作业核心配置" class="headerlink" title="2.2.2 作业核心配置"></a>2.2.2 作业核心配置</h3><p>作业核心配置(JobCoreConfiguration),我们可以看到在每种作业类型配置都有该属性(<code>coreConfig</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public final class JobCoreConfiguration &#123;</div><div class="line">    private final String jobName;</div><div class="line">    private final String cron;</div><div class="line">    private final int shardingTotalCount;</div><div class="line">    private final String shardingItemParameters;</div><div class="line">    private final String jobParameter;</div><div class="line">    private final boolean failover;</div><div class="line">    private final boolean misfire;</div><div class="line">    private final String description;</div><div class="line">    private final JobProperties jobProperties;</div><div class="line">    </div><div class="line">    // ... 省略Getter方法</div><div class="line">    public static class Builder &#123;</div><div class="line">    </div><div class="line">	    // ... 省略部分属性</div><div class="line">	    public final JobCoreConfiguration build() &#123;</div><div class="line">	            Preconditions.checkArgument(!Strings.isNullOrEmpty(jobName), &quot;jobName can not be empty.&quot;);</div><div class="line">	            Preconditions.checkArgument(!Strings.isNullOrEmpty(cron), &quot;cron can not be empty.&quot;);</div><div class="line">	            Preconditions.checkArgument(shardingTotalCount &gt; 0, &quot;shardingTotalCount should larger than zero.&quot;);</div><div class="line">	            return new JobCoreConfiguration(jobName, cron, shardingTotalCount, shardingItemParameters, jobParameter, failover, misfire, description, jobProperties);</div><div class="line">	        &#125;</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>jobName</code>: 作业名称。必填</li>
<li><code>cron</code>: cron表达式，用于控制作业触发时间。必填</li>
<li><code>shardingTotalCount</code>: 作业分片总数，如果一个作业启动超过作业分片总数的节点，只有<code>shardingTotalCount</code>会执行作业。必填</li>
<li><code>shardingItemParameters</code>: 分片序列号和参数</li>
</ul>
<blockquote>
<p>分片序列号和参数用等号分隔，多个键值对用逗号分隔<br>分片序列号从0开始，不可大于或等于分片总数<br>如: 0=a,1=b,2=c</p>
</blockquote>
<ul>
<li><code>jobParameter</code>: 作业自定义参数，选填</li>
</ul>
<blockquote>
<p>作业自定义参数，可通过传递该参数为作业调度的业务方法传参，用于实现带参数的作业</p>
<p>例: 每次获取的数据量、作业实例从数据库读取的主键</p>
</blockquote>
<ul>
<li><code>failover</code>: 是否开启作业执行失效转移，开启表示如果作业在一次作业执行中途宕机，允许将该次未完成的作业在另一作业节点上补偿执行。默认为false。选填</li>
<li><code>misfire</code>: 是否开启错误作业重新执行，默认为true.选填</li>
<li><code>description</code>: 作业描述，选填。</li>
<li><code>jobProperties</code>: 作业属性配置，选填。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public final class JobProperties &#123;</div><div class="line">    </div><div class="line">    private EnumMap&lt;JobPropertiesEnum, String&gt; map = new EnumMap&lt;&gt;(JobPropertiesEnum.class);</div><div class="line"></div><div class="line">	public enum JobPropertiesEnum &#123;</div><div class="line">	        </div><div class="line">	        /**</div><div class="line">	         * 作业异常处理器.</div><div class="line">	         */</div><div class="line">	        JOB_EXCEPTION_HANDLER(&quot;job_exception_handler&quot;, JobExceptionHandler.class, DefaultJobExceptionHandler.class.getCanonicalName()),</div><div class="line">	        </div><div class="line">	        /**</div><div class="line">	         * 线程池服务处理器.</div><div class="line">	         */</div><div class="line">	        EXECUTOR_SERVICE_HANDLER(&quot;executor_service_handler&quot;, ExecutorServiceHandler.class, DefaultExecutorServiceHandler.class.getCanonicalName());</div><div class="line">	        </div><div class="line">	        private final String key;</div><div class="line">	    </div><div class="line">	        private final Class&lt;?&gt; classType;</div><div class="line">	        </div><div class="line">	        private final String defaultValue;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>JOB_EXCEPTION_HANDLER</code>: 用于扩展异常处理类</li>
<li><code>EXECUTOR_SERVICE_HANDLER</code>: 用于扩展作业处理线程池类</li>
<li>通过这个属性，我们可以自定义每个作业的异常处理和线程池服务</li>
</ul>
<h3 id="2-3-作业事件配置"><a href="#2-3-作业事件配置" class="headerlink" title="2.3 作业事件配置"></a>2.3 作业事件配置</h3><p>通过作业事件配置（<code>JobEventConfiguration</code>）,实现对作业事件的异步监听、处理。在<code>Elastic-Job-Lite源码解析 --- 作业事件追踪</code> 详细分享</p>
<h3 id="2-4-作业监听器"><a href="#2-4-作业监听器" class="headerlink" title="2.4 作业监听器"></a>2.4 作业监听器</h3><p>通过配置作业监听器（<code>ElasticJobListener</code>）,实现对作业执行的同步监听、处理。<code>Elastic-Job-Lite源码解析 --- 作业监听器</code>详细分享</p>
<h3 id="3-作业配置服务"><a href="#3-作业配置服务" class="headerlink" title="3 作业配置服务"></a>3 作业配置服务</h3><p>多个Elastic-Job-Lite使用相同注册中心和相同<code>namespace</code>组成集群，实现高可用。集群中，使用作业配置服务（<code>ConfigurationService</code>）共享作业配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final class ConfigurationService &#123;</div><div class="line">    </div><div class="line">    private final TimeService timeService;</div><div class="line">    </div><div class="line">    private final JobNodeStorage jobNodeStorage;</div><div class="line">    </div><div class="line">    public ConfigurationService(final CoordinatorRegistryCenter regCenter, final String jobName) &#123;</div><div class="line">        jobNodeStorage = new JobNodeStorage(regCenter, jobName);</div><div class="line">        timeService = new TimeService();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>timeService</code>: 时间服务，提供当前时间查询</li>
<li><code>jobNodeStorage</code>: 封装注册中心，提供存储服务。<code>Elastic-Job-Lite源码解析 --- 作业数据存储</code>详细分享</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final class TimeService &#123;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 获取当前时间的毫秒数.</div><div class="line">     * </div><div class="line">     * @return 当前时间的毫秒数</div><div class="line">     */</div><div class="line">    public long getCurrentMillis() &#123;</div><div class="line">        return System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-1-读取作业配置"><a href="#3-1-读取作业配置" class="headerlink" title="3.1 读取作业配置"></a>3.1 读取作业配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * 读取作业配置.</div><div class="line">    * </div><div class="line">    * @param fromCache 是否从缓存中读取</div><div class="line">    * @return 作业配置</div><div class="line">    */</div><div class="line">   public LiteJobConfiguration load(final boolean fromCache) &#123;</div><div class="line">       String result;</div><div class="line">       if (fromCache) &#123;</div><div class="line">           result = jobNodeStorage.getJobNodeData(ConfigurationNode.ROOT);</div><div class="line">           if (null == result) &#123;</div><div class="line">               result = jobNodeStorage.getJobNodeDataDirectly(ConfigurationNode.ROOT);</div><div class="line">           &#125;</div><div class="line">       &#125; else &#123;</div><div class="line">           result = jobNodeStorage.getJobNodeDataDirectly(ConfigurationNode.ROOT);</div><div class="line">       &#125;</div><div class="line">       return LiteJobConfigurationGsonFactory.fromJson(result);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-持久化作业配置"><a href="#3-2-持久化作业配置" class="headerlink" title="3.2 持久化作业配置"></a>3.2 持久化作业配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">  * 持久化分布式作业配置信息.</div><div class="line">  * </div><div class="line">  * @param liteJobConfig 作业配置</div><div class="line">  */</div><div class="line"> public void persist(final LiteJobConfiguration liteJobConfig) &#123;</div><div class="line">     checkConflictJob(liteJobConfig);</div><div class="line">     if (!jobNodeStorage.isJobNodeExisted(ConfigurationNode.ROOT) || liteJobConfig.isOverwrite()) &#123;</div><div class="line">         jobNodeStorage.replaceJobNode(ConfigurationNode.ROOT, LiteJobConfigurationGsonFactory.toJson(liteJobConfig));</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#checkConflictJob(...)</code>方法校验注册中心存储的作业配置的作业实现类全路径（<code>jobClass</code>）和当前的是否相同，如果不同，则认为是冲突，不允许存储：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private void checkConflictJob(final LiteJobConfiguration liteJobConfig) &#123;</div><div class="line">        Optional&lt;LiteJobConfiguration&gt; liteJobConfigFromZk = find();</div><div class="line">        if (liteJobConfigFromZk.isPresent() &amp;&amp; !liteJobConfigFromZk.get().getTypeConfig().getJobClass().equals(liteJobConfig.getTypeConfig().getJobClass())) &#123;</div><div class="line">            throw new JobConfigurationException(&quot;Job conflict with register center. The job &apos;%s&apos; in register center&apos;s class is &apos;%s&apos;, your job class is &apos;%s&apos;&quot;, </div><div class="line">                    liteJobConfig.getJobName(), liteJobConfigFromZk.get().getTypeConfig().getJobClass(), liteJobConfig.getTypeConfig().getJobClass());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>当注册中心未存储该作业配置或者当前作业配置允许替换注册中心配置(<code>overwrite = true</code>)时，持久化作业配置。</li>
</ul>
<h3 id="3-3-校验本机时间是否合法"><a href="#3-3-校验本机时间是否合法" class="headerlink" title="3.3 校验本机时间是否合法"></a>3.3 校验本机时间是否合法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 检查本机与注册中心的时间误差秒数是否在允许范围.</div><div class="line">     * </div><div class="line">     * @throws JobExecutionEnvironmentException 本机与注册中心的时间误差秒数不在允许范围所抛出的异常</div><div class="line">     */</div><div class="line">    public void checkMaxTimeDiffSecondsTolerable() throws JobExecutionEnvironmentException &#123;</div><div class="line">        int maxTimeDiffSeconds =  load(true).getMaxTimeDiffSeconds();</div><div class="line">        if (-1  == maxTimeDiffSeconds) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        long timeDiff = Math.abs(timeService.getCurrentMillis() - jobNodeStorage.getRegistryCenterTime());</div><div class="line">        if (timeDiff &gt; maxTimeDiffSeconds * 1000L) &#123;</div><div class="line">            throw new JobExecutionEnvironmentException(</div><div class="line">                    &quot;Time different between job server and register center exceed &apos;%s&apos; seconds, max time different is &apos;%s&apos; seconds.&quot;, timeDiff / 1000, maxTimeDiffSeconds);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>Elastic-Job-Lite</code>作业触发时依赖本机时间，相同集群使用注册中心为基准，校验本机与注册中心的时间误差是否在允许范围内<code>LiteJobConfiguration.maxTimeDiffSeconds</code></li>
</ul>
<h3 id="4-结语"><a href="#4-结语" class="headerlink" title="4 结语"></a>4 结语</h3><p>这篇文章写作思路是参考别人的，通过这篇文章我提炼出，阅读源码几点技巧：</p>
<ul>
<li>从一个点切入，找到这个点的入口；</li>
<li>按照作者编码的思路去思考，抓住主线，一个个类去梳理</li>
<li>擅加利用IDEA的查看接口实现类的功能；如下展示：</li>
</ul>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-2/35421199.jpg" alt=""></p>
<ul>
<li>从官方文档上，了解到项目有哪些功能，带着问题去看源码；列出你想要了解的功能，一个个去学习；</li>
<li>以类图来梳理整个功能的逻辑，了解每个类，每个属性的含义，而又不会深入到每个方法的具体实现细节。</li>
<li>一次只讨论一个点，每次学习都有一个重心；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h3&gt;&lt;p&gt;涉及到主要类的类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.clouddn.com
    
    </summary>
    
      <category term="ElasticJob" scheme="http://jianwl.com/categories/ElasticJob/"/>
    
    
      <category term="ElasticJob" scheme="http://jianwl.com/tags/ElasticJob/"/>
    
  </entry>
  
  <entry>
    <title>Elastic-Job源码分析---为什么阅读Elastic-Job源码</title>
    <link href="http://jianwl.com/2017/11/01/Elastic-Job%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%85%E8%AF%BBElastic-Job%E6%BA%90%E7%A0%81/"/>
    <id>http://jianwl.com/2017/11/01/Elastic-Job源码分析-为什么阅读Elastic-Job源码/</id>
    <published>2017-11-01T07:25:05.000Z</published>
    <updated>2017-11-01T08:07:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么阅读源码Elastic-Job源码"><a href="#为什么阅读源码Elastic-Job源码" class="headerlink" title="为什么阅读源码Elastic-Job源码"></a>为什么阅读源码Elastic-Job源码</h3><ol>
<li>Quartz多节点通过数据库锁实现任务抢占，Elastic-Job基于什么策略实现任务调度与分配</li>
<li>任务分片如何实现</li>
<li><code>Elastic-Job-Cloud</code>如何实现任务动态扩容和缩容</li>
<li>任务超时如何处理？任务假死怎么判断？</li>
</ol>
<h3 id="步骤-功能"><a href="#步骤-功能" class="headerlink" title="步骤/功能"></a>步骤/功能</h3><ul>
<li>【】分布式调度协调</li>
<li>【】弹性扩容缩容</li>
<li>【】失效转移</li>
<li>【】错过执行作业重触发</li>
<li>【】作业分片策略</li>
<li>【】作业唯一节点执行</li>
<li>【】自诊断并修复分布式不稳定造成的问题</li>
<li>【】支持并行调度</li>
<li>【】支持作业生命周期操作</li>
<li>【】丰富的作业类型</li>
<li>【】Spring整合以及命名空间提供</li>
<li>【】运维平台</li>
<li>【】事件追踪</li>
<li>【】DUMP作业运行信息</li>
<li>【】作业监听器</li>
<li>【】基于Docker的进程隔离（TBD）</li>
<li>【】高可用</li>
</ul>
<h3 id="XXL-JOB"><a href="#XXL-JOB" class="headerlink" title="XXL-JOB"></a>XXL-JOB</h3><p>基于V1.8，会逐步和Elastic-Job功能做对比</p>
<ul>
<li>【】简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手</li>
<li>【】动态：支持动态修改任务状态、暂停/恢复任务、以及终止运行中任务，即时生效；</li>
<li>【】调度中心HA（中心式）：调度采用中心式设计，调度中心基于集群Quartz实现可保证调度中心HA</li>
<li>【】执行器HA（分布式）：任务分布式执行，任务执行器支持集群部署，可保证任务执行HA</li>
<li>【】任务Failover:执行器集群部署时，任务路由策略选择故障转移情况下，调度失败时将会平滑切换执行器进行Failover；</li>
<li>【】一致性：调度中心通过DB锁保证集群分布式调度的一致性，一次任务调度只会触发一次执行；</li>
<li>【】自定义任务参数：支持在线配置调度任务入参，即时生效；</li>
<li>【】调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被阻塞；</li>
<li>【】弹性扩容缩容：一旦有新执行器机器上线或下线，下次调度时将会重新分配任务</li>
<li>【】邮件报警：任务失败时支持邮件报警，支持配置多邮件群发报警邮件</li>
<li>【】状态监控：支持实时监控任务进度</li>
<li>【】Rolling执行日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志</li>
<li>【】GLUE：提供Web IDE,支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程，支持30个版本的历史版本回溯</li>
<li>【】数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性</li>
<li>【】任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会触发一次子任务的执行，多个子任务用逗号分隔；</li>
<li>【】推送maven中央库：将会把最新稳定版本推送到maven中央库，方便用户接入和使用；</li>
<li>【】任务注册：执行器会周期性自动注册任务，调度中心将会自动发现注册的任务并触发执行，同时也支持手动录入执行器地址；</li>
<li>【】路由策略：执行器集群部署时提供丰富的路由策略，包括第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近未使用、故障转移、忙碌转移等；</li>
<li>【】运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器次数等、以及调度报表，如调度日期分布图、调度成功分布图等；</li>
<li>【】脚本任务：支持以GLUE模式开发和运行脚本任务，包括shell、python等类型脚本；</li>
<li>【】阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度、</li>
<li>【】处理失败策略：调度失败时的处理策略，策略包括：失败告警（默认）、失败重试</li>
<li>【】分片广播任务：执行器集群部署时，任务路由策略选择分片广播情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务、同时传递分片参数、可根据分片参数分片开发任务；</li>
<li>【】动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理，在进行大数量业务操作是，可显著提升任务处理能力和速度。</li>
<li>【】事件触发：除了Cron方法和任务依赖方式触发任务执行之外，支持基于事件的触发任务方式，调度中心提供触发任务单次执行的API服务，可根据业务事件灵活触发。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么阅读源码Elastic-Job源码&quot;&gt;&lt;a href=&quot;#为什么阅读源码Elastic-Job源码&quot; class=&quot;headerlink&quot; title=&quot;为什么阅读源码Elastic-Job源码&quot;&gt;&lt;/a&gt;为什么阅读源码Elastic-Job源码&lt;/h3&gt;&lt;
    
    </summary>
    
      <category term="ElasticJob" scheme="http://jianwl.com/categories/ElasticJob/"/>
    
    
      <category term="ElasticJob" scheme="http://jianwl.com/tags/ElasticJob/"/>
    
  </entry>
  
  <entry>
    <title>ElasticJob入门实战</title>
    <link href="http://jianwl.com/2017/11/01/ElasticJob%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/"/>
    <id>http://jianwl.com/2017/11/01/ElasticJob入门实战/</id>
    <published>2017-11-01T03:31:58.000Z</published>
    <updated>2017-11-01T04:42:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h3><p><code>ElasticJob</code>是一个分布式调度解决方案，由两个互相独立的子项目<code>Elastic-Job-Lite</code>和<code>Elastic-Job-Cloud</code>组成。<code>Elastic-Job-Lite</code>定位为轻量级无中心化解决方案，使用jar包形式提供分布式的协调服务。这一节我们将会介绍SpringBoot整合ElasticJob。</p>
<h3 id="2、SpringBoot整合ElasticJob"><a href="#2、SpringBoot整合ElasticJob" class="headerlink" title="2、SpringBoot整合ElasticJob"></a>2、SpringBoot整合ElasticJob</h3><h4 id="1）依赖pom-xml"><a href="#1）依赖pom-xml" class="headerlink" title="1）依赖pom.xml"></a>1）依赖pom.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">	&lt;groupId&gt;com.frank&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;chapter6-4&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">	&lt;packaging&gt;jar&lt;/packaging&gt;</div><div class="line"></div><div class="line">	&lt;name&gt;chapter6-4&lt;/name&gt;</div><div class="line">	&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</div><div class="line"></div><div class="line">	&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.4.2.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.8&lt;/java.version&gt;</div><div class="line">		&lt;elastic.job.version&gt;2.1.5&lt;/elastic.job.version&gt;</div><div class="line">		&lt;mysql.version&gt;5.1.43&lt;/mysql.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;com.dangdang&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;elastic-job-lite-core&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;$&#123;elastic.job.version&#125;&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;com.dangdang&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;elastic-job-lite-spring&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;$&#123;elastic.job.version&#125;&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;curator-test&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;4.0.0&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;com.h2database&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;h2&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;1.4.184&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</div><div class="line">			&lt;optional&gt;true&lt;/optional&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;test&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div><div class="line"></div><div class="line">	&lt;build&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/build&gt;</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<h4 id="2）注册中心配置"><a href="#2）注册中心配置" class="headerlink" title="2）注册中心配置"></a>2）注册中心配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">@ConditionalOnExpression(&quot;&apos;$&#123;regCenter.serverList&#125;&apos;.length()&gt;0&quot;)</div><div class="line">public class ZookeeperRegistryCenterConfig &#123;</div><div class="line">    @Bean(initMethod = &quot;init&quot;)</div><div class="line">    public ZookeeperRegistryCenter regCenter(@Value(&quot;$&#123;regCenter.serverList&#125;&quot;) final String serverList,</div><div class="line">                                             @Value(&quot;$&#123;regCenter.namespace&#125;&quot;) final String namespace)&#123;</div><div class="line">        return new ZookeeperRegistryCenter(new ZookeeperConfiguration(serverList,namespace));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-作业事件配置"><a href="#3-作业事件配置" class="headerlink" title="3) 作业事件配置"></a>3) 作业事件配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class JobEventConfig &#123;</div><div class="line"></div><div class="line">    @Resource</div><div class="line">    private DataSource dataSource;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public JobEventConfiguration jobEventConfiguration() &#123;</div><div class="line">        return new JobEventRdbConfiguration(dataSource);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-内嵌Zookeeper配置"><a href="#4-内嵌Zookeeper配置" class="headerlink" title="4) 内嵌Zookeeper配置"></a>4) 内嵌Zookeeper配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class EmbedZookeeperServer &#123;</div><div class="line">    private static TestingServer testingServer;</div><div class="line"></div><div class="line">    public static void start(final int port)&#123;</div><div class="line">        try&#123;</div><div class="line">            testingServer = new TestingServer(port,new File(String.format(&quot;target/test_zk_data/%s/&quot;,System.nanoTime())));</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;finally &#123;</div><div class="line">            Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123;</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(1000L);</div><div class="line">                    testingServer.close();</div><div class="line">                &#125; catch (InterruptedException | IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-基于时间驱动的任务"><a href="#5-基于时间驱动的任务" class="headerlink" title="5) 基于时间驱动的任务"></a>5) 基于时间驱动的任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class SpringSimpleJob implements SimpleJob&#123;</div><div class="line"></div><div class="line">    @Resource</div><div class="line">    private FooRepository fooRepository;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void execute(ShardingContext shardingContext) &#123;</div><div class="line">        System.out.println(String.format(&quot;Item: %s | Time: %s | Thread: %s | %s&quot;,</div><div class="line">                shardingContext.getShardingItem(), new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()), Thread.currentThread().getId(), &quot;SIMPLE&quot;));</div><div class="line">        List&lt;Foo&gt; data = fooRepository.findTodoData(shardingContext.getShardingParameter(), 10);</div><div class="line">        for (Foo each : data) &#123;</div><div class="line">            fooRepository.setCompleted(each.getId());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>模型类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class Foo implements Serializable&#123;</div><div class="line">    private final long id;</div><div class="line">    private final String location;</div><div class="line">    private Status status;</div><div class="line"></div><div class="line">    public Foo(long id, String location, Status status) &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.location = location;</div><div class="line">        this.status = status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public long getId() &#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getLocation() &#123;</div><div class="line">        return location;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Status getStatus() &#123;</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setStatus(Status status) &#123;</div><div class="line">        this.status = status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;Foo&#123;&quot; +</div><div class="line">                &quot;id=&quot; + id +</div><div class="line">                &quot;, location=&apos;&quot; + location + &apos;\&apos;&apos; +</div><div class="line">                &quot;, status=&quot; + status +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public enum Status&#123;</div><div class="line">        TODO,</div><div class="line">        COMPLETED</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Repository</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@Repository</div><div class="line">public class FooRepository &#123;</div><div class="line">    private Map&lt;Long,Foo&gt; data = new ConcurrentHashMap&lt;&gt;(300,1);</div><div class="line"></div><div class="line">    public FooRepository()&#123;init();&#125;</div><div class="line"></div><div class="line">    private void init()&#123;</div><div class="line">        addData(0L, 100L, &quot;Beijing&quot;);</div><div class="line">        addData(100L, 200L, &quot;Shanghai&quot;);</div><div class="line">        addData(200L, 300L, &quot;Guangzhou&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void addData(final Long idFrom,final Long idTo,final String location)&#123;</div><div class="line">        for(long i=idFrom; i &lt; idTo; i++) &#123;</div><div class="line">            data.put(i,new Foo(i,location,Foo.Status.TODO));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public List&lt;Foo&gt; findTodoData(final String location, final int limit) &#123;</div><div class="line">        List&lt;Foo&gt; result = new ArrayList&lt;&gt;(limit);</div><div class="line">        int count = 0;</div><div class="line">        for (Map.Entry&lt;Long, Foo&gt; each : data.entrySet()) &#123;</div><div class="line">            Foo foo = each.getValue();</div><div class="line">            if (foo.getLocation().equals(location) &amp;&amp; foo.getStatus() == Foo.Status.TODO) &#123;</div><div class="line">                result.add(foo);</div><div class="line">                count++;</div><div class="line">                if (count == limit) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCompleted(final long id) &#123;</div><div class="line">        data.get(id).setStatus(Foo.Status.COMPLETED);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-任务注册"><a href="#6-任务注册" class="headerlink" title="6) 任务注册"></a>6) 任务注册</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class SimpleJobConfig &#123;</div><div class="line"></div><div class="line">    @Resource</div><div class="line">    private ZookeeperRegistryCenter regCenter;</div><div class="line"></div><div class="line">    @Resource</div><div class="line">    private JobEventConfiguration jobEventConfiguration;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public SimpleJob simpleJob()&#123;</div><div class="line">        return new SpringSimpleJob();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean(initMethod = &quot;init&quot;)</div><div class="line">    public JobScheduler simpleJobScheduler(final SimpleJob simpleJob, @Value(&quot;$&#123;simpleJob.cron&#125;&quot;) final String cron,</div><div class="line">                                           @Value(&quot;$&#123;simpleJob.shardingTotalCount&#125;&quot;) final int shardingTotalCount,</div><div class="line">                                           @Value(&quot;$&#123;simpleJob.shardingItemParameters&#125;&quot;) final String shardingItemParameters)&#123;</div><div class="line">        return new SpringJobScheduler(simpleJob, regCenter, getLiteJobConfiguration(simpleJob.getClass(), cron, shardingTotalCount, shardingItemParameters), jobEventConfiguration);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private LiteJobConfiguration getLiteJobConfiguration(final Class&lt;? extends SimpleJob&gt; jobClass, final String cron, final int shardingTotalCount, final String shardingItemParameters) &#123;</div><div class="line">        return LiteJobConfiguration.newBuilder(new SimpleJobConfiguration(JobCoreConfiguration.newBuilder(</div><div class="line">                jobClass.getName(), cron, shardingTotalCount).shardingItemParameters(shardingItemParameters).build(), jobClass.getCanonicalName())).overwrite(true).build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-入口类"><a href="#7-入口类" class="headerlink" title="7) 入口类"></a>7) 入口类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">public class Chapter64Application &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		EmbedZookeeperServer.start(6181); // 启动内嵌zookeeper</div><div class="line">		SpringApplication.run(Chapter64Application.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="8-参数配置application-properties"><a href="#8-参数配置application-properties" class="headerlink" title="8) 参数配置application.properties"></a>8) 参数配置application.properties</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">regCenter.serverList=localhost:6181</div><div class="line">regCenter.namespace=elastic-job-lite-springboot</div><div class="line"></div><div class="line">simpleJob.cron=0/30 * * * * ?</div><div class="line">simpleJob.shardingTotalCount=3</div><div class="line">simpleJob.shardingItemParameters=0=Beijing,1=Shanghai,2=Guangzhou</div><div class="line"></div><div class="line">spring.datasource.url=jdbc:h2:mem:job_event_storage</div><div class="line">spring.datasource.driver-class-name=org.h2.Driver</div><div class="line">spring.datasource.username=sa</div><div class="line">spring.datasource.password=</div></pre></td></tr></table></figure>
<h4 id="9-项目源码请移步：SpringBoot整合ElasticJob"><a href="#9-项目源码请移步：SpringBoot整合ElasticJob" class="headerlink" title="9) 项目源码请移步：SpringBoot整合ElasticJob"></a>9) 项目源码请移步：<a href="https://github.com/frank-jian/SpringBootDemo/tree/master/chapter6-4" target="_blank" rel="external">SpringBoot整合ElasticJob</a></h4><h3 id="3、elastic-job-lite-console界面中配置注册中心"><a href="#3、elastic-job-lite-console界面中配置注册中心" class="headerlink" title="3、elastic-job-lite-console界面中配置注册中心"></a>3、<a href="https://github.com/elasticjob/elastic-job/blob/master/elastic-job-lite/elastic-job-lite-console/src/main/java/com/dangdang/ddframe/job/lite/console/ConsoleBootstrap.java" target="_blank" rel="external">elastic-job-lite-console</a>界面中配置注册中心</h3><p>1、启动<a href="https://github.com/elasticjob/elastic-job/blob/master/elastic-job-lite/elastic-job-lite-console/src/main/java/com/dangdang/ddframe/job/lite/console/ConsoleBootstrap.java" target="_blank" rel="external">ConsoleBootstrap.java</a>类，输入账号：root，密码：root</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-1/62773298.jpg" alt=""></p>
<p>2、启动步骤2中SpringBoot整合的ElasticJob项目，在<code>elastic-job-lite-console</code>界面中配置注册中心地址；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-1/48589935.jpg" alt=""></p>
<p>3、连接注册中心</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-1/20731156.jpg" alt=""></p>
<p>4、获取注册中心的任务(另外一个任务文章没有提及注册流程，具体可以看<a href="https://github.com/frank-jian/SpringBootDemo/tree/master/chapter6-4" target="_blank" rel="external">项目源码</a>)</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-1/54676368.jpg" alt=""></p>
<p>5、触发任务</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-1/11175796.jpg" alt=""></p>
<h3 id="4、结语"><a href="#4、结语" class="headerlink" title="4、结语"></a>4、结语</h3><p>至此，已经简单介绍了ElasticJob的用法，后续会深入ElasticJob源码学习，深入理解其各个特性实现的思想；</p>
<h3 id="5、参考资料"><a href="#5、参考资料" class="headerlink" title="5、参考资料"></a>5、参考资料</h3><ol>
<li><a href="http://elasticjob.io/index_zh.html" target="_blank" rel="external">Elastic-Job官方文档</a></li>
<li><a href="https://github.com/elasticjob/elastic-job" target="_blank" rel="external">Elastic-Job源码</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、引言&quot;&gt;&lt;a href=&quot;#1、引言&quot; class=&quot;headerlink&quot; title=&quot;1、引言&quot;&gt;&lt;/a&gt;1、引言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ElasticJob&lt;/code&gt;是一个分布式调度解决方案，由两个互相独立的子项目&lt;code&gt;Elastic-J
    
    </summary>
    
      <category term="ElasticJob" scheme="http://jianwl.com/categories/ElasticJob/"/>
    
    
      <category term="ElasticJob" scheme="http://jianwl.com/tags/ElasticJob/"/>
    
  </entry>
  
</feed>
