<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录点滴成长</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianwl.com/"/>
  <updated>2017-04-25T00:49:32.000Z</updated>
  <id>http://jianwl.com/</id>
  
  <author>
    <name>流云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法基础学习笔记</title>
    <link href="http://jianwl.com/2017/04/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://jianwl.com/2017/04/25/算法基础学习笔记/</id>
    <published>2017-04-25T00:35:06.000Z</published>
    <updated>2017-04-25T00:49:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>算法一篇空白，大学所学忘的差不多了，接下来几周会侧重学习算法基础。</p>
<h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1. 排序"></a>1. 排序</h3><h4 id="1-领居好说话-–-冒泡算法"><a href="#1-领居好说话-–-冒泡算法" class="headerlink" title="1) 领居好说话 – 冒泡算法"></a>1) 领居好说话 – 冒泡算法</h4><p><code>基本思想：</code> 每次比较两个相邻的元素，如果他们的顺序错误就把他们交换过来；每一趟只能确定将一个数归位。如<code>12 35 99 18 76</code>这5个数，第一趟确定最大的数排在第1位，第二趟确定第二大的数排在第二位，5个数字，只需要5趟，就能够排好序。</p>
<p><img src="http://i4.buimg.com/567571/c604fc4bd2fa1fa5.png" alt=""></p>
<p><code>实战</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test_001()&#123;</div><div class="line">    int[] nums = new int[]&#123;12,35,99,18,76&#125;;</div><div class="line">    // 第一层: 待排序数[0,n-2]</div><div class="line">    for (int i = 0; i &lt; nums.length - 1; i++) &#123;</div><div class="line">        // 第二层: 未排序数[i,n-1]</div><div class="line">       for (int j = i; j&lt; nums.length -1; j++) &#123;</div><div class="line">           // 待排序数 VS 未排序数, 比其小则交换</div><div class="line">           if (nums[i] &lt; nums[j+1]) &#123;</div><div class="line">               int t = nums[i];</div><div class="line">               nums[i] = nums[j+1];</div><div class="line">               nums[j+1] = t;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    System.out.println(JSON.toJSONString(nums));</div><div class="line">&#125;</div><div class="line">// 结果 [99,76,35,18,12]</div><div class="line">// 时间复杂度 O(N^2)</div></pre></td></tr></table></figure>
<h4 id="2-最常用的排序-–-快速排序"><a href="#2-最常用的排序-–-快速排序" class="headerlink" title="2) 最常用的排序 – 快速排序"></a>2) 最常用的排序 – 快速排序</h4><p><code>基本思想：</code> 以序列<code>6 1 2 7 9 3 4 5 10 8</code>为例，分别从序列两端探测，先<strong>从右到左</strong>找一个小于6的数，找到之后，停止前进的步伐，再<strong>从左到右</strong>找一个大于6的数，然后交换他们。这里可以用变量i和变量j来表示，知道变量i和变量j相遇,完成第一次排序；</p>
<p><img src="http://i2.muimg.com/567571/e31ef94b0d159921.png" alt=""></p>
<p><code>整个算法处理过程：</code></p>
<p><img src="http://i2.muimg.com/567571/1db0b8aba2e48ad7.png" alt=""></p>
<p><code>实战</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public void quick(Integer[] str) &#123;</div><div class="line">    if (str.length &gt; 0) &#123;    //查看数组是否为空</div><div class="line">        _quickSort(str, 0, str.length - 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">private void _quickSort(Integer[] list, int low, int high) &#123;</div><div class="line">    if (low &lt; high) &#123;</div><div class="line">        int middle = _getMiddle(list, low, high);  //将list数组进行一分为二</div><div class="line">        _quickSort(list, low, middle - 1);        //对低字表进行递归排序</div><div class="line">        _quickSort(list, middle + 1, high);       //对高字表进行递归排序</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">private int _getMiddle(Integer[] list, int low, int high) &#123;</div><div class="line">    int tmp = list[low];   //数组的第一个作为中轴</div><div class="line">    while (low &lt; high) &#123;</div><div class="line">        while (low &lt; high &amp;&amp; list[high] &gt; tmp) &#123;</div><div class="line">            high--;</div><div class="line">        &#125;</div><div class="line">        list[low] = list[high];   //比中轴小的记录移到低端</div><div class="line">        while (low &lt; high &amp;&amp; list[low] &lt; tmp) &#123;</div><div class="line">            low++;</div><div class="line">        &#125;</div><div class="line">        list[high] = list[low];   //比中轴大的记录移到高端</div><div class="line">    &#125;</div><div class="line">    list[low] = tmp;              //中轴记录到尾</div><div class="line">    return low;                   //返回中轴的位置</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 时间复杂度: O(NlogN)</div></pre></td></tr></table></figure>
<h3 id="2-队列、栈、链表"><a href="#2-队列、栈、链表" class="headerlink" title="2. 队列、栈、链表"></a>2. 队列、栈、链表</h3><h4 id="1-解密QQ号-–-队列"><a href="#1-解密QQ号-–-队列" class="headerlink" title="1) 解密QQ号 – 队列"></a>1) 解密QQ号 – 队列</h4><p><code>基本思想：</code> <strong>先进先出</strong>的数据结构，队尾进入，队首出去。</p>
<p><code>场景：</code>新学期开始了，小哈是小哼的新同桌，小哼向小哈询问QQ号，小哈给小哼一串加密过的数字，同时告诉小哼解密规则：将第1个数删除、紧接着将第2个数放到这串数的末尾，再将第三个数删除并将第4个数放到这串数字的末尾，再将第5个数删除….直到剩下最后一个数，将最后一个数也删除。最后将删除的数连在一起就是小哈的QQ。加密的数字为「6 3 1 7 5 8 9 2 4」</p>
<p><code>解题思路：</code> 解密第一步是将第一个数删除，如何在数组中删除一个数呢？最简单的办法是将所有后面的数都往前挪一步，将前面的数覆盖，但这样的做法太耗时了。在这里我们将引入两个变量，head用来记录队列的队首，tail用来记录队列的队尾的下一个位置。为什么tail不直接记录队尾呢，却要记录队尾的下一个位置呢？因为当队列中只剩下一个元素时，队首和队尾重合会带来一些麻烦。</p>
<p><code>解密过程：</code></p>
<p><img src="http://i1.piimg.com/567571/1bb74389d2320537.png" alt=""></p>
<p><code>实战:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test_002()&#123;</div><div class="line">    // init</div><div class="line">    int nums[] = new int[102];</div><div class="line">    List&lt;Integer&gt; initNums = Arrays.asList(6,3,1,7,5,8,9,2,4);</div><div class="line">    for(int i = 0; i &lt; initNums.size(); i ++) &#123;</div><div class="line">        nums[i] = initNums.get(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int head = 0;</div><div class="line">    int tail = initNums.size();</div><div class="line">    while (head &lt; tail) &#123;</div><div class="line">        System.out.print(nums[head] + &quot; &quot;);</div><div class="line">        head ++;</div><div class="line">        nums[tail] = nums[head];</div><div class="line">        tail ++;</div><div class="line">        head ++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 输出结果：6 1 5 9 4 7 2 8 3</div></pre></td></tr></table></figure>
<h4 id="2-解密回文-–-栈"><a href="#2-解密回文-–-栈" class="headerlink" title="2) 解密回文 – 栈"></a>2) 解密回文 – 栈</h4><p><code>基本思想：</code> <strong>后进先出</strong>的数据结构，且只能在一端进行插入和删除操作。</p>
<p><code>生活上的例子：</code>我们在吃桶装薯片的时候，想要吃掉<strong>最后一片</strong>，就必须把前面的全部吃掉；在装子弹的时候，最后装入的那发子弹，是被第一个打出去的；</p>
<p><code>场景：</code> “xyzyx”是一个回文字符串，所谓回文字符串就是正读反读均相同的字符序列。通过栈这个数据结构我们很容易判断一个字符串是否为回文。</p>
<p><code>实战：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">   public void test_003()&#123;</div><div class="line">       String str = &quot;xyzyx&quot;;</div><div class="line"></div><div class="line">       // 偶数一定不是回文</div><div class="line">       if(str.length() % 2 == 0)&#123;</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       int mid = str.length() / 2;</div><div class="line">       int top = -1;</div><div class="line">       char[] strChars = str.toCharArray();</div><div class="line">       char[] firstChars = new char[mid];</div><div class="line"></div><div class="line">       for(int i = 0; i &lt; mid; i ++) &#123;</div><div class="line">           firstChars[++top] = strChars[i];</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       System.out.print(&quot;firstChars =&gt; &quot; + new String(firstChars) + “ : ”);</div><div class="line"></div><div class="line">       // xy mid yx 左右两边是对称的;</div><div class="line">       for(int i = mid + 1; i &lt; str.length()-1; i++) &#123;</div><div class="line">           if(strChars[i] != firstChars[top])&#123;</div><div class="line">               break;</div><div class="line">           &#125;</div><div class="line">           top --;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       System.out.println(top == 0 ? &quot;YES&quot; : &quot;NO&quot;);</div><div class="line">   &#125;</div><div class="line">   // 结果: firstChars =&gt; xy : YES</div></pre></td></tr></table></figure>
<p>未完待续…</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>啊哈！算法 by 啊哈磊</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;算法一篇空白，大学所学忘的差不多了，接下来几周会侧重学习算法基础。&lt;/p&gt;
&lt;h3 id=&quot;1-排序&quot;&gt;&lt;a href=&quot;#1-排序&quot; cl
    
    </summary>
    
      <category term="算法" scheme="http://jianwl.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://jianwl.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>React-Router入门</title>
    <link href="http://jianwl.com/2017/04/23/React-Router%E5%85%A5%E9%97%A8/"/>
    <id>http://jianwl.com/2017/04/23/React-Router入门/</id>
    <published>2017-04-23T04:26:18.000Z</published>
    <updated>2017-04-23T05:54:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>真正学会<code>React</code>是一个漫长的过程。你会发现，它不是一个库，也不是一个框架，而是一个庞大的体系，想要发挥它的威力，整个技术栈都要配合它改造。你要学习一整套解决方案，从后端到前端都是全新的做法。</p>
<p>本文介绍<code>React</code>体系的一个重要组成部分：路由库<code>React-Router</code>,它是官方维护的，事实上也是唯一可选的路由库。它通过管理URL，实现组件的切换和状态的变化，开发复杂的应用几乎肯定会用到。</p>
<h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><p>React Router安装命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -S react-router</div></pre></td></tr></table></figure>
<p>使用时，路由器<code>Router</code>就是React的一个组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; Router &#125; from &apos;react-router&apos;;</div><div class="line">render(&lt;Router/&gt;,document.getElementById(&apos;app&apos;));</div></pre></td></tr></table></figure>
<p><code>Router</code>组件本身只是一个容器，真正的路由要通过<code>Route</code>组件来定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import &#123; Router, Route, hashHistory &#125; from &apos;react-router&apos;;</div><div class="line"></div><div class="line">render((</div><div class="line">	&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">		&lt;Router path=&quot;/&quot; component=&#123;App&#125;/&gt;</div><div class="line">	&lt;/Router&gt;</div><div class="line">), document.getElementById(&apos;app&apos;));</div></pre></td></tr></table></figure>
<p>上面代码中，用户访问跟路由<code>/</code>（比如<code>http://www.example.com/</code>）,组件App就会加载到<code>document.getElementById(&#39;app&#39;)</code>。</p>
<p>你可能还注意到，<code>Router</code>组件有一个参数<code>history</code>，它的值<code>hashHistory</code>表示，路由的切换由URL的hash变化决定，即<code>URL</code>的<code>#</code>部分发生变化，举例来说，用户访问<code>http://www.example.com/</code>，实际上看到的是<code>http://www.example.com/#/</code>。</p>
<p><code>Route</code>组件定义了URL路径与组件的对应关系，你可以同时使用多个<code>Route</code>组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">	&lt;Route path=&quot;/&quot; component=&#123;App&#125;/&gt;</div><div class="line">	&lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;/&gt;</div><div class="line">	&lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure>
<p>上面代码中，用户访问<code>repos</code>(比如<code>http://localhost:8080/#/repos</code>),加载<code>Repos</code>组件；访问<code>/about</code>(<code>http://localhost:8080/#/about</code>)时，加载<code>About</code>组件。</p>
<h3 id="2-嵌套路由"><a href="#2-嵌套路由" class="headerlink" title="2. 嵌套路由"></a>2. 嵌套路由</h3><p>Route组件可以嵌套</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">	&lt;Route path=&quot;/&quot; component=&#123;App&#125;/&gt;</div><div class="line">		&lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;/&gt;</div><div class="line">		&lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</div><div class="line">	&lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure>
<p>上面代码中，用户访问<code>/repos</code>时，会先加载<code>App</code>组件，然后在它的内部再加载<code>Repos</code>组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;App&gt;</div><div class="line">	&lt;Repos&gt;</div><div class="line">&lt;/App&gt;</div></pre></td></tr></table></figure>
<p><code>App</code>组件要写成下面的样子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">export default React.createClass(&#123;</div><div class="line">	render() &#123;</div><div class="line">		return &lt;div&gt;</div><div class="line">			&#123;this.props.children&#125;</div><div class="line">			&lt;/div&gt;</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>上面代码中，<code>App</code>组件的<code>this.props.children</code>属性就是子组件。</p>
<p>子路由也可以不写在<code>Router</code>组件里面，单独传入<code>Router</code>组件的<code>routes</code>属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let routes = &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</div><div class="line">	&lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;/&gt;</div><div class="line">	&lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</div><div class="line">&lt;/Route&gt;</div><div class="line"></div><div class="line">&lt;Router routes=&#123;routes&#125; history=&#123;browserHistory&#125;/&gt;</div></pre></td></tr></table></figure>
<h3 id="3-path属性"><a href="#3-path属性" class="headerlink" title="3. path属性"></a>3. path属性</h3><p><code>Route</code>组件的<code>path</code>属性指定路由的匹配规则，这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件。</p>
<p>试看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</div><div class="line">	&lt;Route path=&quot;message/:id&quot; component=&#123;Message&#125;&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure>
<p>上面代码中，当用户访问<code>/inbox/message/:id</code>,会加载下面的组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Inbox&gt;</div><div class="line">	&lt;Message/&gt;</div><div class="line">&lt;/Inbox&gt;</div></pre></td></tr></table></figure>
<p>如果省略外层<code>Route</code>的path参数，写成下面的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Route component=&#123;Inbox&#125;&gt;</div><div class="line">	&lt;Route path=&quot;inbox/message/:id&quot; component=&#123;Message&#125;&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure>
<p>现在用户访问<code>/inbox/message/:id</code>时，组件加载还是原来的样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Inbox&gt;</div><div class="line">	&lt;Message/&gt;</div><div class="line">&lt;/Inbox&gt;</div></pre></td></tr></table></figure>
<h3 id="4-通配符"><a href="#4-通配符" class="headerlink" title="4. 通配符"></a>4. 通配符</h3><p><code>path</code>属性可以使用通配符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;/hello/:name&quot;&gt;</div><div class="line">// 匹配 /hello/andy</div><div class="line">// 匹配 /hello/lucy</div><div class="line"></div><div class="line">&lt;Route path=&quot;/hello(/:name)&quot;&gt;</div><div class="line">// 匹配 /hello</div><div class="line">// 匹配 /hello/andy</div><div class="line">// 匹配 /hello/lucy</div><div class="line"></div><div class="line">&lt;Route path=&quot;/files/*.*&quot;&gt;</div><div class="line">// 匹配 /files/hello.jpg</div><div class="line">// 匹配 /files/hello.html</div><div class="line"></div><div class="line">&lt;Route path=&quot;/files/*&quot;&gt;</div><div class="line">// 匹配 /files/</div><div class="line">// 匹配 /files/a</div><div class="line">// 匹配 /files/a/b</div><div class="line"></div><div class="line">&lt;Route path=&quot;/**/*.jpg&quot;&gt;</div><div class="line">// 匹配 /files/hello.jpg</div><div class="line">// 匹配 /files/path/to/file.jpg</div></pre></td></tr></table></figure>
<p>通配符的规则如下：</p>
<p>(1) <code>:paramName</code></p>
<p><code>:paramName</code>匹配URL的一个部分，知道遇到下一个<code>/</code>、<code>？</code>、<code>#</code>为止，这个路径参数可以通过<code>this.props.params.paramName</code>取出；</p>
<p>(2) <code>()</code></p>
<p><code>()</code>表示URL的这个部分是可选的；</p>
<p>(3) <code>*</code></p>
<p><code>*</code>匹配任意字符，直到模式里面的下一个字符为止，匹配方式是非贪婪模式；</p>
<p>(4) <code>**</code></p>
<p><code>**</code> 匹配任意字符，知道下一个<code>/</code>、<code>？</code>、<code>#</code>为止。匹配方式是贪婪模式。</p>
<p><code>path</code> 属性也可以使用相对路径(不以<code>/</code>开头)，匹配时就会相对于父组件的路由，可以参考上一节的例子，嵌套路由如果想摆脱这个规则，可以使用绝对路由。</p>
<p>路由匹配规则是从上到下执行，一旦发现匹配，就不再匹配其余的规则了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;/comments&quot; ...&gt;</div><div class="line">&lt;Route path=&quot;/comments&quot; ...&gt;</div></pre></td></tr></table></figure>
<p>上面代码中，路径<code>/comments</code>同时匹配两个规则，第二个规则不会生效。</p>
<p>设置路径参数时，需要特别小心这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Router&gt;</div><div class="line">  &lt;Route path=&quot;/:userName/:id&quot; component=&#123;UserPage&#125;/&gt;</div><div class="line">  &lt;Route path=&quot;/about/me&quot; component=&#123;About&#125;/&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure>
<p>上面代码中，用户访问<code>/about/me</code>时，不会触发第二个路由规则，因为它会匹配<code>/:username/:id</code>这个规则，因此，带参数的路劲一般要写在路由规则的底部。</p>
<p>此外，<code>URL</code>的查询字符串<code>/foo?bar=baz</code>，可以用<code>this.props.location.query.bar</code>获取。</p>
<h3 id="5-IndexRoute组件"><a href="#5-IndexRoute组件" class="headerlink" title="5. IndexRoute组件"></a>5. IndexRoute组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Router&gt;</div><div class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</div><div class="line">    &lt;Route path=&quot;accounts&quot; component=&#123;Accounts&#125;/&gt;</div><div class="line">    &lt;Route path=&quot;statements&quot; component=&#123;Statements&#125;/&gt;</div><div class="line">  &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure>
<p>上面代码中，访问根路径<code>/</code>，不会加载任何子组件，也就是说，<code>App</code>组件的<code>this.props.children</code>，这时是<code>undefined</code>。</p>
<p><code>IndexRoute</code>就是解决这个问题的，显示指定<code>Home</code>是跟路由的子组件，即默认情况下加载的子组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Router&gt;</div><div class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</div><div class="line">    &lt;IndexRoute component=&#123;Home&#125;/&gt;</div><div class="line">    &lt;Route path=&quot;accounts&quot; component=&#123;Accounts&#125;/&gt;</div><div class="line">    &lt;Route path=&quot;statements&quot; component=&#123;Statements&#125;/&gt;</div><div class="line">  &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure>
<p>现在，用户访问<code>/</code>的时候，加载的组件结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;App&gt;</div><div class="line">  &lt;Home/&gt;</div><div class="line">&lt;/App&gt;</div></pre></td></tr></table></figure>
<h3 id="6-Redirect组件"><a href="#6-Redirect组件" class="headerlink" title="6. Redirect组件"></a>6. Redirect组件</h3><p><code>&lt;Redirect&gt;</code>组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</div><div class="line">	&#123;/* 从/inbox/messages/:id 跳转到 /messages/:id */&#125;</div><div class="line">	&lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot;&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure>
<h3 id="7-IndexRedirect组件"><a href="#7-IndexRedirect组件" class="headerlink" title="7. IndexRedirect组件"></a>7. IndexRedirect组件</h3><p><code>IndexRedirect</code>组件用于访问跟路由的时候，将用户重定向到某个子组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</div><div class="line">  ＜IndexRedirect to=&quot;/welcome&quot; /&gt;</div><div class="line">  &lt;Route path=&quot;welcome&quot; component=&#123;Welcome&#125; /&gt;</div><div class="line">  &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure>
<p>上面代码中，用户访问根路径时，将自动重定向到子组件<code>welcome</code>。</p>
<h3 id="8-Link"><a href="#8-Link" class="headerlink" title="8. Link"></a>8. Link</h3><p><code>Link</code>组件用于取代<code>&lt;a&gt;</code>元素，生成一个链接，允许用户点击跳转到另一个路由。它基本上就是<code>&lt;a&gt;</code>元素的<code>React</code>版本，可以接收<code>Router</code>的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">	return &lt;div&gt;</div><div class="line">		&lt;ul role=&quot;nav&quot;&gt;</div><div class="line">			&lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt;</div><div class="line">			&lt;li&gt;&lt;Link to=&quot;/repos&quot;&gt;Repos&lt;/Link&gt;&lt;/li&gt;</div><div class="line">		&lt;/ul&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="9-IndexLink"><a href="#9-IndexLink" class="headerlink" title="9.IndexLink"></a>9.IndexLink</h3><p>如果链接到跟路由<code>/</code>，不要使用<code>Link</code>组件，而要使用<code>IndexLink</code>组件，对于跟路由来说<code>activeStyle</code>和<code>activeClassName</code>会失效，或者说总是生效，因为<code>/</code>会匹配任何子路由，而<code>IndexLink</code>组件会使用路径的精确匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;IndexLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;</div><div class="line">  Home</div><div class="line">&lt;/IndexLink&gt;</div></pre></td></tr></table></figure>
<h3 id="10-history属性"><a href="#10-history属性" class="headerlink" title="10. history属性"></a>10. history属性</h3><p><code>Router</code>组件的<code>history</code>属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供<code>React Router</code>匹配。</p>
<p><code>history</code>属性，一共可以设置三种值，分别为 browserHistory、hashHistory、createMemoryHistory。</p>
<p>(1) 如果设为<code>hashHistory</code>，路由将通过URL的hash部分(<code>#</code>)切换，URL的形式类似<code>example.com/#/some/path</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import &#123; hashHistory &#125; from &apos;react-router&apos;</div><div class="line"></div><div class="line">render(</div><div class="line">	&lt;Router history= &#123;hashHistory&#125; routes=&#123;routes&#125;/&gt;,</div><div class="line">	document.getElementById(&apos;app&apos;)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>(2) 如果设为<code>browserHistory</code>，浏览器的路由将不再通过<code>Hash</code>完成，而显示正常的路径<code>example.com/some/path</code>,背后调用的是浏览器的History API.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import &#123; browserHistory &#125; from &apos;react-router&apos;</div><div class="line"></div><div class="line">render(</div><div class="line">	&lt;Router history= &#123;browserHistory&#125; routes=&#123;routes&#125;/&gt;,</div><div class="line">	document.getElementById(&apos;app&apos;)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>但是，这种情况需要对服务器改造，否则用户直接向服务器请求某个子路由，会显示<code>404</code>。</p>
<p>(3) <code>createMemoryHistory</code>主要用于服务器渲染，它创建一个内存中<code>history</code>对象，不与浏览器<code>URL</code>互动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const history = createMemoryHistory(location)</div></pre></td></tr></table></figure>
<h3 id="11-表单处理"><a href="#11-表单处理" class="headerlink" title="11. 表单处理"></a>11. 表单处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</div><div class="line">	&lt;input type=&quot;text&quot; placeholder=&quot;username&quot;/&gt;</div><div class="line">	&lt;input type=&quot;text&quot; placeholder=&quot;repo&quot;&gt;</div><div class="line">	&lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>第一种方法是使用<code>browserHistory.push</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import &#123; browserHistory &#125; from &apos;react-router&apos;</div><div class="line"></div><div class="line">// ...</div><div class="line"></div><div class="line">handleSubmit(event) &#123;</div><div class="line">	event.preventDefault()</div><div class="line">	const userName = event.target.elements[0].value</div><div class="line">	const repo = event.target.element[1].value</div><div class="line">	const path = `/repos/$&#123;userName&#125;/$&#123;repo&#125;`</div><div class="line">	browserHistory.push(path)</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>第二种方法是使用<code>context</code>对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">export default React.createClass(&#123;</div><div class="line">	contextTypes: &#123;</div><div class="line">		router: React.PropTypes.object</div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	handleSubmit(event) &#123;</div><div class="line">		// ...</div><div class="line">		this.context.router.push(path)</div><div class="line">	&#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="12-路由的钩子"><a href="#12-路由的钩子" class="headerlink" title="12. 路由的钩子"></a>12. 路由的钩子</h3><p>每个路由都有<code>Enter</code>和<code>Leave</code>钩子，用户进入或离开时触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt;</div><div class="line">＜Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</div><div class="line">  ＜Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure>
<p>上面代码中，如果用户离开<code>/messages/:id</code>，进入<code>/about</code>时，会依次触发以下的钩子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/messages/:id的onLeave</div><div class="line">/inbox的onLeave</div><div class="line">/about的onEnter</div></pre></td></tr></table></figure>
<p>下面是一个例子，使用<code>onEnter</code>钩子代替<code>&lt;Redirect&gt;</code>组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</div><div class="line">  &lt;Route</div><div class="line">    path=&quot;messages/:id&quot;</div><div class="line">    onEnter=&#123;</div><div class="line">      (&#123;params&#125;, replace) =&gt; replace(`/messages/$&#123;params.id&#125;`)</div><div class="line">    &#125; </div><div class="line">  /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure>
<p><code>onEnter</code>钩子还可以用来做认证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const requireAuth = (nextState, replace) =&gt; &#123;</div><div class="line">    if (!auth.isAdmin()) &#123;</div><div class="line">        // Redirect to Home page if not an Admin</div><div class="line">        replace(&#123; pathname: &apos;/&apos; &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">export const AdminRoutes = () =&gt; &#123;</div><div class="line">  return (</div><div class="line">     &lt;Route path=&quot;/admin&quot; component=&#123;Admin&#125; onEnter=&#123;requireAuth&#125; /&gt;</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是一个高级应用，当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">const Home = withRouter(</div><div class="line">  React.createClass(&#123;</div><div class="line">    componentDidMount() &#123;</div><div class="line">      this.props.router.setRouteLeaveHook(</div><div class="line">        this.props.route, </div><div class="line">        this.routerWillLeave</div><div class="line">      )</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    routerWillLeave(nextLocation) &#123;</div><div class="line">      // 返回 false 会继续停留当前页面，</div><div class="line">      // 否则，返回一个字符串，会显示给用户，让其自己决定</div><div class="line">      if (!this.state.isSaved)</div><div class="line">        return &apos;确认要离开？&apos;;</div><div class="line">    &#125;,</div><div class="line">  &#125;)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>上面代码中，<code>setRouteLeaveHook</code>方法为<code>Leave</code>钩子指定<code>routerWillLeave</code>函数。该方法如果返回false，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html" target="_blank" rel="external">React Router使用教程 by 阮一峰</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;真正学会&lt;code&gt;React&lt;/code&gt;是一个漫长的过程。你会发现，它不是一个库，也不是一个框架，而是一个庞大的体系，想要发挥它的威力，
    
    </summary>
    
      <category term="React" scheme="http://jianwl.com/categories/React/"/>
    
    
      <category term="React" scheme="http://jianwl.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="http://jianwl.com/2017/04/22/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://jianwl.com/2017/04/22/Linux学习笔记/</id>
    <published>2017-04-22T02:00:00.000Z</published>
    <updated>2017-04-22T02:59:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="1-快速改变当前工作目录的有效方法："><a href="#1-快速改变当前工作目录的有效方法：" class="headerlink" title="1. 快速改变当前工作目录的有效方法："></a>1. 快速改变当前工作目录的有效方法：</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>cd</td>
<td>更改工作目录到你的家目录</td>
</tr>
<tr>
<td>cd -</td>
<td>更改工作目录到先前的工作目录</td>
</tr>
<tr>
<td>cd ~user_name</td>
<td>更改工作目录到用户家目录</td>
</tr>
</tbody>
</table>
<h4 id="2-Linux目录结构"><a href="#2-Linux目录结构" class="headerlink" title="2. Linux目录结构"></a>2. Linux目录结构</h4><table>
<thead>
<tr>
<th>目录</th>
<th>评论</th>
</tr>
</thead>
<tbody>
<tr>
<td>/</td>
<td>根目录，万物起源</td>
</tr>
<tr>
<td>/bin</td>
<td>包含系统启动和运行所必须的二进制程序</td>
</tr>
<tr>
<td>/boot</td>
<td>包含Linux内核，最初的RMA磁盘映像</td>
</tr>
<tr>
<td>/dev</td>
<td>这是一个包含设备结点的特殊目录。 “一切都是文件”，也适用于设备，在这个目录里，内核维护着它支持的设备</td>
</tr>
<tr>
<td>/etc</td>
<td>这个目录包含所有系统层面的配置文件。它也包含一系列的shell脚本，在系统启动时，这些脚本会运行每个系统服务。这个目录中的任何文件都是可读的文本文件。<code>/etc/crontab</code>，定义自动运行的任务；<code>/etc/fstab</code>，包含存储设备的列表，以及与他们相关的挂载点;<code>/etc/passwd</code>，包含用户账号列表;</td>
</tr>
<tr>
<td>/home</td>
<td>在通常的配置环境下，系统会在/home下，给每个用户分配一个目录，普通智能在他们的目录下创建文件。这个限制保护系统免受错误的用户活动破坏。</td>
</tr>
<tr>
<td>/lib</td>
<td>包含核心程序所需的库文件，这些文件与windows中的动态链接库相似</td>
</tr>
<tr>
<td>/lost+found</td>
<td>每个使用Linux文件系统的格式化分区或设备</td>
</tr>
<tr>
<td>/media</td>
<td>可移除媒体设备的挂载点，例如USB驱动器、CD-ROMS等</td>
</tr>
<tr>
<td>/mnt</td>
<td>可移除设备的挂载点</td>
</tr>
<tr>
<td>/opt</td>
<td>安装可选的软件</td>
</tr>
<tr>
<td>/proc</td>
<td>它是一个由Linux内核维护的虚拟文件系统，它所包含的文件时内核的窥视孔</td>
</tr>
<tr>
<td>/root</td>
<td>root账户的家目录</td>
</tr>
<tr>
<td>/sbin</td>
<td>这个目录包含“系统”二进制文件</td>
</tr>
<tr>
<td>/tmp</td>
<td>存储各种程序创建的临时文件的地方</td>
</tr>
<tr>
<td>/usr</td>
<td>包含普通用户所需要的所有程序和文件</td>
</tr>
<tr>
<td>/usr/bin</td>
<td>系统安装的可执行程序</td>
</tr>
<tr>
<td>/usr/lib</td>
<td>程序所用的共享库</td>
</tr>
<tr>
<td>/usr/local</td>
<td>由源码编译的程序会安装在/usr/local/bin目录下</td>
</tr>
<tr>
<td>/usr/sbin</td>
<td>许多系统管理程序</td>
</tr>
<tr>
<td>/usr/share</td>
<td>由/usr/bin目录中的程序使用的共享数据</td>
</tr>
<tr>
<td>/var</td>
<td>各种数据库，假脱机文件、用户邮件等都在这</td>
</tr>
<tr>
<td>/var/log</td>
<td>系统日志</td>
</tr>
</tbody>
</table>
<h4 id="3-硬链接-VS-符号链接"><a href="#3-硬链接-VS-符号链接" class="headerlink" title="3. 硬链接 VS 符号链接"></a>3. 硬链接 VS 符号链接</h4><p><code>硬链接</code></p>
<p><img src="http://i2.muimg.com/567571/c80b86ffcc0477bf.png" alt=""></p>
<p>source.txt与copy.txt共用同一份资源，任何一个文件改动，另外一个文件会跟着变化。</p>
<p><code>符号链接</code></p>
<p><img src="http://i2.muimg.com/567571/aae479ac8ce6f170.png" alt=""></p>
<p>source.txt与sign_copy.txt共用同一份资源，任何一个文件改动，另外一个文件会跟着变化。</p>
<p><code>硬链接 VS 符号链接区别 ？</code></p>
<p>硬链接不能跨越物理设备，硬链接不能关联目录，只能关联文件；符号链接就是为了解决这两个问题，创建符号链接的过程与硬链接相似；</p>
<h4 id="4-which-显示可执行文件的位置"><a href="#4-which-显示可执行文件的位置" class="headerlink" title="4. which 显示可执行文件的位置"></a>4. which 显示可执行文件的位置</h4><p><img src="http://i1.piimg.com/567571/224ff92365521577.png" alt=""></p>
<h4 id="5-重定向"><a href="#5-重定向" class="headerlink" title="5. 重定向"></a>5. 重定向</h4><h5 id="1-重定向标准输出，从头开始写文件"><a href="#1-重定向标准输出，从头开始写文件" class="headerlink" title="1) 重定向标准输出，从头开始写文件"></a>1) 重定向标准输出，从头开始写文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 将标准输出重定向到 ls-output.txt 文件</div><div class="line">ls -l /usr/bin &gt; ls-output.txt</div></pre></td></tr></table></figure>
<p>重复定向测试，这次我们把目录换成一个不存在的目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 屏幕上显示 ls: /usr/bins: No such file or directory</div><div class="line">ls -l /usr/bins &gt; ls-output.txt</div></pre></td></tr></table></figure>
<p>为什么错误信息没有被重定向到ls-output.txt文件呢？反而直接抛出在屏幕上，因为我们只定义了标准输出，而没有定向标准错误输出。</p>
<h5 id="2）重定向标准输出，追加文件"><a href="#2）重定向标准输出，追加文件" class="headerlink" title="2）重定向标准输出，追加文件"></a>2）重定向标准输出，追加文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 将内容追加到ls-output.txt</div><div class="line">ls -l /usr/bin &gt;&gt; ls-output.txt</div></pre></td></tr></table></figure>
<h5 id="3-重定向标准错误"><a href="#3-重定向标准错误" class="headerlink" title="3) 重定向标准错误"></a>3) 重定向标准错误</h5><p><img src="http://i2.muimg.com/567571/b024d5f76e8db1a7.png" alt=""></p>
<p>文件描述符2，紧挨着重定向符之前，用来重定向标准错误输出到文件。</p>
<h5 id="4）重定向标准输出和错误到同一个文件"><a href="#4）重定向标准输出和错误到同一个文件" class="headerlink" title="4）重定向标准输出和错误到同一个文件"></a>4）重定向标准输出和错误到同一个文件</h5><p><img src="http://i1.piimg.com/567571/a1958525fdae5dfd.png" alt=""></p>
<p><code>2&gt;&amp;1</code>表示重定向文件描述符<code>2</code>「标准错误」到文件描述符<code>1</code>「标准输出」，注意重定向的顺序非常重要，标准错误的重定向必须总是在标准输出重定向之后，要不然它就不起作用；</p>
<h5 id="5-处理不需要的输出"><a href="#5-处理不需要的输出" class="headerlink" title="5) 处理不需要的输出"></a>5) 处理不需要的输出</h5><p>有时候我们不想要一个命令的输出结果，只想把他们直接扔掉，我们可以将其重定向到一个特殊的叫做<code>/dev/null</code>的文件，它接受输入，并且对输入不做任何处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -l /usr/bins 2&gt; /dev/null</div></pre></td></tr></table></figure>
<h4 id="6-快速移动光标快捷键"><a href="#6-快速移动光标快捷键" class="headerlink" title="6. 快速移动光标快捷键"></a>6. 快速移动光标快捷键</h4><table>
<thead>
<tr>
<th>按键</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl-a</td>
<td>光标移到行首</td>
</tr>
<tr>
<td>Ctrl-e</td>
<td>光标移到行尾</td>
</tr>
<tr>
<td>Ctrl-f</td>
<td>光标前移一个字符</td>
</tr>
<tr>
<td>Ctrl-b</td>
<td>光标后移一个字符</td>
</tr>
<tr>
<td>Ctrl-l</td>
<td>清空屏幕</td>
</tr>
</tbody>
</table>
<h4 id="7-VIM快捷键"><a href="#7-VIM快捷键" class="headerlink" title="7. VIM快捷键"></a>7. VIM快捷键</h4><h5 id="1-移动光标-「命令模式下」"><a href="#1-移动光标-「命令模式下」" class="headerlink" title="1) 移动光标 「命令模式下」"></a>1) 移动光标 「命令模式下」</h5><table>
<thead>
<tr>
<th>按键</th>
<th>移动光标</th>
</tr>
</thead>
<tbody>
<tr>
<td>l</td>
<td>向右移动一个字符</td>
</tr>
<tr>
<td>h</td>
<td>向左移动一个字符</td>
</tr>
<tr>
<td>j</td>
<td>向下移动一行</td>
</tr>
<tr>
<td>k</td>
<td>向上移动一行</td>
</tr>
<tr>
<td>^</td>
<td>移动到当前行的第一个非空字符</td>
</tr>
<tr>
<td><code>$</code></td>
<td>移动到当前行的末尾</td>
</tr>
<tr>
<td>numberG</td>
<td>移动到第number行</td>
</tr>
<tr>
<td>G</td>
<td>移动到文件末尾</td>
</tr>
</tbody>
</table>
<h5 id="2-删除文本"><a href="#2-删除文本" class="headerlink" title="2) 删除文本"></a>2) 删除文本</h5><table>
<thead>
<tr>
<th>按键</th>
<th>删除的文本</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>当前字符</td>
</tr>
<tr>
<td>dd</td>
<td>当前行</td>
</tr>
<tr>
<td>5dd</td>
<td>当前行及随后4行</td>
</tr>
<tr>
<td>dG</td>
<td>当前行到文件末尾</td>
</tr>
<tr>
<td>d20G</td>
<td>当前行到文件的第20行</td>
</tr>
</tbody>
</table>
<h5 id="3-复制文本"><a href="#3-复制文本" class="headerlink" title="3) 复制文本"></a>3) 复制文本</h5><p>通过 dd「剪切」yy「复制」文本，通过 p「粘贴」</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>复制的内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>yy</td>
<td>当前行</td>
</tr>
<tr>
<td>5yy</td>
<td>当前行及随后4行</td>
</tr>
<tr>
<td>yG</td>
<td>当前行到文件末尾</td>
</tr>
<tr>
<td>y20G</td>
<td>当前行到文件的第20行</td>
</tr>
</tbody>
</table>
<h5 id="4-全局查找和替代"><a href="#4-全局查找和替代" class="headerlink" title="4) 全局查找和替代"></a>4) 全局查找和替代</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:%s/Line/line/g</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>条目</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>:</td>
<td>冒号字符运行一个ex命令</td>
</tr>
<tr>
<td>%</td>
<td>指定要操作的行数，%是一个快捷方式，表示从第一行到最后一行。另外也可以用1,<code>$</code>来代替，表示从第一行到文件最后一行</td>
</tr>
<tr>
<td>s</td>
<td>指定操作，在这种情况下是，替换</td>
</tr>
<tr>
<td>Line/line</td>
<td>查找类型与替换文本</td>
</tr>
<tr>
<td>g</td>
<td>文本行中所有匹配的字符串执行查找和替换操作</td>
</tr>
</tbody>
</table>
<h5 id="5-显示行号与关闭行号"><a href="#5-显示行号与关闭行号" class="headerlink" title="5) 显示行号与关闭行号"></a>5) 显示行号与关闭行号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:set nu // 显示行号</div><div class="line">:set nonu // 关闭行号</div></pre></td></tr></table></figure>
<h4 id="8-查找文件"><a href="#8-查找文件" class="headerlink" title="8. 查找文件"></a>8. 查找文件</h4><p><img src="http://i1.piimg.com/567571/062a4bbf1cd6f71f.png" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>快乐的Linux命令行</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实战&quot;&gt;&lt;a href=&quot;#实战&quot; class=&quot;headerlink&quot; title=&quot;实战&quot;&gt;&lt;/a&gt;实战&lt;/h3&gt;&lt;h4 id=&quot;1-快速改变当前工作目录的有效方法：&quot;&gt;&lt;a href=&quot;#1-快速改变当前工作目录的有效方法：&quot; class=&quot;headerli
    
    </summary>
    
      <category term="Linux" scheme="http://jianwl.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://jianwl.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redux入门教程(三)</title>
    <link href="http://jianwl.com/2017/04/21/Redux%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-%E4%B8%89/"/>
    <id>http://jianwl.com/2017/04/21/Redux入门教程-三/</id>
    <published>2017-04-21T09:00:53.000Z</published>
    <updated>2017-04-21T10:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="http://jianwl.com/2017/04/21/Redux%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-%E4%BA%8C/#more">上一篇文章</a>，介绍了Redux的基本做法：用户发出Action,Reducer函数算出新的State，View重新渲染。但是一个关键的问题没有解决：异步操作怎么办？Action发出以后，Reducer立即算出State，这叫做同步；Action发出以后，过一段时间在执行Reducer，这就是异步。</p>
<p>怎么才能Reducer在异步操作结束后自动执行呢？这就要用到新的工具：中间件(middleware)。</p>
<h3 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h3><p>为了理解中间件，让我们站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Reducer: 纯函数，只能承担计算 State 的功能，不适合承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。</div><div class="line"></div><div class="line">View：与 State 一一对应，可以看做 State 的视觉层，也不适合承担其他功能。</div><div class="line"></div><div class="line">Action: 存放数据的对象，即消息的载体， 只能被别人操作，自己不能进行任何操作。</div></pre></td></tr></table></figure>
<p>想来想去，只有发送 Action 的这个步骤，即<code>store.dispatch()</code>方法，可以添加功能，距离来说，添加日志功能，把 Action 和 State 打印出来， 可以对<code>store.dispatch</code>进行如下改造。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let next = store.dispatch;</div><div class="line">store.dispatch = function dispatchAndLog(action) &#123;</div><div class="line">	consle.log(&quot;dispatching&quot;,action);</div><div class="line">	next(action);</div><div class="line">	console.log(&apos;next state&apos;, store.getState());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，对<code>store.dispatch</code>进行了重定义，在发送<code>Action</code>前后添加了打印功能，这就是中间件的雏形。中间件就是一个函数，对<code>store.dispatch</code>方法进行了改造，在发出Action 和执行 Reducer 这两步之间，添加了其他功能。</p>
<h3 id="中间件的用法"><a href="#中间件的用法" class="headerlink" title="中间件的用法"></a>中间件的用法</h3><p>上节的日志中间件，是有现成的模块的<a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" target="_blank" rel="external">redux-logger</a>，这里将介绍如何使用它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import &#123; applyMiddleware, createStore &#125; from &apos;redux&apos;;</div><div class="line">import createLogger from &apos;redux-logger&apos;;</div><div class="line">const logger = createStore(</div><div class="line">	reducer,</div><div class="line">	applyMiddleware(logger)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>上面代码中，<code>redux-logger</code>提供一个生成器<code>createLogger</code>,可以生成日志中间件<code>logger</code>,然后，将他放在<code>appleMiddleware</code>方法之中，传入<code>createStore</code>方法，就完成了<code>store.dispatch()</code>的功能增强。</p>
<p>这里有两点需要注意：</p>
<p>（1）<code>createStore</code> 方法可以接受整个应用的初始化状态作为参数，那样的话，<code>applyMiddleware</code>就是第三个参数了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const store = createStore(</div><div class="line">	reducer,</div><div class="line">	initial_state,</div><div class="line">	applyMiddleware(logger)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>(2) 中间件的次序有讲究</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const store = createStore(</div><div class="line">	reducer,</div><div class="line">	applyMiddleware(thunk, promise, logger)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>上面代码中，<code>applyMiddleware</code>方法的三个参数，就是三个中间件，有的中间件有次序要求，使用前要查下文档，比如，<code>logger</code>就一定要放在最后，否则输出结果就不对。</p>
<h3 id="applyMiddlewares"><a href="#applyMiddlewares" class="headerlink" title="applyMiddlewares()"></a>applyMiddlewares()</h3><p>看到这里，你可能会问，<code>applyMiddlewares</code>这个方法到底是干什么用的？<br>它是<code>Redux</code>的原生方法，作用是将所有中间件组成一个数组，依次执行，下面是它的源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">export default function applyMiddleware(...middlewares) &#123;</div><div class="line">	return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123;</div><div class="line">		var dispatch = store.dispatch;</div><div class="line">		var chain = [];</div><div class="line">		</div><div class="line">		var middlewareAPI = &#123;</div><div class="line">			getState: store.getState,</div><div class="line">			dispatch: (action) =&gt; dispatch(action)</div><div class="line">		&#125;;</div><div class="line">		chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));</div><div class="line">		dispatch = compose(...chain)(store.dispatch);</div><div class="line">		</div><div class="line">		return &#123;...store,dispatch&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，所有中间件被放进一个数组<code>chain</code>，然后进行嵌套执行，最后执行<code>store.dispatch</code>，可以看到，中间件内部（middlewareAPI）可以拿到<code>getState</code> 和 <code>dispatch</code> 这两个方法。</p>
<h3 id="异步操作的思路"><a href="#异步操作的思路" class="headerlink" title="异步操作的思路"></a>异步操作的思路</h3><p>理解中间件以后，就可以处理异步操作了。</p>
<p>同步操作只需要发出一种Action即可，异步操作的差别是它要发出三种Action。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">操作发起的Action</div><div class="line">操作成功时的Action</div><div class="line">操作失败时的Action</div></pre></td></tr></table></figure>
<p>以向服务器取出数据为例，三种Action可以有两种不同的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 写法一：名称相同，参数不同</div><div class="line">&#123; type: &apos;FETCH_POSTS&apos; &#125;</div><div class="line">&#123; type: &apos;FETCH_POSTS&apos;, status: &apos;error&apos;, error: &apos;Oops&apos; &#125;</div><div class="line">&#123; type: &apos;FETCH_POSTS&apos;, status: &apos;success&apos;, response: &#123; ... &#125; &#125;</div><div class="line"></div><div class="line">// 写法二：名称不同</div><div class="line">&#123; type: &apos;FETCH_POSTS_REQUEST&apos; &#125;</div><div class="line">&#123; type: &apos;FETCH_POSTS_FAILURE&apos;, error: &apos;Oops&apos; &#125;</div><div class="line">&#123; type: &apos;FETCH_POSTS_SUCCESS&apos;, response: &#123; ... &#125; &#125;</div></pre></td></tr></table></figure>
<p>除了 Action 种类不同，异步操作的 State 也要进行改造，反映不同的操作状态。下面是 State 的一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let state = &#123;</div><div class="line">	isFetching: true,</div><div class="line">	didInvalidate: true,</div><div class="line">	lastUpdated: &apos;xxxxx&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中， State的属性<code>isFetching</code>表示是否在抓取数据。<code>didInvalidate</code>表示数据是否过时，<code>lastUpdated</code>表示上一次更新时间。</p>
<p>现在整个异步操作的思路就很清楚了:操作开始时，送出一个 Action，触发 State 更新为”正在操作”状态，View 重新渲染;操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" target="_blank" rel="external">Redux入门教程二 by 阮一峰</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://jianwl.com/2017/04/21/Redux%E5%85%A5%E9%97%A8%E6%95%99
    
    </summary>
    
      <category term="React" scheme="http://jianwl.com/categories/React/"/>
    
    
      <category term="React" scheme="http://jianwl.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Redux入门教程(二)</title>
    <link href="http://jianwl.com/2017/04/21/Redux%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-%E4%BA%8C/"/>
    <id>http://jianwl.com/2017/04/21/Redux入门教程-二/</id>
    <published>2017-04-21T02:11:40.000Z</published>
    <updated>2017-04-21T08:01:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇文章<a href="http://jianwl.com/2017/04/19/Redux%E5%85%A5%E9%97%A8/#more">Redux入门</a>，主要偏于实战，这一节主要介绍Redux的基本概念 &amp; API &amp; Reducer拆分。</p>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p><code>Redux</code>的设计思想很简单，就两句话。</p>
<blockquote>
<p>(1) Web 应用是一个状态机，视图与状态是一一对应的。</p>
<p>(2) 所有的状态，保存在一个对象里面。</p>
</blockquote>
<h3 id="基本概念-amp-API"><a href="#基本概念-amp-API" class="headerlink" title="基本概念 &amp; API"></a>基本概念 &amp; API</h3><h4 id="1、Store"><a href="#1、Store" class="headerlink" title="1、Store"></a>1、Store</h4><p><code>Store</code>就是保存数据的地方，你可以把它看成一个容器，整个应用只能有一个<code>Store</code>。<code>Redux</code>提供<code>createStore</code>这个函数，用来生成<code>Store</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;;</div><div class="line">const store = createStore(fn);</div></pre></td></tr></table></figure>
<p>上面代码中，<code>createStore</code>函数接受另一个函数作为参数，返回新生成的<code>Store</code>对象。</p>
<h4 id="2、State"><a href="#2、State" class="headerlink" title="2、State"></a>2、State</h4><p><code>Store</code>对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照。这种时点的数据集合，就叫<code>State</code>。当前时刻的<code>State</code>，可以通过<code>store.getState()</code>拿到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;</div><div class="line">const store = createStore(fn);</div><div class="line">const state = store.getState();</div></pre></td></tr></table></figure>
<p><code>Redux</code>规定，一个<code>State</code>对应一个<code>View</code>，只要<code>State</code>相同，<code>View</code>就相同，你知道<code>State</code>，就知道<code>View</code>是什么样。</p>
<h4 id="3、Action"><a href="#3、Action" class="headerlink" title="3、Action"></a>3、Action</h4><p><code>State</code>的变化，会导致<code>View</code>的变化，但是，用户接触不到<code>State</code>，只能接触到<code>View</code>，所以<code>State</code>变化必须是<code>View</code>导致的，<code>Action</code>就是<code>View</code>发出的通知，表示<code>State</code>应该要发送变化了。</p>
<p><code>Action</code>是一个对象，其中<code>type</code>属性是必须的，表示<code>Action</code>的名称，其他属性可以自由设置，社区有一个<a href="https://github.com/acdlite/flux-standard-action" target="_blank" rel="external">规范</a>可以参考。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const action = &#123;</div><div class="line">	type: &apos;ADD_TODO&apos;,</div><div class="line">	payload: &apos;Learn Redux&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，<code>Action</code>的名称是<code>ADD_TODO</code>，它携带的信息是字符串<code>Learn Redux</code>。可以这样理解，<code>Action</code>描述当前发生的事情，改变<code>State</code>的唯一方法，就是使用<code>Action</code>，它会运送数据到<code>Store</code>。</p>
<h4 id="4、Action-Creator"><a href="#4、Action-Creator" class="headerlink" title="4、Action Creator"></a>4、Action Creator</h4><p><code>View</code>要发送多少信息，就会有多少种<code>Action</code>，如果都手写，会很麻烦，可以定义一个函数来生成<code>Action</code>，这个函数就叫<code>Action Creator</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const ADD_TODO = &apos;添加 TODO&apos;；</div><div class="line"></div><div class="line">function addTodo(text) &#123;</div><div class="line">	return &#123;</div><div class="line">		type: ADD_TODO,</div><div class="line">		text</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const action = addTodo(&apos;Learn Redux&apos;);</div></pre></td></tr></table></figure>
<p>上面代码中,<code>addTodo</code>函数就是一个<code>Action Creator</code>。</p>
<h4 id="5、store-dispatch"><a href="#5、store-dispatch" class="headerlink" title="5、store.dispatch()"></a>5、store.dispatch()</h4><p><code>store.dispatch()</code>是View发出Action的唯一方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;;</div><div class="line">const store = createStore(fn);</div><div class="line"></div><div class="line">store.dispatch(&#123;</div><div class="line">	type: &apos;ADD_TODO&apos;,</div><div class="line">	payload: &apos;Learn Redux&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码中，<code>store.dispatch</code>接受一个Action对象作为参数，将他发送出去。<br>结合 <code>Action Creator</code>，这段代码可以改写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.dispatch(addTodo(‘Learn Redux’));</div></pre></td></tr></table></figure>
<h4 id="6、Reducer"><a href="#6、Reducer" class="headerlink" title="6、Reducer"></a>6、Reducer</h4><p><code>Store</code>收到<code>Action</code>以后，必须给出一个新的<code>State</code>，这样<code>View</code>才会发生变化，这种<code>State</code>的计算过程就叫做<code>Reducer</code>。<code>Reducer</code>是一个函数，它接受<code>Action</code>和当前<code>State</code>作为参数，返回一个新的<code>State</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const reducer = function(state,action) &#123;</div><div class="line">	// ...</div><div class="line">	return new_state;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个应用的状态，可以作为State的默认值，下面是一个实际例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">const defaultState = 0;</div><div class="line">const reducer = (state = defaultState,action) =&gt; &#123;</div><div class="line">	switch (action.type) &#123;</div><div class="line">		case &apos;ADD&apos;:</div><div class="line">			return state + action.payload;</div><div class="line">		default:</div><div class="line">			return state;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const state = reducer(1,&#123;</div><div class="line">	type: &apos;ADD&apos;,</div><div class="line"> 	payload: 2</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码中，<code>reducer</code>函数收到名为<code>ADD</code>的<code>Action</code>以后，就返回一个新的<code>State</code>,作为加法的计算结果，其他计算的逻辑（比如减法)，也可以根据<code>Action</code>的不同来实现。</p>
<p>实际应用中，<code>reducer</code>函数不用像上面这样手动调用，<code>store.dispatch</code>方法会触发<code>Reducer</code>的自动执行。为此，<code>Store</code>需要知道<code>Reducer</code>函数，做法就是在生成Store的时候，将<code>Reducer</code>传入<code>createStore</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;</div><div class="line">const store = createStore(reducer);</div></pre></td></tr></table></figure>
<p>上面代码中，<code>createStore</code>接受<code>Reducer</code>作为参数，生成一个新的Store，以后每当<code>store.dispatch</code>发送过来一个新的<code>Action</code>，就会自动调用<code>Reducer</code>，得到<code>State</code>。</p>
<p>为什么这个函数叫做<code>Reducer</code>呢？因为它可以作为数据的<code>reduce</code>方法的函数，请看下面的例子，一系列<code>Action</code>对象按照排序作为一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const actions = &#123;</div><div class="line">	&#123; type: &apos;ADD&apos;, payload: 0&#125;,</div><div class="line">	&#123; type: &apos;ADD&apos;, payload: 1&#125;,</div><div class="line">	&#123; type: &apos;ADD&apos;, payload: 2&#125;</div><div class="line">&#125;</div><div class="line">const total = actions.reduce(reducer,0); //3</div></pre></td></tr></table></figure>
<p>上面代码中，数组<code>actions</code>表示依次有三个<code>Action</code>，分别是加<code>0</code>、加<code>1</code>和加<code>2</code>。数组的<code>reduce</code>方法接受<code>Reducer</code>函数作为参数，就可以直接得到最终的状态<code>3</code>。</p>
<h4 id="7、纯函数"><a href="#7、纯函数" class="headerlink" title="7、纯函数"></a>7、纯函数</h4><p><code>Reducer</code>函数最重要的特征是，它是一个纯函数，也就是说，只要是同样的输入，必定得到同样的输出。纯函数是函数式编程的概念，必须遵守以下规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">不得改写参数</div><div class="line">不能调用系统I/O的API</div><div class="line">不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果</div></pre></td></tr></table></figure>
<p>由于<code>Reducer</code>是纯函数，就可以保证同样的<code>State</code>，必定得到同样的<code>View</code>，但也正因为这一点，<code>Reducer</code>函数里不能改变<code>State</code>，必须返回一个全新的对象。参考下面的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// State 是一个对象</div><div class="line">function reducer(state, action) &#123;</div><div class="line">	return Object.assign(&#123;&#125;,state,&#123;thingToChange&#125;);</div><div class="line">	// 或者</div><div class="line">	return &#123; ...state,...newState &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// State 是一个数组</div><div class="line">function reducer(state, action) &#123;</div><div class="line">	return [ ...state, newItem ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最好把<code>State</code>对象设成只读，你没法改变它，要得到新的<code>State</code>,唯一办法就是生成一个新对象，这样的好处是，任何时候，与某个View对应的<code>State</code>总是一个不变的对象。</p>
<h4 id="store-subscribe"><a href="#store-subscribe" class="headerlink" title="store.subscribe()"></a>store.subscribe()</h4><p><code>Store</code>允许使用<code>store.subscribe</code>方法设置监听函数，一旦<code>State</code>发生变化，就自动执行这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;;</div><div class="line">const store = createStore(reducer);</div><div class="line"></div><div class="line">store.subscribe(listener);</div></pre></td></tr></table></figure>
<p>显然，只要把<code>View</code>的更新函数（对于React项目，就是组件的render方法或setState方法）放入<code>listen</code>，就会实现<code>View</code>的自动渲染。</p>
<p><code>store.subscribe</code>方法返回一个函数，调用这个函数就可以解除监听。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let unsubscribe = store.subscribe(() =&gt; </div><div class="line">	console.log(store.getState())</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="Reducer拆分"><a href="#Reducer拆分" class="headerlink" title="Reducer拆分"></a>Reducer拆分</h3><p><code>Reducer</code>函数负责生成<code>State</code>，由于整个应用只有一个<code>State</code>对象，包含所有数据，对于大型应用来说，这个<code>State</code>必然十分庞大，导致<code>Reducer</code>函数也十分庞大。<br>请看下面的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123;</div><div class="line">	const &#123; type, payload &#125; = action;</div><div class="line">	switch (type) &#123;</div><div class="line">		case ADD_CHAT:</div><div class="line">			return Object.assign(&#123;&#125;,state,&#123;</div><div class="line">				chatLog: state.chatLog.concat(payload)</div><div class="line">			&#125;);</div><div class="line">		case CHANNGE_STATUS:</div><div class="line">			return Object.assign(&#123;&#125;, state, &#123;</div><div class="line">				statusMessage: payload</div><div class="line">			&#125;);</div><div class="line">		case CHANGE_USERNAME:</div><div class="line">			return Object.assign(&#123;&#125;,state, &#123;</div><div class="line">				userName: payload</div><div class="line">			&#125;);</div><div class="line">		default: return state;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，三种<code>Action</code>分别改变<code>State</code>的三个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ADD_CHAT: chatLog属性</div><div class="line">CHANGE_STATUS: statusMessage属性</div><div class="line">CHANGE_USERNAME: userName属性</div></pre></td></tr></table></figure>
<p>这三个属性之前没有联系，这提示我们可以把<code>Reducer</code>函数拆分，不同的函数负责处理不同属性，最终把它们合并成一个大的<code>Reducer</code>即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123;</div><div class="line">	return &#123;</div><div class="line">		chatLog: chatLog(state.chatLog,action),</div><div class="line">		statusMessage: statusMessage(state.statusMessage,action),</div><div class="line">		userName: userName(state.userName, action)</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，<code>Reducer</code>函数被拆分成了三个小函数，每一个负责生产对应的属性。</p>
<p>这样一拆，<code>Reducer</code>就容易读写多了，而且，这种拆分与<code>React</code>应用的结构相吻合： 一个<code>React</code>跟组件由许多子组件构成这就是说子组件与子Reducer完全可以对应。</p>
<p>Redux提供了一个<code>combineReducers</code>方法，用于Reducer的拆分，你只要定义各个子<code>Reducer</code>函数，然后用这个方法，将它们合成一个大的<code>Reducer</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import &#123; combineReducers &#125; from &apos;redux&apos;</div><div class="line"></div><div class="line">const chatReducer = combineReducers(&#123;</div><div class="line">	chatLog,</div><div class="line">	statusMessage,</div><div class="line">	userName</div><div class="line">&#125;)</div><div class="line"></div><div class="line">export default todoApp;</div></pre></td></tr></table></figure>
<p>这种写法有一个前提，<code>State</code>的属性名必须与子<code>Redecer</code>同名，如果不同名，就要采用下面的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">const reducer = combineReducers(&#123;</div><div class="line">	a: doSomethingWithA,</div><div class="line">	b: processB,</div><div class="line">	c: c</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 等同于</div><div class="line">function reducer(state = &#123;&#125;, action) &#123;</div><div class="line">	return &#123;</div><div class="line">		a: doSomethingWithA(state.a,action),</div><div class="line">		b: processB(state.b,action),</div><div class="line">		c: c(state.c,action)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总之，<code>combineReducers()</code>做的就是产生一个整体的<code>Reducer</code>函数，该函数根据<code>State</code>的key去执行相应的子<code>Reducer</code>，并将返回结果合并成一个大的<code>State</code>对象。</p>
<p>下面是<code>combineReducer</code>的简单实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const combineReducers = reducers =&gt; &#123;</div><div class="line">	return (state = &#123;&#125;, action) =&gt; &#123;</div><div class="line">		return Object.keys(reducers).reduce(</div><div class="line">			(nextState,key) =&gt; &#123;</div><div class="line">				nextState[key] = reducers[key](state[key],action);</div><div class="line">				return nextState;	</div><div class="line">			&#125;,</div><div class="line">			&#123;&#125;</div><div class="line">		);</div><div class="line">	&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>你可以把所有字<code>Reducer</code>放在一个文件里面，然后统一引入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import &#123; combineReducers &#125; from &apos;redux&apos;</div><div class="line">import * as reducers from &apos;./reducers&apos;</div><div class="line">const reducer = combineReducers(reducers)</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="external">Redux 入门教程（一) by 阮一峰</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;上一篇文章&lt;a href=&quot;http://jianwl.com/2017/04/19/Redux%E5%85%A5%E9%97%A8/#mo
    
    </summary>
    
      <category term="React" scheme="http://jianwl.com/categories/React/"/>
    
    
      <category term="React" scheme="http://jianwl.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JS之易错点</title>
    <link href="http://jianwl.com/2017/04/20/JS%E4%B9%8B%E6%98%93%E9%94%99%E7%82%B9/"/>
    <id>http://jianwl.com/2017/04/20/JS之易错点/</id>
    <published>2017-04-19T23:37:56.000Z</published>
    <updated>2017-04-20T12:06:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>刚接触JS语法，有许多易出错的点，将这些点记录下来，备忘。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="1-var变量声明提升"><a href="#1-var变量声明提升" class="headerlink" title="1. var变量声明提升"></a>1. var变量声明提升</h4><p>声明变量有三种方式：</p>
<p><code>var</code> 声明一个变量，可以选择将其初始化为一个值</p>
<p><code>let</code> 声明一个块作用域的局部变量，可选择将其初始化为一个值</p>
<p><code>const</code> 声明一个只读的常量</p>
<p><code>案例1：</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-20/54570265-file_1492646127490_12e36.png" alt=""></p>
<p><code>案例2：</code> 变量提升后的变量将返回<code>undefined</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-20/90885158-file_1492646887623_17d65.png" alt=""></p>
<h4 id="2-字符串字面量"><a href="#2-字符串字面量" class="headerlink" title="2. 字符串字面量"></a>2. 字符串字面量</h4><p>模板字符串提供一些语法糖来构造字符串，例如：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-20/43060038-file_1492647130780_4999.png" alt=""></p>
<h4 id="3-JS闭包"><a href="#3-JS闭包" class="headerlink" title="3. JS闭包"></a>3. JS闭包</h4><p>当内部函数以某一种方式被任何一个外部函数作用域访问时，就产生闭包了。JS中内部函数可以访问定义在外部函数中的所有变量和函数，但是外部函数却不能访问定义在函数内部的变量和函数。如果需要访问，则可以使用闭包。</p>
<p><code>案例1：</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-20/94058572-file_1492653762314_14c1b.png" alt=""></p>
<p><code>案例2：</code></p>
<p><img src="http://i1.piimg.com/567571/cdb2b25d28952ef4.png" alt=""></p>
<h4 id="4-箭头函数"><a href="#4-箭头函数" class="headerlink" title="4. 箭头函数"></a>4. 箭头函数</h4><p>箭头函数不绑定自己的<code>this</code>、<code>arguments</code>、<code>super</code>或<code>new.target</code>，此外箭头函数最好在非方法函数中使用，且不能用作构造函数。</p>
<p><code>1、 基础语法</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 多参数</div><div class="line">(param1, param2,..., paramN) =&gt; &#123; statements &#125;</div><div class="line">(param1, param2,..., paramN) =&gt; expression</div><div class="line">// 等价于: =&gt; &#123; return expression &#125;</div><div class="line"></div><div class="line">// 一个参数，圆括号可选</div><div class="line">(singleParam) =&gt; &#123;statements&#125;</div><div class="line">singleParam =&gt; &#123;statements&#125;</div><div class="line"></div><div class="line">// 无参的函数需要使用圆括号</div><div class="line">() =&gt; &#123; statements &#125;</div></pre></td></tr></table></figure>
<p><code>2、高级语法</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 返回文字表达式时应当用圆括号将其包起来：</div><div class="line">params =&gt; (&#123;foo: bar&#125;)</div><div class="line"></div><div class="line">// 支持 Rest parameters 和 default parameters</div><div class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</div><div class="line">(param1 = defaultValue1, param2, ...,paramN = defaultValueN ) =&gt; &#123; statements &#125;</div><div class="line"></div><div class="line">// 支持参数列表中的解构赋值</div><div class="line">var f = ([a,b] = [1,2],&#123;x: c&#125; = &#123;x: a+b&#125;) =&gt; a + b + c;</div></pre></td></tr></table></figure>
<p><code>案例1</code></p>
<p><img src="http://i1.piimg.com/567571/30e0246c31be8206.png" alt=""></p>
<h4 id="5-解构"><a href="#5-解构" class="headerlink" title="5. 解构"></a>5. 解构</h4><p><img src="http://i2.muimg.com/567571/b29447a502915ebf.png" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#变量声明提升(Variable_hoisting" target="_blank" rel="external">MSDN之JS基础教程</a>)</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;刚接触JS语法，有许多易出错的点，将这些点记录下来，备忘。&lt;/p&gt;
&lt;h3 id=&quot;实战&quot;&gt;&lt;a href=&quot;#实战&quot; class=&quot;hea
    
    </summary>
    
      <category term="JavaScript" scheme="http://jianwl.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://jianwl.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS之基本数据结构</title>
    <link href="http://jianwl.com/2017/04/19/JS%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://jianwl.com/2017/04/19/JS之基本数据结构/</id>
    <published>2017-04-19T15:12:50.000Z</published>
    <updated>2017-04-19T15:37:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>JavaScript</code>是一种弱类型语言，意味着你不用提前声明变量的类型，在程序运行的过程中，类型会被自动确定。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var foo = 42; // foo is a Number now</div><div class="line">var foo = &quot;bar&quot;; // foo is a String now</div><div class="line">var foo = true; // foo is a Boolean now</div></pre></td></tr></table></figure>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>最新的<code>ECMASCRIPT</code>标准定义了7种数据结构分别为<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>、<code>Object</code>。 </p>
<h4 id="1-布尔类型"><a href="#1-布尔类型" class="headerlink" title="1. 布尔类型"></a>1. 布尔类型</h4><p>布尔表示一个逻辑实体，可以有两个值：<code>true</code>和<code>false</code></p>
<h4 id="2-Null-类型"><a href="#2-Null-类型" class="headerlink" title="2. Null 类型"></a>2. Null 类型</h4><p>Null类型只有一个值: null</p>
<h4 id="3-Undefined-类型"><a href="#3-Undefined-类型" class="headerlink" title="3. Undefined 类型"></a>3. Undefined 类型</h4><p>一个没有被赋值的变量会有个默认值<code>undefined</code></p>
<h4 id="4-数字类型"><a href="#4-数字类型" class="headerlink" title="4. 数字类型"></a>4. 数字类型</h4><h4 id="5-字符串类型"><a href="#5-字符串类型" class="headerlink" title="5. 字符串类型"></a>5. 字符串类型</h4><h4 id="6-符号类型"><a href="#6-符号类型" class="headerlink" title="6. 符号类型"></a>6. 符号类型</h4><p>符号「Symbols」是<code>ECMASCRIPT</code>第六版定义的，符号类型是唯一的并且是不可修改的，并且也可以作为Object的key的值。</p>
<h4 id="7-对象"><a href="#7-对象" class="headerlink" title="7. 对象"></a>7. 对象</h4><p>在<code>JavaScript</code>里，对象可以被看作是一组属性的组合。用对象字面量语法来定义对象时，会自动初始化一组属性。 </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="external">MSDN之JS数据结构</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;是一种弱类型语言，意味着你不用提前声明变量的类型，在程序运行的过程中，类型会被自动确定。例如：
    
    </summary>
    
      <category term="JavaScript" scheme="http://jianwl.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://jianwl.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS之运算符</title>
    <link href="http://jianwl.com/2017/04/19/JS%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://jianwl.com/2017/04/19/JS之运算符/</id>
    <published>2017-04-19T14:18:37.000Z</published>
    <updated>2017-04-19T15:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本节主要来学习<code>JS</code>常用的一些运算符，如<code>Spread运算符</code>、<code>typeof运算符</code>、<code>instanceof运算符</code>。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="1、Spread运算符「…」"><a href="#1、Spread运算符「…」" class="headerlink" title="1、Spread运算符「…」"></a>1、Spread运算符「…」</h4><p><code>场景：</code> 用于赋值数组的部分</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-19/45847198-file_1492611937925_105b8.png" alt=""></p>
<h4 id="2、typeof运算符"><a href="#2、typeof运算符" class="headerlink" title="2、typeof运算符"></a>2、typeof运算符</h4><p><code>场景：</code>返回一个用于标识表达式的数据类型的字符串,<code>typeof</code> 返回六种可能的值：“数字”、“字符串”、“布尔值”、“对象”、“函数”和“未定义”</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-19/46037312-file_1492612991793_11991.png" alt=""></p>
<h4 id="3、三元运算符「-」"><a href="#3、三元运算符「-」" class="headerlink" title="3、三元运算符「?:」"></a>3、三元运算符「?:」</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-19/48353265-file_1492613129543_743e.png" alt=""></p>
<h4 id="4、IN运算符"><a href="#4、IN运算符" class="headerlink" title="4、IN运算符"></a>4、<code>IN</code>运算符</h4><p><code>场景：</code>测试一个对象中是否存在一种属性。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-19/92241650-file_1492613451214_106bc.png" alt=""></p>
<h4 id="5、instanceof运算符"><a href="#5、instanceof运算符" class="headerlink" title="5、instanceof运算符"></a>5、<code>instanceof</code>运算符</h4><p><code>场景：</code>返回一个布尔值，该值指示一个对象是否为特定类的一个实例。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-19/74839833-file_1492613994605_12dec.png" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://msdn.microsoft.com/zh-cn/library/dn919259(v=vs.94" target="_blank" rel="external">MSDN之运算符</a>.aspx)</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="external">MSDN之JS数据结构</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本节主要来学习&lt;code&gt;JS&lt;/code&gt;常用的一些运算符，如&lt;code&gt;Spread运算符&lt;/code&gt;、&lt;code&gt;typeof运算符
    
    </summary>
    
      <category term="JavaScript" scheme="http://jianwl.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://jianwl.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Redux入门</title>
    <link href="http://jianwl.com/2017/04/19/Redux%E5%85%A5%E9%97%A8/"/>
    <id>http://jianwl.com/2017/04/19/Redux入门/</id>
    <published>2017-04-19T00:01:49.000Z</published>
    <updated>2017-04-19T13:12:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Redux</code>是参考<code>Flux</code>架构思想的库，对<code>Flux</code>许多冗余的部分做了简化。<code>Redux</code>本身只把自己定位成一个<code>可预测的状态容器</code>，接下来学习<code>Redux</code>的三大原则、并实战<code>Redux</code>和<code>React</code>如何结合使用。</p>
<h3 id="Redux运行流程"><a href="#Redux运行流程" class="headerlink" title="Redux运行流程"></a>Redux运行流程</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-11/53696420-file_1491870916439_e756.png" alt=""></p>
<h3 id="Redux三大原则"><a href="#Redux三大原则" class="headerlink" title="Redux三大原则"></a>Redux三大原则</h3><h4 id="1-单一数据源"><a href="#1-单一数据源" class="headerlink" title="1. 单一数据源"></a>1. 单一数据源</h4><p>在<code>Redux</code>中，一个应用永远只有唯一的数据源，这样做的好处在于整个应用状态都保存在一个对象中，这样我们随时可以提取出整个应用的状态进行持久化。同时<code>Redux</code>提供工具函数<code>combineReducers</code>化解数据源对象过于庞大的问题。后文将会介绍。</p>
<h4 id="2-状态是只读的"><a href="#2-状态是只读的" class="headerlink" title="2. 状态是只读的"></a>2. 状态是只读的</h4><p>在<code>Redux</code>中，会定义一个<code>reducer</code>，他的功能是根据当前触发的action对当前应用的状态来进行迭代，并没有直接修改应用的状态，而是返回一份全新的状态。<code>Redux</code>提供的<code>createStore</code>方法会根据reducer生产store，最后可以利用<code>store.dispatch</code>来修改状态。</p>
<h4 id="3-状态修改均由纯函数完成"><a href="#3-状态修改均由纯函数完成" class="headerlink" title="3. 状态修改均由纯函数完成"></a>3. 状态修改均由纯函数完成</h4><p>在<code>Redux</code>中，通过定义<code>reducer</code>来确定状态的修改，而每一个reducer都是纯函数，这样做的好处是，在<code>reducer</code>里对状态的修改变得简单、纯粹、可测试。</p>
<h3 id="Redux核心API"><a href="#Redux核心API" class="headerlink" title="Redux核心API"></a>Redux核心API</h3><p>在<code>Redux</code>中负责响应<code>action</code>并修改数据的角色就是reducer，reducer本质上是一个函数，其函数签名为<code>reducer(previousState,action) =&gt; newState</code>, 可以看出，<code>reducer</code>在处理<code>action</code>的同时，还需要接受一个<code>previousState</code>参数。所以，<code>render</code>的职责是根据<code>previousState</code>和<code>action</code>计算出<code>newState</code>。</p>
<p><code>reduce范例：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">const initialState = &#123;</div><div class="line">	todos: []</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 定义的todos 这个render 在第一次执行的时候，会返回&#123;todos:[]&#125;作为初始化状态</div><div class="line">function todos(previousState = initialState,action) &#123;</div><div class="line">	switch(action.type) &#123;</div><div class="line">	 	case &apos;XXX&apos;: &#123;</div><div class="line">	 		// 具体的业务逻辑</div><div class="line">	 		return newState;</div><div class="line">	 	&#125;</div><div class="line">	 	</div><div class="line">	 	default:</div><div class="line">	 		return previousState;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>getState</td>
<td>获取store中当前的状态</td>
</tr>
<tr>
<td>dispatch(action)</td>
<td>分发一个action，并返回这个action，这是唯一能改变store中数据的方式。</td>
</tr>
<tr>
<td>subscribe(listener)</td>
<td>注册一个监听者，它在store发生变化时被调用</td>
</tr>
<tr>
<td>replaceReducer(nextReducer)</td>
<td>更新当前state里的reducer</td>
</tr>
</tbody>
</table>
<h3 id="Redux实战-加减乘除"><a href="#Redux实战-加减乘除" class="headerlink" title="Redux实战 - 加减乘除"></a>Redux实战 - 加减乘除</h3><p><code>1、入口：index.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;</div><div class="line">import ReactDOM from &apos;react-dom&apos;</div><div class="line">import &#123; createStore &#125; from &apos;redux&apos;</div><div class="line">import Counter from &apos;./components/Counter&apos;</div><div class="line">import counter from &apos;./reducers&apos;</div><div class="line"></div><div class="line">const store = createStore(counter)</div><div class="line">const rootEl = document.getElementById(&apos;root&apos;)</div><div class="line"></div><div class="line">const render = () =&gt; ReactDOM.render(</div><div class="line">    &lt;Counter</div><div class="line">        value=&#123;store.getState()&#125;</div><div class="line">        onIncrement=&#123;() =&gt; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)&#125;</div><div class="line">        onDecrement=&#123;() =&gt; store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;)&#125;</div><div class="line">        onMutil=&#123;() =&gt; store.dispatch(&#123; type : &apos;MUTIL&apos;&#125;)&#125;</div><div class="line">        onDiv=&#123;() =&gt; store.dispatch(&#123; type: &apos;DIV&apos;&#125;)&#125;</div><div class="line">    /&gt;,</div><div class="line">    rootEl</div><div class="line">)</div><div class="line"></div><div class="line">render()</div><div class="line">store.subscribe(render)</div></pre></td></tr></table></figure>
<p><code>2、纯函数：reducers/index.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">export default (state = 0, action) =&gt; &#123;</div><div class="line">  switch (action.type) &#123;</div><div class="line">    case &apos;INCREMENT&apos;:</div><div class="line">      return state + 1</div><div class="line">    case &apos;DECREMENT&apos;:</div><div class="line">      return state - 1</div><div class="line">    case &apos;MUTIL&apos;:</div><div class="line">      return state * 2</div><div class="line">    case &apos;DIV&apos;:</div><div class="line">      return state / 2</div><div class="line">    default:</div><div class="line">      return state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>3、组件：components/Counter.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;</div><div class="line"></div><div class="line">class Counter extends Component &#123;</div><div class="line">    static propTypes = &#123;</div><div class="line">        value: PropTypes.number.isRequired,</div><div class="line">        onIncrement: PropTypes.func.isRequired,</div><div class="line">        onDecrement: PropTypes.func.isRequired,</div><div class="line">        onMutil: PropTypes.func.isRequired,</div><div class="line">        onDiv: PropTypes.func.isRequired</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    incrementIfOdd = () =&gt; &#123;</div><div class="line">        if (this.props.value % 2 !== 0) &#123;</div><div class="line">            this.props.onIncrement()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    incrementAsync = () =&gt; &#123;</div><div class="line">        setTimeout(this.props.onIncrement, 1000)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        const &#123; value, onIncrement, onDecrement, onMutil, onDiv &#125; = this.props</div><div class="line">        return (</div><div class="line">            &lt;p&gt;</div><div class="line">                Clicked: &#123;value&#125; times</div><div class="line">                &#123;&apos; &apos;&#125;</div><div class="line">                &lt;button onClick=&#123;onIncrement&#125;&gt;</div><div class="line">                    +</div><div class="line">                &lt;/button&gt;</div><div class="line">                &#123;&apos; &apos;&#125;</div><div class="line">                &lt;button onClick=&#123;onDecrement&#125;&gt;</div><div class="line">                    -</div><div class="line">                &lt;/button&gt;</div><div class="line">                &#123;&apos; &apos;&#125;</div><div class="line">                &lt;button onClick=&#123;this.incrementIfOdd&#125;&gt;</div><div class="line">                    Increment if odd</div><div class="line">                &lt;/button&gt;</div><div class="line">                &#123;&apos; &apos;&#125;</div><div class="line">                &lt;button onClick=&#123;this.incrementAsync&#125;&gt;</div><div class="line">                    Increment async</div><div class="line">                &lt;/button&gt;</div><div class="line">                &#123;&apos; &apos;&#125;</div><div class="line">                &lt;button onClick=&#123;onMutil&#125;&gt;</div><div class="line">                    *</div><div class="line">                &lt;/button&gt;</div><div class="line">                &#123;&apos; &apos;&#125;</div><div class="line">                &lt;button onClick=&#123;onDiv&#125;&gt;</div><div class="line">                    /</div><div class="line">                &lt;/button&gt;</div><div class="line">            &lt;/p&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default Counter</div></pre></td></tr></table></figure>
<p><code>4、运行效果：</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-19/34742256-file_1492607123287_af13.png" alt=""></p>
<p><code>5、Redux API接口介绍:</code></p>
<p><code>createStore(reducer,[preloadedState], enhancer)</code> 创建一个 Redux store 来以存放应用中所有的 state。</p>
<ul>
<li><code>reducer</code>「function」接收两个参数，分别是当前的 state 树和要处理的 action，返回新的 state 树。</li>
<li><code>[preloadedState]</code>「any」: 初始时的 state</li>
<li><code>enhancer</code> 「function」: <code>Store enhancer</code> 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1、<a href="http://cn.redux.js.org/docs/api/createStore.html" target="_blank" rel="external">Redux中文文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Redux&lt;/code&gt;是参考&lt;code&gt;Flux&lt;/code&gt;架构思想的库，对&lt;code&gt;Flux&lt;/code&gt;许多冗余的部分
    
    </summary>
    
      <category term="React" scheme="http://jianwl.com/categories/React/"/>
    
    
      <category term="React" scheme="http://jianwl.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Java8之不常用却很有用的知识点</title>
    <link href="http://jianwl.com/2017/04/17/Java8%E4%B9%8B%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%8D%B4%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://jianwl.com/2017/04/17/Java8之不常用却很有用的知识点/</id>
    <published>2017-04-17T06:07:13.000Z</published>
    <updated>2017-04-17T10:42:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="1-forEach-VS-forEachOrdered"><a href="#1-forEach-VS-forEachOrdered" class="headerlink" title="1. forEach VS forEachOrdered"></a>1. forEach VS forEachOrdered</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test_005()&#123;</div><div class="line">    List&lt;String&gt; strs = Arrays.asList(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;);</div><div class="line">    strs.stream().parallel().forEach(str -&gt; System.out.println(&quot;forEach =&gt; &quot; + str));</div><div class="line">    strs.stream().parallel().forEachOrdered(str -&gt; System.out.println(&quot;forEachOrdered =&gt; &quot; + str));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>结果：</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/16-12-11/96792814-file_1481436578266_14fcc.png" alt=""></p>
<p><code>分析</code></p>
<p>并行处理数据时，<code>forEach</code>处理的数据是无序的，而<code>forEachOrdered</code>处理数据是按照输入流的顺序处理的。</p>
<h4 id="2-合并Map"><a href="#2-合并Map" class="headerlink" title="2. 合并Map"></a>2. 合并Map</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@RunWith(JUnit4.class)</div><div class="line">public class BasicTest &#123;</div><div class="line">    /**</div><div class="line">     * 将sub合并至total,若在total中存在该键(key),则键值合并;</div><div class="line">     */</div><div class="line">    @Test</div><div class="line">    public void test_001()&#123;</div><div class="line">        Map&lt;String,List&lt;Integer&gt;&gt; total = Maps.newHashMap();</div><div class="line">        Map&lt;String,List&lt;Integer&gt;&gt; sub = Maps.newHashMap();</div><div class="line"></div><div class="line">        total.put(&quot;num1&quot;, Arrays.asList(1,2,3,4,11));</div><div class="line">        total.put(&quot;num2&quot;,Arrays.asList(1,2,3,4));</div><div class="line">        total.put(&quot;num3&quot;,Arrays.asList(1,2,3,4));</div><div class="line">        total.put(&quot;num4&quot;,Arrays.asList(1,2,3,4));</div><div class="line"></div><div class="line">        sub.put(&quot;num1&quot;,Arrays.asList(1,2,3,4,5,6,7));</div><div class="line">        sub.put(&quot;num2&quot;,Arrays.asList(1,2,3,4,4,5,6,7));</div><div class="line"></div><div class="line">        sub.keySet().forEach(key -&gt; total.merge(key,sub.get(key),(v1,v2) -&gt; Arrays.asList(v1,v2).stream().flatMap(Collection::stream).distinct().collect(Collectors.toList())));</div><div class="line"></div><div class="line">        System.out.println(&quot;total =&gt; &quot; + JSON.toJSONString(total));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-2-21/83737621-file_1487691562243_10db7.png" alt=""></p>
<h4 id="3-排序Map"><a href="#3-排序Map" class="headerlink" title="3. 排序Map"></a>3. 排序Map</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test_033() &#123;</div><div class="line">    Map&lt;String,Integer&gt; map = Maps.newHashMap();</div><div class="line">    map.put(&quot;key1&quot;,9);</div><div class="line">    map.put(&quot;key2&quot;,1);</div><div class="line">    map.put(&quot;key3&quot;,3);</div><div class="line">    map.put(&quot;key4&quot;,2);</div><div class="line">    LinkedHashMap&lt;String,Integer&gt; linkedHashMap = map.entrySet().stream().sorted(Map.Entry.comparingByValue((v1,v2) -&gt; v2.compareTo(v1))).collect(Collectors.toMap(Map.Entry::getKey,Map.Entry::getValue,(e1,e2) -&gt; e1,LinkedHashMap::new));</div><div class="line">    System.out.println(linkedHashMap);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-17/80305570-file_1492423465236_f04f.png" alt=""></p>
<h4 id="4-Collections-toMap重复key的处理方式"><a href="#4-Collections-toMap重复key的处理方式" class="headerlink" title="4. Collections.toMap重复key的处理方式"></a>4. <code>Collections.toMap</code>重复key的处理方式</h4><p><code>声明User对象</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class User&#123;</div><div class="line">    private Integer id;</div><div class="line">    private String name;</div><div class="line"></div><div class="line">    public User(Integer id, String name) &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Integer getId() &#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setId(Integer id) &#123;</div><div class="line">        this.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>测试类：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">  public void test_034() &#123;</div><div class="line">      User u1 = new User(1,&quot;张三&quot;);</div><div class="line">      User u2 = new User(1,&quot;王武&quot;);</div><div class="line">      User u3 = new User(2,&quot;李四&quot;);</div><div class="line">      Map&lt;Integer,String&gt; map = Arrays.asList(u1,u2,u3).stream().collect(Collectors.toMap(User::getId, User::getName,(v1,v2) -&gt; v1,HashMap::new));</div><div class="line">      System.out.println(map);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><code>运行结果：</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-17/80087753-file_1492425664414_3370.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h3&gt;&lt;h4 id=&quot;1-forEach-VS-forEachOrdered&quot;&gt;&lt;a href=&quot;#1-forEach-VS-forEachOr
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>React入门实战(二)</title>
    <link href="http://jianwl.com/2017/04/09/React%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98-%E4%BA%8C/"/>
    <id>http://jianwl.com/2017/04/09/React入门实战-二/</id>
    <published>2017-04-09T05:02:42.000Z</published>
    <updated>2017-04-09T09:27:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直以来都很想去学习React，前一段时间因为业务的需要先去学习<code>Python</code>，Python已基本入门，未来一段时间将会来持续学习React技术栈。</p>
<h3 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h3><p>在<code>React</code>中，数据是自顶向下单向流动的，即从父组件到子组件。<code>state</code>和<code>props</code>是<code>React</code>组件中最重要的概念。<code>state</code>只关心每个组件自己内部的状态，这些状态只能在组件内改变。<code>props</code>是<code>React</code>用来让组件之间互相联系的一种机制。</p>
<h3 id="React组件生命周期"><a href="#React组件生命周期" class="headerlink" title="React组件生命周期"></a>React组件生命周期</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-9/62453041-file_1491716351303_165d7.png" alt="React生命周期整体流程图"></p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="1-state范例"><a href="#1-state范例" class="headerlink" title="1. state范例"></a>1. <code>state</code>范例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import ReactDOM from &apos;react-dom&apos;</div><div class="line"></div><div class="line">class App03 extends Component &#123;</div><div class="line"></div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props);</div><div class="line">        this.state = &#123;date: new Date()&#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    componentDidMount() &#123;</div><div class="line">        this.timerID = setInterval(</div><div class="line">            () =&gt; this.tick(),</div><div class="line">            1000</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    componentWillUnmount() &#123;</div><div class="line">        clearInterval(this.timerID);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tick() &#123;</div><div class="line">        this.setState(&#123;</div><div class="line">            date: new Date()</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line"></div><div class="line">        return (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h1&gt;Hello, world!&lt;/h1&gt;</div><div class="line">                &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">ReactDOM.render(&lt;App03/&gt;,document.getElementById(&apos;root&apos;));</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-9/36837049-file_1491716947107_15e99.png" alt=""></p>
<h4 id="2-props范例"><a href="#2-props范例" class="headerlink" title="2. props范例"></a>2. <code>props</code>范例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component,PropTypes &#125; from &apos;react&apos;;</div><div class="line">import ReactDOM from &apos;react-dom&apos;</div><div class="line"></div><div class="line">class App04 extends Component &#123;</div><div class="line">    static propTypes = &#123;</div><div class="line">        name : PropTypes.string,</div><div class="line">    &#125;</div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;div&gt;</div><div class="line">                Hello &#123;this.props.name&#125;</div><div class="line">            &lt;/div&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(&lt;App04 name=&quot;Judy&quot;/&gt;,document.getElementById(&apos;root&apos;));</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-9/62676968-file_1491716985916_8d8d.png" alt=""></p>
<h4 id="3-绑定事件"><a href="#3-绑定事件" class="headerlink" title="3. 绑定事件"></a>3. 绑定事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component,PropTypes &#125; from &apos;react&apos;;</div><div class="line">import ReactDOM from &apos;react-dom&apos;</div><div class="line"></div><div class="line">class App09 extends Component &#123;</div><div class="line"></div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props);</div><div class="line"></div><div class="line">        this.handleChange = this.handleChange.bind(this);</div><div class="line"></div><div class="line">        this.state = &#123;</div><div class="line">            coffee : [],</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleChange(e) &#123;</div><div class="line">        const &#123;checked, value &#125; = e.target;</div><div class="line">        let &#123; coffee &#125; = this.state;</div><div class="line"></div><div class="line">        if(checked &amp;&amp; coffee.indexOf(value) === -1) &#123;</div><div class="line">            coffee.push(value);</div><div class="line">        &#125; else &#123;</div><div class="line">            coffee = coffee.filter(i =&gt; i !== value);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        this.setState(&#123;</div><div class="line">            coffee,</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        const &#123;coffee&#125; = this.state;</div><div class="line">        const coffeeItems = coffee.map((c =&gt; &lt;li&gt;&#123;c&#125;&lt;/li&gt;));</div><div class="line">        return (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;p&gt;请选择你最喜欢的咖啡:&lt;/p&gt;</div><div class="line">                &lt;label&gt;</div><div class="line">                    &lt;input type=&quot;checkbox&quot; value=&quot;coffee_1&quot; checked=&#123;coffee.indexOf(&apos;coffee_1&apos;) !== -1&#125; onChange=&#123;this.handleChange&#125;/&gt;</div><div class="line">                    coffee_1</div><div class="line">                &lt;/label&gt;</div><div class="line">                &lt;br/&gt;</div><div class="line">                &lt;label&gt;</div><div class="line">                    &lt;input type=&quot;checkbox&quot; value=&quot;coffee_2&quot; checked=&#123;coffee.indexOf(&apos;coffee_2&apos;) !== -1&#125; onChange=&#123;this.handleChange&#125;/&gt;</div><div class="line">                    coffee_2</div><div class="line">                &lt;/label&gt;</div><div class="line">                &lt;br/&gt;</div><div class="line">                &lt;label&gt;</div><div class="line">                    &lt;input type=&quot;checkbox&quot; value=&quot;coffee_3&quot; checked=&#123;coffee.indexOf(&apos;coffee_3&apos;) !== -1&#125; onChange=&#123;this.handleChange&#125;/&gt;</div><div class="line">                    coffee_3</div><div class="line">                &lt;/label&gt;</div><div class="line">                &lt;br/&gt;</div><div class="line">                &lt;label&gt;</div><div class="line">                    &lt;input type=&quot;checkbox&quot; value=&quot;coffee_4&quot; checked=&#123;coffee.indexOf(&apos;coffee_4&apos;) !== -1&#125; onChange=&#123;this.handleChange&#125;/&gt;</div><div class="line">                    coffee_4</div><div class="line">                &lt;/label&gt;</div><div class="line">                &lt;br/&gt;</div><div class="line">                &lt;br/&gt;</div><div class="line">                &lt;div&gt;</div><div class="line">                    最后选择的咖啡:</div><div class="line">                    &lt;ul&gt;&#123;coffeeItems&#125;&lt;/ul&gt;</div><div class="line">                &lt;/div&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(&lt;App09/&gt;,document.getElementById(&apos;root&apos;));</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-9/44022370-file_1491724470762_50b0.png" alt=""></p>
<h4 id="4-组件间的通信"><a href="#4-组件间的通信" class="headerlink" title="4. 组件间的通信"></a>4. 组件间的通信</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component,PropTypes &#125; from &apos;react&apos;;</div><div class="line">import ReactDOM from &apos;react-dom&apos;</div><div class="line"></div><div class="line">class ListItem extends Component &#123;</div><div class="line">    static defaultProps = &#123;</div><div class="line">        text : &apos;&apos;,</div><div class="line">        checked: false,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">           &lt;li&gt;</div><div class="line">               &lt;input type=&quot;checkbox&quot; checked=&#123;this.props.checked&#125; onChange=&#123;this.props.onChange&#125;/&gt;</div><div class="line">               &lt;span&gt;&#123;this.props.value&#125;&lt;/span&gt;</div><div class="line">           &lt;/li&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class List extends Component &#123;</div><div class="line">    static defaultProps = &#123;</div><div class="line">        list: [],</div><div class="line">        handleItemChange: () =&gt; &#123;&#125;,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props);</div><div class="line"></div><div class="line">        this.state = &#123;</div><div class="line">            list : this.props.list.map(entry =&gt; (&#123;</div><div class="line">                text: entry.text,</div><div class="line">                checked: entry.checked,</div><div class="line">            &#125;)),</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    onItemChange(entry)&#123;</div><div class="line">        const &#123; list &#125; = this.state ;</div><div class="line"></div><div class="line">        this.setState(&#123;</div><div class="line">            list: list.map(prevEntry =&gt; (&#123;</div><div class="line">                text: prevEntry.text,</div><div class="line">                checked: prevEntry.text === entry.text ?</div><div class="line">                    !prevEntry.checked : prevEntry.checked,</div><div class="line">            &#125;)),</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        this.props.handleItemChange(entry);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;ul&gt;</div><div class="line">                    &#123;this.state.list.map((entry,index) =&gt; (</div><div class="line">                        &lt;ListItem key=&#123;`list-$&#123;index&#125;`&#125; value=&#123;entry.text&#125; checked=&#123;entry.checked&#125; onChange=&#123;this.onItemChange.bind(this,entry)&#125;/&gt;</div><div class="line">                    ))&#125;</div><div class="line">                &lt;/ul&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class App10 extends Component &#123;</div><div class="line"></div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props);</div><div class="line"></div><div class="line">        this.handleItemChange = this.handleItemChange.bind(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleItemChange(item) &#123;</div><div class="line">        console.log(item);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;List list=&#123;[&#123;text: 1&#125;,&#123;text: 2&#125;]&#125; handleItemChange=&#123;this.handleItemChange&#125;/&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(&lt;App10/&gt;,document.getElementById(&apos;root&apos;));</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-9/45259056-file_1491729802101_13081.png" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://facebook.github.io/react/docs/hello-world.html" target="_blank" rel="external">React官方文档</a></li>
<li>深入React技术栈</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一直以来都很想去学习React，前一段时间因为业务的需要先去学习&lt;code&gt;Python&lt;/code&gt;，Python已基本入门，未来一段时间
    
    </summary>
    
      <category term="React" scheme="http://jianwl.com/categories/React/"/>
    
    
      <category term="React" scheme="http://jianwl.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Intellij 常用快捷键</title>
    <link href="http://jianwl.com/2017/04/05/Intellij-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://jianwl.com/2017/04/05/Intellij-常用快捷键/</id>
    <published>2017-04-05T14:15:36.000Z</published>
    <updated>2017-04-06T00:24:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>IntelliJ在业界被公认为最好的java开发工具之一,了解其常用快捷键对于工作效率会有一定提升。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p><strong>查询最近的文件</strong></p>
<p>应用场景：可以快速跳转到之前刚刚查看过的文件。</p>
<p>快捷键：<code>command + E</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/16-9-11/51543212.jpg" alt=""></p>
<p><strong>查看最近编辑的文件</strong></p>
<p>应用场景：可以快速跳转到之前刚刚编辑过的文件。</p>
<p>快捷键：<code>command + shift +  E</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/16-9-11/51543212.jpg" alt=""></p>
<p><strong>快速定位到大括号的开头或结尾</strong></p>
<p>快捷键：<code>command + ]</code> 或 <code>command + [</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/16-9-11/97015680.jpg" alt=""></p>
<p><strong>快速查找类</strong></p>
<p>快捷键：<code>command + N</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/16-9-11/42335832.jpg" alt=""></p>
<p><strong>格式化代码</strong></p>
<p>快捷键：<code>command + alt + L</code></p>
<p><strong>文本替换</strong></p>
<p>快捷键：<code>command + R</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/16-9-11/60502414.jpg" alt=""></p>
<p><strong>全局查找</strong></p>
<p>快捷键： <code>control + shift + F</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/16-9-11/85182590.jpg" alt=""></p>
<p><strong>删除行</strong></p>
<p>快捷键：<code>command + X</code></p>
<p><strong>复制行</strong></p>
<p>快捷键：<code>command + D</code></p>
<p><strong>跳到方法实现处</strong></p>
<p>使用场景：通常我们会声明一个接口，然后让一个类实现这个接口。那么怎么从接口，跳到方法实现处呢？可以用这个快捷键</p>
<p>快捷键： <code>command + alt + B</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/16-9-11/41820209.jpg" alt=""></p>
<p><strong>隐藏工具窗口</strong></p>
<p>快捷键： <code>shift + esc</code><br><img src="http://oc5a5l0a0.bkt.clouddn.com/16-9-11/75772825.jpg" alt=""></p>
<p><strong>定位到具体某一行</strong></p>
<p>快捷键：<code>command + G</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/16-9-11/99125758.jpg" alt=""></p>
<p><strong>复制当前文件的路径</strong></p>
<p>快捷键：<code>command + shift + C</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/16-9-11/26431733.jpg" alt=""></p>
<p><strong>重命名</strong></p>
<p>快捷键：<code>shift + fn + F6</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/16-9-11/88468445.jpg" alt=""></p>
<p><strong>根据接口或抽象类找到实现/继承类</strong></p>
<p>快捷键：<code>alt + command + B</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-6/32445215-file_1491438185245_a538.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;IntelliJ在业界被公认为最好的java开发工具之一,了解其常用快捷键对于工作效率会有一定提升。&lt;/p&gt;
&lt;h3 id=&quot;场景&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="Intellij IDEA" scheme="http://jianwl.com/categories/Intellij-IDEA/"/>
    
    
      <category term="Intellij IDEA" scheme="http://jianwl.com/tags/Intellij-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>TCP之网络基础知识</title>
    <link href="http://jianwl.com/2017/04/04/TCP%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://jianwl.com/2017/04/04/TCP之网络基础知识/</id>
    <published>2017-04-04T03:38:28.000Z</published>
    <updated>2017-04-04T07:40:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>TCP</code>是网络编程的基础，这一节我们主要来学习<code>协议分层</code>、<code>ARP</code>、<code>RARP</code>、<code>IP</code> 、<code>Mac地址</code>、<code>OSPF路由协议</code>、<code>硬件设备介绍</code>。</p>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><h4 id="1-OSI-7层协议-amp-各层的作用"><a href="#1-OSI-7层协议-amp-各层的作用" class="headerlink" title="1. OSI 7层协议 &amp; 各层的作用"></a>1. OSI 7层协议 &amp; 各层的作用</h4><p><code>OSI</code>参考模型分为7层，上下层之间进行交互时所遵循的约定叫<code>接口</code>，同一层之间的交互所遵循的约定叫<code>协议</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">层</th>
<th style="text-align:center">分层名称</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">每层功能概览</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">应用层</td>
<td style="text-align:center">针对特定应用的协议</td>
<td style="text-align:center">如：电子邮件 → 电子邮箱协议；文件传输 → 文件传输协议</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">表示层</td>
<td style="text-align:center">设备固有数据格式和网络标准数据格式的转换</td>
<td style="text-align:center">接收不同表现形式的信息，如文字流、图像、声音等</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">会话层</td>
<td style="text-align:center">负责建立和断开通讯，以及<strong>数据的分割</strong>等数据传输相关的管理</td>
<td style="text-align:center">何时建立连接，何时断开连接以及保持多久的连接？</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">传输层</td>
<td style="text-align:center">只在通信双方的节点上进行处理，而无需再路由器上处理，起着可靠传输的作用。</td>
<td style="text-align:center"><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-4/76951531-file_1491280215483_aa6e.png" alt=""></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">网络层</td>
<td style="text-align:center">将数据传输到目标地址，目标地址可以是多个网络通过路由器连接而成的某一个地址。这一层主要<strong>负责寻址</strong>和<strong>路由选择</strong>。</td>
<td style="text-align:center"><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-4/17373754-file_1491280668058_18508.png" alt=""></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center">负责物理层面上的互联、节点之间的通信传输，将<code>0</code>、<code>1</code>序列划分为具有意义的数据帧传给对端</td>
<td style="text-align:center"><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-4/4389953-file_1491281059377_14847.png" alt=""></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">物理层</td>
<td style="text-align:center">负责<code>0</code>、<code>1</code>比特流与电压高低、光的闪灭之间的互换</td>
<td style="text-align:center"><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-4/80710941-file_1491281893820_70a6.png" alt=""></td>
</tr>
</tbody>
</table>
<h4 id="2-一个请求的从发送到返回都经历了什么？"><a href="#2-一个请求的从发送到返回都经历了什么？" class="headerlink" title="2. 一个请求的从发送到返回都经历了什么？"></a>2. 一个请求的从发送到返回都经历了什么？</h4><p><code>HTTP请求「应用层」</code> → <code>DNS协议，域名映射IP</code> → <code>HTTP基于TCP/IP协议「传输层」</code> → <code>ARP协议获取接收端Mac地址 通过OSPF路由协议找到目标主机「网络层」</code> → <code>传输数据帧「数据链路层」</code> → <code>将计算机二进制 0、1信号 转换为电压的高低电平「物理层」</code></p>
<h4 id="3-ARP"><a href="#3-ARP" class="headerlink" title="3. ARP"></a>3. ARP</h4><p>只要确定<code>IP</code>地址，就可以向这个目标地址发送<code>IP</code>数据报，然后在<strong>数据链路层</strong>，进行实际通信时需要每个IP地址所对应的<code>MAC</code>地址。</p>
<p><code>ARP</code>是一个解决地址问题的协议，以目标<code>IP</code>地址作为线索，用来定位下一个应该接收数据分包的网络对应的<code>MAC</code>地址。如果目标主机不在同一个链路上，可以<strong>通过代理ARP的路由器</strong>将<code>ARP</code>请求转发给相邻网段。「注：<code>ARP</code>包会被路由器隔离，<code>ARP</code>只适用于<code>IPv4</code>,<code>IPv6</code>用<code>ICMpv6</code>」</p>
<p>举例：</p>
<p><code>主机A</code>为了获取<code>主机B</code>的<code>Mac</code>地址，通过广播发送一个<code>ARP</code>请求包「请求中包含<code>主机B</code>的<code>IP</code>地址」，由于广播的包可以被同一个链路上所有的主机或路由器接收，如果<code>ARP</code>请求包中的目标<code>IP</code>与自己的<code>IP</code>地址一致，那么这个节点就将自己的<code>Mac</code>地址塞入<code>ARP</code>响应包返回给<code>主机A</code>。</p>
<h4 id="4-RARP"><a href="#4-RARP" class="headerlink" title="4. RARP"></a>4. RARP</h4><p><code>RARP</code>是将<code>ARP</code>反过来，从<code>MAC</code>地址定位IP地址的一种协议。</p>
<h4 id="5-IP地址"><a href="#5-IP地址" class="headerlink" title="5. IP地址"></a>5. IP地址</h4><p><code>IP地址</code>处于网络层， 用于在<strong>连接到网络中的所有主机识别出进行通信的目标地址；</strong> <code>IP地址</code>由32位正整数来表示，每8位为一组，分4组，每组以<code>.</code>隔开；<code>IP地址</code>由<strong>网络标识</strong>和<strong>主机标识</strong>两部分组成。相同网段内的主机必须有相同的网络标识，主机标识不允许在同一个网段内重复出现。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-4/15647844-file_1491288228515_fbc6.png" alt=""></p>
<p>目前引入子网以后，一个IP地址有了两种识别码，一个是<code>IP</code>本身，另一个是<code>子网掩码</code>。子网掩码对应<code>IP网络标识</code>部分的位全部为<code>1</code>，对应<code>IP地址主机识别</code>的部分则全部为<code>0</code>。</p>
<p>举例：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-4/84217771-file_1491288982288_790d.png" alt=""></p>
<h4 id="6-MAC地址"><a href="#6-MAC地址" class="headerlink" title="6. MAC地址"></a>6. MAC地址</h4><p><code>Mac</code>地址用于识别数据链路中的互连的节点，<code>Mac</code>地址长48比特，每个<strong>网卡</strong>都有一个唯一的<code>Mac</code>地址。</p>
<h4 id="7-OSPF"><a href="#7-OSPF" class="headerlink" title="7. OSPF"></a>7. OSPF</h4><p><code>OSPF</code>为链路状态型路由器，相邻路由器之间交换链路状态生成网络拓扑信息，然后在根据这个拓扑信息生成路由控制表。<code>OSPF</code>给每条链路赋予一个权重，并始终选择一个权重最小的路径作为最终路由。「注：连接到同一个链路的路由器称作相邻路由器」</p>
<h4 id="8-硬件设备"><a href="#8-硬件设备" class="headerlink" title="8. 硬件设备"></a>8. 硬件设备</h4><table>
<thead>
<tr>
<th style="text-align:center">设备</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">网卡</td>
<td style="text-align:center">使计算机连网的设备</td>
</tr>
<tr>
<td style="text-align:center">中继器</td>
<td style="text-align:center">从物理上延长网络的设备，由电缆传过来的电信号或光信号经由中继放大器的波形调整和放大再传给另外一个电缆。</td>
</tr>
<tr>
<td style="text-align:center">网桥/2层交换机</td>
<td style="text-align:center">从数据链路层上延长网络的设备，它能识别数据链路层中的数据帧，并将这些数据帧临时存储于内存中，在重新生成信号作为一个全新帧给相连的另一个网段。</td>
</tr>
<tr>
<td style="text-align:center">路由器/3层交换机</td>
<td style="text-align:center">通过网络层转发分组数据的设备，路由器用于连接不同的数据链路。</td>
</tr>
<tr>
<td style="text-align:center">4~7层交换机</td>
<td style="text-align:center">处理传输层以上各层网络传输的设备</td>
</tr>
<tr>
<td style="text-align:center">网关</td>
<td style="text-align:center">转换协议的设备，例子：电脑和手机之间设置了一道网关，是的电脑和手机间可以互发邮件。</td>
</tr>
</tbody>
</table>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>图解TCP/IP - 竹下隆史</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt;是网络编程的基础，这一节我们主要来学习&lt;code&gt;协议分层&lt;/code&gt;、&lt;code&gt;ARP&lt;/code&gt;、
    
    </summary>
    
      <category term="HTTP" scheme="http://jianwl.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://jianwl.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Vim之常用快捷键</title>
    <link href="http://jianwl.com/2017/04/04/Vim%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://jianwl.com/2017/04/04/Vim之常用快捷键/</id>
    <published>2017-04-04T00:18:21.000Z</published>
    <updated>2017-04-04T00:39:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Vim</code>是最常用的文本编辑器，掌握常用的快捷键，可以极大的增强工作效率。</p>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><h4 id="1-移动光标"><a href="#1-移动光标" class="headerlink" title="1. 移动光标"></a>1. 移动光标</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gg 光标移动文本首行</div><div class="line">G 光标移到文本末行</div><div class="line">nG 光标移动到第n行</div><div class="line">nEnter 光标下移n行</div><div class="line">0 光标移到本行开头</div><div class="line">$ 光标移到本行末尾</div><div class="line">CTRL+F 下一页</div><div class="line">CTRL+B 上一页</div></pre></td></tr></table></figure>
<h4 id="2-查找-amp-替换"><a href="#2-查找-amp-替换" class="headerlink" title="2. 查找&amp;替换"></a>2. 查找&amp;替换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/word 向下查找word</div><div class="line">n 重复上一个查找</div><div class="line">N 反向查找</div><div class="line">:1,$s/word1/word2/gc 把word1替换成word2</div></pre></td></tr></table></figure>
<h4 id="3-编辑操作"><a href="#3-编辑操作" class="headerlink" title="3. 编辑操作"></a>3. 编辑操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dd 删除光标所在行</div><div class="line">ndd 向下删除n行</div><div class="line">x 删除一个字符</div><div class="line">nx 删除n个字符</div><div class="line">yy 复制光标所在行</div><div class="line">nyy 向下复制n行</div><div class="line">p 粘贴到光标下一行</div></pre></td></tr></table></figure>
<h4 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">u 撤销上一个操作</div><div class="line">CTRL+R 恢复之前的操作</div><div class="line">. 重复上一个操作</div><div class="line">:set nu 显示行号</div><div class="line">:set nonu 不显示行号</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://fqk.io/page/29/" target="_blank" rel="external">vi快捷键备忘</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Vim&lt;/code&gt;是最常用的文本编辑器，掌握常用的快捷键，可以极大的增强工作效率。&lt;/p&gt;
&lt;h3 id=&quot;理论&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="Linux" scheme="http://jianwl.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://jianwl.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>JAVA之正则表达式实战</title>
    <link href="http://jianwl.com/2017/04/02/JAVA%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E6%88%98/"/>
    <id>http://jianwl.com/2017/04/02/JAVA之正则表达式实战/</id>
    <published>2017-04-02T11:35:48.000Z</published>
    <updated>2017-04-02T12:39:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这一节主要来学习，正则表达式在<code>JAVA</code>中的运用。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="1-获取匹配值"><a href="#1-获取匹配值" class="headerlink" title="1. 获取匹配值"></a>1. 获取匹配值</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/59243831-file_1491135662906_16f46.png" alt=""></p>
<h4 id="2-查找与替换"><a href="#2-查找与替换" class="headerlink" title="2. 查找与替换"></a>2. 查找与替换</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/44125256-file_1491136420354_158ed.png" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>精通正则表达式 - 余晟</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这一节主要来学习，正则表达式在&lt;code&gt;JAVA&lt;/code&gt;中的运用。&lt;/p&gt;
&lt;h3 id=&quot;实战&quot;&gt;&lt;a href=&quot;#实战&quot; cl
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式入门(二)</title>
    <link href="http://jianwl.com/2017/04/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8-%E4%BA%8C/"/>
    <id>http://jianwl.com/2017/04/02/正则表达式入门-二/</id>
    <published>2017-04-02T03:50:41.000Z</published>
    <updated>2017-04-02T11:12:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="http://jianwl.com/2017/04/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/#more">上一节正则表达式入门</a>,学习了正则表达的基本功，这一节将继续深入学习正则表达式。</p>
<h3 id="正则表达式语法进阶"><a href="#正则表达式语法进阶" class="headerlink" title="正则表达式语法进阶"></a>正则表达式语法进阶</h3><h4 id="1-常用的字符"><a href="#1-常用的字符" class="headerlink" title="1) 常用的字符"></a>1) 常用的字符</h4><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\s</td>
<td>任何”空白”字符「空格符、制表符、进制符等」</td>
</tr>
<tr>
<td>\S</td>
<td>除<code>\s</code>之外的任何字符</td>
</tr>
<tr>
<td>\w</td>
<td><code>[a-zA-Z0-9]</code>在<code>\w+</code>中很有用，可以用来匹配一个单词</td>
</tr>
<tr>
<td>\W</td>
<td>除<code>\w</code>之外的任何字符，也就是<code>[^a-zA-Z0-9]</code></td>
</tr>
<tr>
<td>\d</td>
<td><code>[0-9]</code>,即数字</td>
</tr>
<tr>
<td>\D</td>
<td>除<code>\d</code>外的任何字符，即<code>[^0-9]</code></td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词边界，只是一个位置，这个位置的一侧是构成单词的字符，另一侧为非单词字符、字符串的开始或结束位置。<code>\b</code>是零宽度的。</td>
</tr>
</tbody>
</table>
<p>实战</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/33870462-file_1491108739351_155aa.png" alt=""></p>
<h4 id="2-输入正整数"><a href="#2-输入正整数" class="headerlink" title="2) 输入正整数"></a>2) 输入正整数</h4><p><code>perl</code>简单语法介绍，<code>=~</code>用来连接正则表达式和待搜索的目标字符串。<code>m/.../</code>告诉<code>Perl</code>该对这个正则表达式进行什么操作。<code>m</code>代表尝试进行<code>正则表达式匹配</code>。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/57253842-file_1491115515846_f21d.png" alt=""></p>
<h4 id="3-输入正-amp-负小数、正-amp-负整数"><a href="#3-输入正-amp-负小数、正-amp-负整数" class="headerlink" title="3) 输入正&amp;负小数、正&amp;负整数"></a>3) 输入正&amp;负小数、正&amp;负整数</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/34044067-file_1491116256845_4c73.png" alt=""></p>
<h4 id="4-使用正则表达式修改文本"><a href="#4-使用正则表达式修改文本" class="headerlink" title="4) 使用正则表达式修改文本"></a>4) 使用正则表达式修改文本</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/231628-file_1491117893226_1375.png" alt=""></p>
<h4 id="5）-四种类型的环视-难点"><a href="#5）-四种类型的环视-难点" class="headerlink" title="5） 四种类型的环视(难点)"></a>5） 四种类型的环视(难点)</h4><table>
<thead>
<tr>
<th>类型</th>
<th>正则表达式</th>
<th>匹配成功的条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>肯定逆序环视</td>
<td><code>?&lt;=...</code></td>
<td>子表达式能够成功匹配<strong>左侧</strong>文本</td>
</tr>
<tr>
<td>肯定顺序环视</td>
<td><code>?=...</code></td>
<td>子表达式能够匹配<strong>右侧</strong>文本 </td>
</tr>
<tr>
<td>否定逆序环视</td>
<td><code>?&lt;!...</code></td>
<td>子表达式不能匹配<strong>左侧</strong>文本</td>
</tr>
<tr>
<td>否定顺序环视</td>
<td><code>?!...</code></td>
<td>子表达式不能匹配<strong>右侧</strong>文本</td>
</tr>
</tbody>
</table>
<p>注意： 环视不消耗正则表达式的匹配字符。</p>
<h5 id="（1）-环视概念与匹配过程示例"><a href="#（1）-环视概念与匹配过程示例" class="headerlink" title="（1）. 环视概念与匹配过程示例"></a>（1）. 环视概念与匹配过程示例</h5><p>对于源字符串<code>ABC</code>，正则<code>(?=A)[A-Z]</code>匹配的是：</p>
<p>1、 <code>(?=A)</code>所在的位置，后面是<code>A</code> </p>
<p>2、 表达式<code>[A-Z]</code>匹配<code>A-Z</code>中任意一个字母，根据两个的先后位置关系，组合在一起，那就是<code>(?=A)</code>所在的位置，后面是A，而且是<code>A-Z</code>中任意一个字母，因此上面正则表达式匹配一个大写字母<code>A</code></p>
<p>实战：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/29664732-file_1491122472393_140ae.png" alt=""></p>
<h5 id="2-肯定顺序实战："><a href="#2-肯定顺序实战：" class="headerlink" title="(2) . 肯定顺序实战："></a>(2) . 肯定顺序实战：</h5><p><code>[A-Za-z]+(?=;)</code>,字母序列后面跟着<code>；</code></p>
<p>实战:</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/93389675-file_1491123341579_f721.png" alt=""></p>
<h5 id="3-肯定逆序实战"><a href="#3-肯定逆序实战" class="headerlink" title="(3) . 肯定逆序实战"></a>(3) . 肯定逆序实战</h5><p><code>\b[0-9]\b(?&lt;=[13579])</code>，0-9中的基数;</p>
<p>实战：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/64931704-file_1491124392441_14979.png" alt=""></p>
<h5 id="4-否定顺序实战"><a href="#4-否定顺序实战" class="headerlink" title="(4) . 否定顺序实战"></a>(4) . 否定顺序实战</h5><p><code>(?!.*?[0h])\b[a-z0-9]+\b</code>，不包含<code>0</code>和<code>h</code>的字母和数字系列</p>
<p>实战:</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/58656792-file_1491125331588_15359.png" alt=""></p>
<h5 id="5-否定逆序实战"><a href="#5-否定逆序实战" class="headerlink" title="(5) . 否定逆序实战"></a>(5) . 否定逆序实战</h5><p><code>\b[a-z]+(?&lt;!z)\b</code>, 不以<code>z</code>结尾的单词</p>
<p>实战：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/28220906-file_1491125753738_94b.png" alt=""></p>
<h5 id="6-进阶的练习"><a href="#6-进阶的练习" class="headerlink" title="(6) . 进阶的练习"></a>(6) . 进阶的练习</h5><p>给一组数字从右到左，每三位加一个逗号;</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/43300392-file_1491131531371_d909.png" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://www.cnblogs.com/Zjmainstay/p/regexp-lookaround.html" target="_blank" rel="external">环视的用法</a></li>
<li><a href="http://blog.csdn.net/lxcnn/article/details/4355364" target="_blank" rel="external">\b 单词边界</a></li>
<li>精通正则表达式 - 余晟</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://jianwl.com/2017/04/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%B
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式入门</title>
    <link href="http://jianwl.com/2017/04/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
    <id>http://jianwl.com/2017/04/01/正则表达式入门/</id>
    <published>2017-04-01T15:00:58.000Z</published>
    <updated>2017-04-02T03:42:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>正则表达式是文本处理&amp;数据爬取的神器，但由于语法难记且在日常工作中用到的机会较少，所以对这一神器知之甚少，这节来学习正则表达式的简单用法。</p>
<h3 id="egrep用法"><a href="#egrep用法" class="headerlink" title="egrep用法"></a>egrep用法</h3><p>文本检索是正则表达式最简单的应用之一 – Mac系统下<code>egrep</code>提供了文本正则表达式的检索功能。举个简单的例子:</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-1/87069959-file_1491061667712_8d09.png" alt=""></p>
<h3 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h3><h4 id="1-行的开始和结束"><a href="#1-行的开始和结束" class="headerlink" title="1. 行的开始和结束"></a>1. 行的开始和结束</h4><p><code>^</code>代表一行的开始，<code>$</code>代表结束</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-1/71581110-file_1491061994393_b0fa.png" alt=""></p>
<h4 id="2-字符组"><a href="#2-字符组" class="headerlink" title="2. 字符组"></a>2. 字符组</h4><h5 id="1-范围型字符组"><a href="#1-范围型字符组" class="headerlink" title="1) 范围型字符组"></a>1) 范围型字符组</h5><p>匹配若干字符之一，可以使用结构体<code>[...]</code>,在字符组内部，<strong>字符组元字符</strong><code>-</code>表示一个范围比如<code>[0-9]</code>。特别注意：<strong>连字符</strong><code>-</code>只有在字符组内部才能表示范围，否则就是普通字符。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/54684166-file_1491062598112_9911.png" alt=""></p>
<h5 id="2）排除型字符组"><a href="#2）排除型字符组" class="headerlink" title="2）排除型字符组"></a>2）排除型字符组</h5><p>字符组会匹配任何未列出的字符，可以用结构体<code>[^...]</code>表示，<code>^</code>在字符组的开头表示排除。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/72090159-file_1491095085321_162c1.png" alt=""></p>
<h4 id="3-用点号匹配任意字符"><a href="#3-用点号匹配任意字符" class="headerlink" title="3. 用点号匹配任意字符"></a>3. 用点号匹配任意字符</h4><p>元字符<code>.</code>是用来匹配任意字符的字符组。例如我们要搜索<code>92/06/02</code>、<code>92-06-02</code>、<code>92.06.02</code>。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/77946479-file_1491096549681_13890.png" alt=""></p>
<h4 id="4-匹配任意子表达式"><a href="#4-匹配任意子表达式" class="headerlink" title="4. 匹配任意子表达式"></a>4. 匹配任意子表达式</h4><p><code>|</code>表示或，能够匹配多个子表达式。比如<code>First</code>和<code>1st</code>是两个表达式，用正则表达式匹配<code>(Fir|1)st</code>,括号是必须的。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/9589231-file_1491097579389_ae64.png" alt=""></p>
<h4 id="5-egrep-忽略大小写"><a href="#5-egrep-忽略大小写" class="headerlink" title="5. egrep 忽略大小写"></a>5. egrep 忽略大小写</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/76759955-file_1491097883322_b1d9.png" alt=""></p>
<h4 id="6-可选元素"><a href="#6-可选元素" class="headerlink" title="6. 可选元素"></a>6. 可选元素</h4><p><code>?</code>代表可选项，把它加在一个字符的后面，就表示此处容许出现这个字符。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/34841121-file_1491098454865_70b6.png" alt=""></p>
<h4 id="7-重复元素"><a href="#7-重复元素" class="headerlink" title="7. 重复元素"></a>7. 重复元素</h4><table>
<thead>
<tr>
<th>符号</th>
<th>次数下限</th>
<th>次数上限</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>？</code></td>
<td>无</td>
<td>1</td>
<td><strong>在<code>?</code>之前的元素</strong>可以不出现，也可以只出现一次</td>
</tr>
<tr>
<td><code>*</code></td>
<td>无</td>
<td>无</td>
<td><strong>在<code>*</code>之前出现的元素</strong>可以出现无数次，也可以不出现</td>
</tr>
<tr>
<td><code>+</code></td>
<td>1</td>
<td>无</td>
<td><strong>在<code>+</code>之前出现的元素</strong>可以出现无数次，但至少要出现一次</td>
</tr>
</tbody>
</table>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/93512234-file_1491099677438_125b8.png" alt=""></p>
<p>规定重复出现的次数<code>{min,max}</code> </p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/58020717-file_1491101398884_a930.png" alt=""></p>
<h4 id="8-神奇的转义字符"><a href="#8-神奇的转义字符" class="headerlink" title="8. 神奇的转义字符\"></a>8. 神奇的转义字符<code>\</code></h4><p>使用转义符<code>\</code>，元字符就会失去特殊含义，比如匹配<code>90.06.02</code></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/35875132-file_1491101901364_14a1a.png" alt=""></p>
<h4 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h4><p>匹配24小时制<code>HH:MM</code>,特别注意以2开头的时间如 <code>21:59</code></p>
<p>实战：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-2/1904614-file_1491103167597_9411.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>符号</th>
<th>元字符</th>
<th>匹配对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>.</code></td>
<td>点号</td>
<td>匹配单个任意字符</td>
</tr>
<tr>
<td>  <code>[...]</code></td>
<td>字符组</td>
<td>匹配单个列出的字符</td>
</tr>
<tr>
<td><code>[^...]</code></td>
<td>排除型字符组</td>
<td>匹配单个未列出的字符</td>
</tr>
<tr>
<td><code>\char</code></td>
<td>转义字符</td>
<td>若char是元字符，匹配char对应的普通字符</td>
</tr>
<tr>
<td><code>?</code></td>
<td>问号</td>
<td>容许匹配一次，但非必需</td>
</tr>
<tr>
<td><code>*</code></td>
<td>星号</td>
<td>容许匹配多次，但也可不匹配</td>
</tr>
<tr>
<td><code>+</code></td>
<td>加号</td>
<td>至少匹配一次，至多可以任意次</td>
</tr>
<tr>
<td><code>{min,max}</code></td>
<td>区间量词</td>
<td>至少需要min次，至多可能任意次「不是所有egrep版本都支持」</td>
</tr>
<tr>
<td><code>^</code></td>
<td>脱字符</td>
<td>匹配一行的开头位置</td>
</tr>
<tr>
<td><code>$</code></td>
<td>美元符</td>
<td>匹配一行的结束位置</td>
</tr>
<tr>
<td><code>(...)</code></td>
<td>括号</td>
<td>限定多选结构的范围</td>
</tr>
</tbody>
</table>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://item.jd.com/11070361.html" target="_blank" rel="external">精通正则表达式- 余晟</a> </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;正则表达式是文本处理&amp;amp;数据爬取的神器，但由于语法难记且在日常工作中用到的机会较少，所以对这一神器知之甚少，这节来学习正则表达式的简单
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Mac下效率神器之autojump</title>
    <link href="http://jianwl.com/2017/04/01/Mac%E4%B8%8B%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8%E4%B9%8Bautojump/"/>
    <id>http://jianwl.com/2017/04/01/Mac下效率神器之autojump/</id>
    <published>2017-04-01T12:59:10.000Z</published>
    <updated>2017-04-01T14:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>过去常用到的一些命令，习惯在<code>.zshrc</code>文件中添加几行快捷键命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alias dada = cd /Users/jianweilin/Work/Java/dada</div><div class="line">alias test = cd /Users/jianweilin/Work/Java/test</div></pre></td></tr></table></figure>
<p>发现一个跳转神器<code>autojump</code>，举个例子</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-4-1/74960136-file_1491052275484_549a.png" alt=""></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1、 建议安装<code>zsh</code></p>
<p>2、建议安装<code>homebrew</code></p>
<p>3、 <code>brew install autojump</code></p>
<p>4、 <code>vim ~/.zshrc</code>找到<code>plugins=</code>，在后面添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plugins=(git autojump)</div></pre></td></tr></table></figure>
<p>5、然后继续在上述文件中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;&amp; . $(brew --prefix)/etc/profile.d/autojump.sh</div></pre></td></tr></table></figure>
<p>6、 <code>source ~/.zshrc</code></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://barretlee.com/blog/2015/03/30/autojump-in-mac/" target="_blank" rel="external">Mac下的效率工具autojump –阿里小胡子哥</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;过去常用到的一些命令，习惯在&lt;code&gt;.zshrc&lt;/code&gt;文件中添加几行快捷键命令:&lt;/p&gt;
&lt;figure class=&quot;high
    
    </summary>
    
      <category term="Mac" scheme="http://jianwl.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://jianwl.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>关于代码阅读的思考</title>
    <link href="http://jianwl.com/2017/04/01/%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://jianwl.com/2017/04/01/关于代码阅读的思考/</id>
    <published>2017-04-01T06:04:49.000Z</published>
    <updated>2017-04-02T00:47:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一个工程师，你的价值如何体现？不是掌握了多少知识，而是体现在创造出的系统，否则空有满腹经纶，最后也只是纸上谈兵。学习编写优秀代码的最佳方式，就是阅读高品质的代码，学习别人的高明之处。这一节我们将来学习阅读优秀源码的技巧。</p>
<h3 id="阅读代码"><a href="#阅读代码" class="headerlink" title="阅读代码"></a>阅读代码</h3><h4 id="1-为什么阅读代码"><a href="#1-为什么阅读代码" class="headerlink" title="1. 为什么阅读代码"></a>1. 为什么阅读代码</h4><p>经常花时间阅读别人编写的高质量代码，就像阅读高品质的散文能够丰富词汇，激发想象力，扩展思维一样，分析设计良好的软件系统的内部结构可以学到<code>新的架构模式</code>、<code>数据结构</code>、<code>编码方法</code>、<code>算法</code>、<code>风格</code>和<code>文档规范</code>、<code>应用程序编程接口(API)</code>，同时可以提高编写代码的水准。</p>
<p>阅读代码的过程中，不可避免地会遇到一些在实践中应该尽量避免的代码，能够快速地从坏代码中区分出好代码是一项有价值的技能；接触一些编码的反面例子有助于提高这种能力，通过下面这些征兆，可以很容易识别出低品质的代码：1️⃣ 编码风格不一致 2️⃣ 结构不必要地复杂或难以理解 3️⃣ 明显的逻辑错误或疏忽 4️⃣ 过度使用不可移植的构造 5️⃣ 缺乏维护</p>
<p>大型、有组织体制之下的项目都会采纳一套编码规范、指导原则或约定，代码规范提供风格上的指导，目标是增强代码的可靠性、易读性和可维护性。关注优秀源码的<code>类命名</code>、<code>变量命名</code>、<code>代码缩进</code>、<code>代码编排</code>、<code>命名约定</code>、<code>文档</code>；</p>
<p>通过阅读优秀源码，我们可以学习到<code>分层架构的设计</code>、<code>更加合理的抽象面向对象的结构</code>、<code>如何更加合理的拆分模块</code>、<code>代码重用</code></p>
<h4 id="2-如何阅读代码"><a href="#2-如何阅读代码" class="headerlink" title="2. 如何阅读代码"></a>2. 如何阅读代码</h4><p>有选择地阅读代码，同时还有<code>有自己的目标</code>。想学习新的模式、编码风格还是满足某些需求的方法？或者只是浏览代码，获取其中的某些亮点。</p>
<p>从小型的程序开始阅读，不要立即陷入对大型系统的研究中，编译研究的程序并运行他们，这样可以得到即时的反馈，了解代码预想的工作方式，同时可以获得成就感。</p>
<p>积极介入现实的代码，能够快速从中了解到一些情况，当觉得已经掌握了他们之后，再采取更有组织的方式来学习，比如：阅读相关书籍、文档、手册、参加培训课程。</p>
<h4 id="3-实战"><a href="#3-实战" class="headerlink" title="3. 实战"></a>3. 实战</h4><p>比如：想要了解一个特定的功能是如何实现的。首先使用该系统，得到他的外部接口，根据外部接口，定位目标代码，针对它进行研究分析，忽略不相关的部分。如果觉得在原来的上下文中，理解代码有困难，就将他复制到一个历史文件中，删除所有不相关的部分。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、养成一个习惯，经常花时间阅读别人编写的高品质代码</p>
<p>2、要有选择地阅读代码，同时还要有自己的目标，想学习新的模式、编码风格、还是满足某些需求的方法</p>
<p>3、对于那些大型且组织良好的系统，只需要最低限度地了解它的全部功能，就能够对它做出修改。</p>
<p>4、向系统中增加新功能时，首先的任务就是找到类似特性的代码，将它作为待实现功能的模板。</p>
<p>5、阅读代码寻找重构机会时，先从系统的架构开始，然后逐步细化，能够获得最大的效益。</p>
<p>6、不需要为了效率，牺牲代码的可读性</p>
<p>7、通过浏览项目的源代码树 – 包含项目源代码的层次目录结构，来分析一个项目的组织方式，源码树常常能够反映出项目在架构和软件过程上的结构。</p>
<p>8、<strong>阅读代码时，应该尽可能利用任何能够得到的文档。</strong></p>
<p>9、<strong>阅读一个小时代码所得到的信息只不过相当于阅读一分钟文档</strong></p>
<p>10、可以将系统的设计规格说明作为认知代码结构的路线图，阅读具体代码的指引</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>代码阅读方法与实践</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;作为一个工程师，你的价值如何体现？不是掌握了多少知识，而是体现在创造出的系统，否则空有满腹经纶，最后也只是纸上谈兵。学习编写优秀代码的最佳方
    
    </summary>
    
      <category term="思绪" scheme="http://jianwl.com/categories/%E6%80%9D%E7%BB%AA/"/>
    
    
      <category term="思绪" scheme="http://jianwl.com/tags/%E6%80%9D%E7%BB%AA/"/>
    
  </entry>
  
  <entry>
    <title>Python之易出错语法</title>
    <link href="http://jianwl.com/2017/03/31/Python%E4%B9%8B%E6%98%93%E5%87%BA%E9%94%99%E8%AF%AD%E6%B3%95/"/>
    <id>http://jianwl.com/2017/03/31/Python之易出错语法/</id>
    <published>2017-03-31T06:36:34.000Z</published>
    <updated>2017-03-31T09:50:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本节主要记录<code>Python</code>和<code>Java</code>不一样的语法，用于备忘。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="1-三目运算"><a href="#1-三目运算" class="headerlink" title="1. 三目运算"></a>1. 三目运算</h4><p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">为真的结果  if 判断条件 else 为假的结果</div></pre></td></tr></table></figure>
<p>实战</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-3-31/68640470-file_1490942427899_33c0.png" alt=""></p>
<h5 id="2-flask-josnify与json-dumps的区别"><a href="#2-flask-josnify与json-dumps的区别" class="headerlink" title="2. flask.josnify与json.dumps的区别"></a>2. flask.josnify与json.dumps的区别</h5><p>json操作：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-3-31/98569674-file_1490945276911_e3be.png" alt=""></p>
<p>jsonify操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def render_success(content=None):</div><div class="line">    data = dict(</div><div class="line">        status=u&apos;ok&apos;</div><div class="line">    )</div><div class="line"></div><div class="line">    if content is not None:</div><div class="line">        data.update(</div><div class="line">            content=content</div><div class="line">        )</div><div class="line"></div><div class="line">    return jsonify(data)</div></pre></td></tr></table></figure>
<p>区别：</p>
<p>jsonify在flask中返回<code>flask.Response()</code>已经在返回的对象的<code>Header</code>中塞入<code>content-type: application/json</code>，而<code>json.dumps()</code>仅仅是返回一个编码后的字符串。</p>
<h4 id="3-判断是否是某一类型"><a href="#3-判断是否是某一类型" class="headerlink" title="3. 判断是否是某一类型"></a>3. 判断是否是某一类型</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">isinstance(object,classinfo)</div></pre></td></tr></table></figure>
<p>实战：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-3-31/9606019-file_1490947230781_fc6f.png" alt=""></p>
<h4 id="4-args和-kwargs区别？"><a href="#4-args和-kwargs区别？" class="headerlink" title="4. *args和**kwargs区别？"></a>4. <code>*args</code>和<code>**kwargs</code>区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*args 元组,特别注意入参的方式</div><div class="line">**kwargs 字典,特别注意入参的方式</div></pre></td></tr></table></figure>
<p>实战:</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-3-31/7333141-file_1490950330464_129f0.png" alt=""></p>
<h4 id="5-set取交集"><a href="#5-set取交集" class="headerlink" title="5. set取交集"></a>5. <code>set</code>取交集</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-3-31/57928855-file_1490953364605_13cda.png" alt=""></p>
<h4 id="6-xrange数据集"><a href="#6-xrange数据集" class="headerlink" title="6. xrange数据集"></a>6. <code>xrange</code>数据集</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-3-31/86398939-file_1490953813150_14023.png" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://stackoverflow.com/questions/7907596/json-dumps-vs-flask-jsonify" target="_blank" rel="external">json-dumps-vs-flask-jsonify</a></li>
<li><a href="https://docs.python.org/2/library/functions.html" target="_blank" rel="external">python官方文档</a></li>
<li><a href="http://stackoverflow.com/questions/3394835/args-and-kwargs" target="_blank" rel="external">args-and-kwargs - stackoverflow</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本节主要记录&lt;code&gt;Python&lt;/code&gt;和&lt;code&gt;Java&lt;/code&gt;不一样的语法，用于备忘。&lt;/p&gt;
&lt;h3 id=&quot;实战
    
    </summary>
    
      <category term="Python" scheme="http://jianwl.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jianwl.com/tags/Python/"/>
    
  </entry>
  
</feed>
