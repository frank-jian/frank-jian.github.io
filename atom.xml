<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录点滴成长</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianwl.com/"/>
  <updated>2017-08-27T05:11:27.000Z</updated>
  <id>http://jianwl.com/</id>
  
  <author>
    <name>流云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>泛型中extends和super的区别?</title>
    <link href="http://jianwl.com/2017/08/27/%E6%B3%9B%E5%9E%8B%E4%B8%ADextends%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://jianwl.com/2017/08/27/泛型中extends和super的区别/</id>
    <published>2017-08-27T05:10:19.000Z</published>
    <updated>2017-08-27T05:11:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://itimetraveler.github.io/2016/12/27/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B%E4%B8%AD%20extends%20%E5%92%8C%20super%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/" target="_blank" rel="external">【Java】泛型中 extends 和 super 的区别？</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://itimetraveler.github.io/2016/12/27/%E3%
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>高效实用Python字典的清单</title>
    <link href="http://jianwl.com/2017/08/22/%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8Python%E5%AD%97%E5%85%B8%E7%9A%84%E6%B8%85%E5%8D%95/"/>
    <id>http://jianwl.com/2017/08/22/高效实用Python字典的清单/</id>
    <published>2017-08-22T14:22:12.000Z</published>
    <updated>2017-08-22T15:07:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>字典(dict)对象是Python最常用的数据结构，这里整理了几个关于高效实用字典的清单，希望Python开发者可以在日常应用开发中合理利用，让代码更加Pythonic。</p>
<h3 id="1、用in关键字检查key是否存在"><a href="#1、用in关键字检查key是否存在" class="headerlink" title="1、用in关键字检查key是否存在"></a>1、用in关键字检查key是否存在</h3><p>Python之禅中有一句开发哲学是:</p>
<blockquote>
<p>There should be one – and perferably only one –obvious way to do it.</p>
</blockquote>
<p>尽量找一种，最好是唯一一种显而易见的解决方案。Python2中判断某个key是否存在字典中可使用<code>has_key</code>方法，另外一种方式是使用<code>in</code>关键字。但强烈推荐后者，因为in的处理速度更快，另外一个原因是<code>has_key</code>这个方法在Python3被移除了。</p>
<p>bad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">info = dict(name=&apos;zhangsan&apos;,age=23)</div><div class="line">if info.has_key(&apos;name&apos;):</div><div class="line">   pass</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">info = dict(name=&apos;zhangsan&apos;,age=23)</div><div class="line">if &apos;name&apos; in info:</div><div class="line">   pass</div></pre></td></tr></table></figure>
<h3 id="2、用get获取字典中的值"><a href="#2、用get获取字典中的值" class="headerlink" title="2、用get获取字典中的值"></a>2、用get获取字典中的值</h3><p>关于获取字典的值，一种简单的方式就是用d[x]访问元素，但是这种情况在key不存在的情况下会报KeyError错误，当然你可以先用in操作检查key是否在字典中在获取，不过这种方式不符合Python之禅中说的：</p>
<blockquote>
<p>Simple is better then complex<br>Flat is better than nested.</p>
</blockquote>
<p>好的代码应该是简单易懂的，扁平的代码结构更加可读。所以我们可以使用get方法来替代if … else.</p>
<p>bad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">d = dict(name=&apos;python&apos;)</div><div class="line">if &apos;name&apos; in d:</div><div class="line">    print d[&apos;hello&apos;]</div><div class="line">else:</div><div class="line">	 print &apos;default&apos;</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print d.get(&apos;name&apos;,&apos;default&apos;)</div></pre></td></tr></table></figure>
<h3 id="3、用setdefault为字典中不存在的key设置缺省值"><a href="#3、用setdefault为字典中不存在的key设置缺省值" class="headerlink" title="3、用setdefault为字典中不存在的key设置缺省值"></a>3、用setdefault为字典中不存在的key设置缺省值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data = [(&apos;animal&apos;,&apos;bear&apos;),(&apos;animal,&apos;duck&apos;),(&apos;plant&apos;,&apos;catus&apos;),(&apos;vehicle&apos;,&apos;speed boat&apos;),(&apos;vehicle&apos;,&apos;school bus&apos;)]</div></pre></td></tr></table></figure>
<p>在做分类统计时，希望把同一类型的数据归到字典中的某种类型中，比如上面代码，把相同类型的事物用列表形式重新组装，得到新字典。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data = dict(animal=[&apos;bear&apos;,&apos;duck&apos;],plant=[&apos;cacuts&apos;],vehicle=[&apos;speed boat&apos;,&apos;school bus&apos;])</div></pre></td></tr></table></figure>
<p>普通的方式就是先判断key是否存在，如果不存在则要先用列表对象进行初始化，在执行后续操作。而更好的方式就是使用字典中的setdefault方法。</p>
<p>bad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">groups = &#123;&#125;</div><div class="line">for (key,value) in data:</div><div class="line">    if key in groups:</div><div class="line">       groups[key].append(value)</div><div class="line">    else:</div><div class="line">       groups[key] = [value]</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">groups = &#123;&#125;</div><div class="line">for (key,value) in data:</div><div class="line">    groups.setdefault(key,[]).append(value)</div></pre></td></tr></table></figure>
<p><code>setdefault</code>的作用是：</p>
<ol>
<li>如果key存在与字典中，那么直接返回对应的值，等效于get</li>
<li>如果key不存在字典中，则会用setdefault中的第二个参数作为该key的值，在返回该值。</li>
</ol>
<h3 id="4、用字典实现swith-…-case语句"><a href="#4、用字典实现swith-…-case语句" class="headerlink" title="4、用字典实现swith … case语句"></a>4、用字典实现swith … case语句</h3><p>Python中没有switch…case语句，这个问题Python之父龟叔表示这个语法过去没有，现在没有，以后也不会有。因为Python简洁的语法完全可以用if…elif实现。如果有太多的分支判断，还可以使用字典来代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if arg == 0:</div><div class="line">  return &apos;zero&apos;</div><div class="line">elif arg == 1:</div><div class="line">  return &apos;one&apos;</div><div class="line">elif arg == 2:</div><div class="line">  return &apos;two&apos;</div><div class="line">elif arg == 3:</div><div class="line">  return &apos;three&apos;</div><div class="line">else:</div><div class="line">  return &apos;nothing&apos;</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = dict(0=&apos;zero&apos;,1=&apos;one&apos;,2=&apos;two&apos;,3=&apos;three&apos;)</div><div class="line">data.get(arg,&quot;nothing&quot;)</div></pre></td></tr></table></figure>
<h3 id="5、使用items迭代字典中的元素"><a href="#5、使用items迭代字典中的元素" class="headerlink" title="5、使用items迭代字典中的元素"></a>5、使用items迭代字典中的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data = dict(0=&apos;zero&apos;,1=&apos;one&apos;,2=&apos;two&apos;,3=&apos;three&apos;)</div><div class="line">for k,v in data.items():</div><div class="line">  print k,v</div></pre></td></tr></table></figure>
<h3 id="6、使用字典推导式"><a href="#6、使用字典推导式" class="headerlink" title="6、使用字典推导式"></a>6、使用字典推导式</h3><p>推导式是个绝妙的东西，列表推导式一出，map、filter等函数黯然失色，至python2.7以后的版本，此特性扩展到了字典和集合身上，构建字典对象无需调用dict方法。</p>
<p>bad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">numbers = [1,2,3]</div><div class="line">d = dict([(number,number*2) for number in numbers])</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">numbers = [1,2,3]</div><div class="line">d = &#123;number: number * 2 for number in numbers&#125;</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://juejin.im/post/599c03e751882511264e7428" target="_blank" rel="external">高效使用Python字典</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;字典(dict)对象是Python最常用的数据结构，这里整理了几个关于高效实用字典的清单，希望Python开发者可以在日常应用开发中合理利用
    
    </summary>
    
      <category term="Python" scheme="http://jianwl.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jianwl.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>cp -r without hidden files</title>
    <link href="http://jianwl.com/2017/08/16/cp-r-without-hidden-files/"/>
    <id>http://jianwl.com/2017/08/16/cp-r-without-hidden-files/</id>
    <published>2017-08-16T03:56:14.000Z</published>
    <updated>2017-08-16T03:57:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><a href="https://stackoverflow.com/questions/11557114/cp-r-without-hidden-files" target="_blank" rel="external">cp-r-without-hidden-files</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/11557114/cp
    
    </summary>
    
      <category term="Linux" scheme="http://jianwl.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://jianwl.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Webpack入门篇</title>
    <link href="http://jianwl.com/2017/08/15/Webpack%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://jianwl.com/2017/08/15/Webpack入门篇/</id>
    <published>2017-08-15T09:16:19.000Z</published>
    <updated>2017-08-15T09:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><a href="http://www.jianshu.com/p/42e11515c10f" target="_blank" rel="external">入门Webpack，看这篇就够了</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/42e11515c10f&quot; target=&quot;
    
    </summary>
    
      <category term="Webpack" scheme="http://jianwl.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://jianwl.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Java服务化系统线上应急和技术攻关，你必须掌握的Linux命令</title>
    <link href="http://jianwl.com/2017/07/22/Java%E6%9C%8D%E5%8A%A1%E5%8C%96%E7%B3%BB%E7%BB%9F%E7%BA%BF%E4%B8%8A%E5%BA%94%E6%80%A5%E5%92%8C%E6%8A%80%E6%9C%AF%E6%94%BB%E5%85%B3%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84Linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://jianwl.com/2017/07/22/Java服务化系统线上应急和技术攻关，你必须掌握的Linux命令/</id>
    <published>2017-07-22T12:51:16.000Z</published>
    <updated>2017-07-23T03:32:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文并不是Linux命令的手册，而是侧重于命令在特定场景如何帮助应急人员和攻关人员定位问题并解决问题，因此，对于每个命令的介绍将直切主题，直接介绍命令的具体场景，而不是介绍命令的详细使用格式。</p>
<h3 id="1-必不可少的基础命令和工具"><a href="#1-必不可少的基础命令和工具" class="headerlink" title="1. 必不可少的基础命令和工具"></a>1. 必不可少的基础命令和工具</h3><h4 id="1-1-grep"><a href="#1-1-grep" class="headerlink" title="1.1 grep"></a>1.1 grep</h4><p><code>grep</code>是<code>Linux</code>下通用的文本内容查找命令。</p>
<p>也可以利用它打印匹配的上下几行，线上查找问题的时候，可以使用以下命令,查找关键字，显示关键字出现的后5行，并且给关键字着色。</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">grep -5 &apos;pattern&apos; INPUT_FILE # 打印匹配行的前后5行</div><div class="line"></div><div class="line">grep -C 5 &apos;pattern&apos; INPUT_FILE # 打印匹配行的前后5行</div><div class="line"></div><div class="line">grep -A 5 &apos;pattern&apos; INPUT_FILE # 打印匹配行的后5行</div><div class="line"></div><div class="line">grep -B 5 &apos;pattern&apos; INPUT_FILE # 打印匹配行的前5行</div></pre></td></tr></table></figure>
<h4 id="1-2-find"><a href="#1-2-find" class="headerlink" title="1.2 find"></a>1.2 find</h4><p>通过文件名称查找文件的所在位置，名称查找支持模糊匹配</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name FILE_NAME</div></pre></td></tr></table></figure>
<p>命令输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@10-9-179-71 ~]# find . -name GifApiApplication.java</div><div class="line">./app/Gif-Api/src/main/java/com/budong/GifApiApplication.java</div></pre></td></tr></table></figure>
<h4 id="1-3-uptime"><a href="#1-3-uptime" class="headerlink" title="1.3 uptime"></a>1.3 uptime</h4><p>查看机器的启动时间、登录用户、平均负载等情况，通常用在线上应急或者技术攻关的时候来确定操作系统的重启时间。</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uptime</div></pre></td></tr></table></figure>
<p>命令输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[jianweilin@login10-103-142 ~]$ uptime</div><div class="line"> 10:35:13 up 698 days, 19:30,  3 users,  load average: 0.20, 0.13, 0.04</div></pre></td></tr></table></figure>
<p>从上面输出可以看到如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1、 当前时间：10:35:13</div><div class="line"></div><div class="line">2、 系统已运行的时间：698天19个小时30分钟</div><div class="line"></div><div class="line">3、当前在线用户：3个用户</div><div class="line"></div><div class="line">4. 系统平均负载：0.20 、0.13 、 0.04，最近1分钟、5分钟、15分钟系统的负载情况</div></pre></td></tr></table></figure>
<p>系统平均负载指在特定时间间隔内队列中运行的平均进程数，如果一个进程满足一下条件，它就会位于运行队列中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1、它没有在等待IO操作的结果</div><div class="line"></div><div class="line">2、它没有主动进入等待状态（也就是没有调用wait相关的系统API）</div><div class="line"></div><div class="line">3、没有被停止（例如：等待终止）</div></pre></td></tr></table></figure>
<p>一般来说，每个CPU内核对应活动进程数不大于3，则系统运行良好，换句话说，也就是活动进程数小于CPU核数的3倍。</p>
<p>举例说明，如果你的服务CPU有3个核心，那么只要uptime最后输出的一串字符数值小于9，即表示系统负载正常。但是，如果系统负载超过10，那就表示当前系统负载过重，需要定位系统执行任务负载超标的原因。</p>
<h4 id="1-4-lsof"><a href="#1-4-lsof" class="headerlink" title="1.4 lsof"></a>1.4 lsof</h4><p>列出系统当前打开的文件句柄，在Linux文件系统中，任何资源都是以文件句柄的形式管理的。例如：硬件设备、文件、网络套接字等，系统内部为每一种资源分配一个句柄，应用程序只能用操作系统分配的句柄来引用资源，因此，文件句柄为应用程序与基础操作系统之间的交互提供了通用的操作接口。</p>
<p>应用程序打开文件的描述列表包含大量的关于应用程序本身的运行信息，因此通过lsof工具查看这个文件句柄列表，对系统监控以及应急排错提供重要的帮助。</p>
<p>查看某一个进程打开的文件句柄：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@10-9-179-71 ~]# lsof -p 12988 | less</div><div class="line">COMMAND   PID USER   FD   TYPE             DEVICE SIZE/OFF     NODE NAME</div><div class="line">java    12988 root  cwd    DIR              252,1     4096   917916 /root/app/Gif-Api</div><div class="line">java    12988 root  rtd    DIR              252,1     4096        2 /</div><div class="line">java    12988 root  txt    REG              252,1     7718   400499 /usr/java/jdk1.7.0_80/bin/java</div><div class="line">java    12988 root  mem    REG              252,1 99170352   292284 /usr/lib/locale/locale-archive</div><div class="line">java    12988 root  mem    REG              252,1   111440   786852 /lib64/libresolv-2.12.so</div><div class="line">java    12988 root  mem    REG              252,1    27896   786492 /lib64/libnss_dns-2.12.so</div><div class="line">java    12988 root  mem    REG              252,1    90880   795901 /lib64/libgcc_s-4.4.7-20120601.</div><div class="line">so.1</div><div class="line">java    12988 root  mem    REG              252,1  1025172   663136 /usr/java/jdk1.7.0_80/jre/lib/e</div><div class="line">xt/localedata.jar</div><div class="line">java    12988 root  mem    REG              252,1   196468   663055 /usr/java/jdk1.7.0_80/jre/lib/e</div><div class="line">xt/sunjce_provider.jar</div></pre></td></tr></table></figure>
<h4 id="1-5-ulimit"><a href="#1-5-ulimit" class="headerlink" title="1.5 ulimit"></a>1.5 ulimit</h4><p>Linux系统为每个登录用户，都限制其最大进程数和打开的最大文件句柄数。为提供性能，可以根据硬件资源的具体情况，设置各个用户的最大进程数和打开的最大文件句柄数。</p>
<p>可以用<code>ulimit -a</code>来显示当前的各种系统对用户使用资源的限制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[root@10-9-179-71 ~]# ulimit -a</div><div class="line">core file size          (blocks, -c) unlimited</div><div class="line">data seg size           (kbytes, -d) unlimited</div><div class="line">scheduling priority             (-e) 0</div><div class="line">file size               (blocks, -f) unlimited</div><div class="line">pending signals                 (-i) 15356</div><div class="line">max locked memory       (kbytes, -l) 64</div><div class="line">max memory size         (kbytes, -m) unlimited</div><div class="line">open files                      (-n) 1000000</div><div class="line">pipe size            (512 bytes, -p) 8</div><div class="line">POSIX message queues     (bytes, -q) 819200</div><div class="line">real-time priority              (-r) 0</div><div class="line">stack size              (kbytes, -s) 10240</div><div class="line">cpu time               (seconds, -t) unlimited</div><div class="line">max user processes              (-u) 15356</div><div class="line">virtual memory          (kbytes, -v) unlimited</div><div class="line">file locks                      (-x) unlimited</div></pre></td></tr></table></figure>
<p>设置用户的最大进程数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ulimit -u 10240</div></pre></td></tr></table></figure>
<p>设置用户可以打开的最大文件句柄数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ulimit -n 10240</div></pre></td></tr></table></figure>
<h4 id="1-6-curl"><a href="#1-6-curl" class="headerlink" title="1.6 curl"></a>1.6 curl</h4><p>程序开发后，会使用Junit、Testng以及Jmock、Mockito进行单元测试，单元测试后需要进行集成测试，由于当前的线上服务较多使用Restful风格，那么集成测试的时候就需要进行HTTP调用，查看返回的结果是否符合预期，curl命令是首选测试的方法。</p>
<p>使用方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 打印请求响应头信息</div><div class="line">[root@10-9-179-71 ~]# curl -i https://bdapi.imdada.cn/health/check</div><div class="line">HTTP/1.1 200 OK</div><div class="line">Server: openresty</div><div class="line">Date: Sun, 23 Jul 2017 03:15:09 GMT</div><div class="line">Content-Type: application/json;charset=UTF-8</div><div class="line">Transfer-Encoding: chunked</div><div class="line">Connection: keep-alive</div><div class="line">&#123;&quot;status&quot;:&quot;ok&quot;,&quot;content&quot;:&quot;ok&quot;&#125;</div><div class="line"></div><div class="line"># 打印HTTP响应码</div><div class="line">[root@10-9-179-71 ~]# curl -I https://bdapi.imdada.cn/health/check</div><div class="line">HTTP/1.1 200 OK</div><div class="line">Server: openresty</div><div class="line">Date: Sun, 23 Jul 2017 03:16:45 GMT</div><div class="line">Content-Type: application/json;charset=UTF-8</div><div class="line">Content-Length: 30</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure>
<h4 id="1-7-scp"><a href="#1-7-scp" class="headerlink" title="1.7 scp"></a>1.7 scp</h4><p>scp命令是Linux系统中功能强大的文件传输命令，可以实现从本地到远程以及远程到本地的双向文件传输，用起来非常的方便。常用来在线上定位问题时，将线上的一些文件下载到本地进行查看，或者将本地的修改上传到服务器上。</p>
<p>使用方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">scp jianweilin@192.168.1.1:/home/jianweilin/test.txt</div><div class="line"></div><div class="line">scp ./test.txt jianweilin@192.168.1.1:/home/jianweilin/</div></pre></td></tr></table></figure></p>
<h4 id="1-8-vi-amp-vim"><a href="#1-8-vi-amp-vim" class="headerlink" title="1.8 vi &amp; vim"></a>1.8 vi &amp; vim</h4><p>vi和vim是Linux中最常用的命令行文本编辑工具，vim是vi的升级版本，在某些Linux版本下，vi实际上通过软链接指向vim。</p>
<p>常用vi/vim命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">1、h: 左移一个字符</div><div class="line"></div><div class="line">2、l: 有移一个字符</div><div class="line"></div><div class="line">3、k: 上移一个字符</div><div class="line"></div><div class="line">4、j: 下移一个字符</div><div class="line"></div><div class="line">5、set number: 显示行号</div><div class="line"></div><div class="line">6、shift + g: 移动到最后一行</div><div class="line"></div><div class="line">7、1 + shift + g: 移动到第一行</div><div class="line"></div><div class="line">8、n + shift + g: 移动到第n行</div><div class="line"></div><div class="line">9、0: 移动到行首</div><div class="line"></div><div class="line">10、$: 移动到行尾</div><div class="line"></div><div class="line">11、 /text: 查到text，按n键查找下一个，按N查找前一个</div><div class="line"></div><div class="line">12、 ?text: 查找text，按n键查找下一个，按N查找前一个</div><div class="line"></div><div class="line">13、i: 在当前位置前插入</div><div class="line"></div><div class="line">14、I: 在当前行首插入</div><div class="line"></div><div class="line">15、a: 在当前位置后插入</div><div class="line"></div><div class="line">16、A: 在当前行尾插入</div><div class="line"></div><div class="line">17、o: 在当前行之后插入一行</div><div class="line"></div><div class="line">18、O: 在当前行之前插入一行</div><div class="line"></div><div class="line">19、%s/old/new/g：用old替换new，替换当前行的所有匹配</div><div class="line"></div><div class="line">20、ctrl + f：向下滚动一屏</div><div class="line"></div><div class="line">21、ctrl + b：向上滚动一屏</div><div class="line"></div><div class="line">22、u：撤销</div><div class="line"></div><div class="line">23、U：撤销对整行的操作</div><div class="line"></div><div class="line">24、Ctrl + r：重做，即撤销的撤销</div><div class="line"></div><div class="line">25、x：删除当前字符</div><div class="line"></div><div class="line">26、dd：删除当前行</div><div class="line"></div><div class="line">27、10d：删除当前行开始的10行</div><div class="line"></div><div class="line">28、yy：拷贝当前行</div><div class="line"></div><div class="line">29、p：在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行</div><div class="line">粘贴</div><div class="line"></div><div class="line">30、：wq：保存并退出</div><div class="line"></div><div class="line">31、：q!：强制退出并忽略所有更改</div></pre></td></tr></table></figure>
<p>未完待续…</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.jianshu.com/p/6fc923ceb722" target="_blank" rel="external">Java服务化系统线上应急和技术攻关，你必须掌握的Linux命令</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文并不是Linux命令的手册，而是侧重于命令在特定场景如何帮助应急人员和攻关人员定位问题并解决问题，因此，对于每个命令的介绍将直切主题，直
    
    </summary>
    
      <category term="Linux" scheme="http://jianwl.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://jianwl.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Flask-SQLAlchemy: Can&#39;t reconnect until invalid transaction is rolled back</title>
    <link href="http://jianwl.com/2017/07/20/Flask-SQLAlchemy-Can-t-reconnect-until-invalid-transaction-is-rolled-back/"/>
    <id>http://jianwl.com/2017/07/20/Flask-SQLAlchemy-Can-t-reconnect-until-invalid-transaction-is-rolled-back/</id>
    <published>2017-07-20T13:17:45.000Z</published>
    <updated>2017-07-20T13:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近来在做些Python的重构工作，今日屡次出现这个错误；</p>
<p> <img src="http://oc5a5l0a0.bkt.clouddn.com/17-7-20/81011645.jpg" alt=""></p>
<p>由日志可知，在查询<code>bd_charge_info</code>这张表时，由于存在没有提交的事务，导致了查询失败；于是查了MYSQL数据库的事务状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SHOW ENGINE INNODB STATUS</div></pre></td></tr></table></figure>
<p>查询结果：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-7-20/50146776.jpg" alt=""></p>
<p>至此确认了问题所在。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://imysql.com/2015/03/25/mysql-faq-how-to-fetch-latest-trxid.shtml" target="_blank" rel="external">如何查看当前最新事务ID</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;近来在做些Python的重构工作，今日屡次出现这个错误；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://oc5a5l0a0.bkt.cl
    
    </summary>
    
      <category term="Python" scheme="http://jianwl.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jianwl.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>2017的小目标</title>
    <link href="http://jianwl.com/2017/07/19/2017%E7%9A%84%E5%B0%8F%E7%9B%AE%E6%A0%87/"/>
    <id>http://jianwl.com/2017/07/19/2017的小目标/</id>
    <published>2017-07-19T14:58:27.000Z</published>
    <updated>2017-07-19T15:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>已经到年中了，给后半年设定一些小目标；</p>
<h3 id="小目标制定"><a href="#小目标制定" class="headerlink" title="小目标制定"></a>小目标制定</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-7-19/17630389.jpg" alt=""></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-7-19/90166218.jpg" alt=""></p>
<h3 id="7月份小目标"><a href="#7月份小目标" class="headerlink" title="7月份小目标"></a>7月份小目标</h3><p>7月份的学习主要以巩固基础为主，熟悉JVM参数配置 &amp; 泛读JVM官方文档</p>
<p>【10h】泛读<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/" target="_blank" rel="external">The Java Virtual Machine Specification</a></p>
<p>【20h】精读《深入理解JAVA虚拟机》并输出笔记</p>
<h3 id="7月份进展"><a href="#7月份进展" class="headerlink" title="7月份进展"></a>7月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="8月份小目标"><a href="#8月份小目标" class="headerlink" title="8月份小目标"></a>8月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="8月份进展"><a href="#8月份进展" class="headerlink" title="8月份进展"></a>8月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="9月份小目标"><a href="#9月份小目标" class="headerlink" title="9月份小目标"></a>9月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="9月份进展"><a href="#9月份进展" class="headerlink" title="9月份进展"></a>9月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="10月份小目标"><a href="#10月份小目标" class="headerlink" title="10月份小目标"></a>10月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="10月份进展"><a href="#10月份进展" class="headerlink" title="10月份进展"></a>10月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="11月份小目标"><a href="#11月份小目标" class="headerlink" title="11月份小目标"></a>11月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="11月份进展"><a href="#11月份进展" class="headerlink" title="11月份进展"></a>11月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="12月份小目标"><a href="#12月份小目标" class="headerlink" title="12月份小目标"></a>12月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="12月份进展"><a href="#12月份进展" class="headerlink" title="12月份进展"></a>12月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="全年总结"><a href="#全年总结" class="headerlink" title="全年总结"></a>全年总结</h3><p>// 还没轮到我呢…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已经到年中了，给后半年设定一些小目标；&lt;/p&gt;
&lt;h3 id=&quot;小目标制定&quot;&gt;&lt;a href=&quot;#小目标制定&quot; class=&quot;headerlink&quot; title=&quot;小目标制定&quot;&gt;&lt;/a&gt;小目标制定&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.
    
    </summary>
    
      <category term="小目标" scheme="http://jianwl.com/categories/%E5%B0%8F%E7%9B%AE%E6%A0%87/"/>
    
    
      <category term="小目标" scheme="http://jianwl.com/tags/%E5%B0%8F%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>JAVA之生产者-消费者模式</title>
    <link href="http://jianwl.com/2017/06/21/JAVA%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/21/JAVA之生产者-消费者模式/</id>
    <published>2017-06-21T08:50:53.000Z</published>
    <updated>2017-06-21T10:48:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>生产者-消费者模式是一个经典的多线程设计模式，它为多线程的协作提供了良好的解决方案。在生产者与消费者模式中，通常有两类线程，即若干个生产者线程和若干个消费者线程。<strong>生产者线程负责提交用户请求，消费者线程负责具体处理生产者提交的任务</strong>；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/QQ20170621-170501@2x.png" alt=""></p>
<p>生产者-消费者模式的核心组件是共享内存缓冲区，它作为生产者和消费者间的通信桥梁，避免了生产者和消费者的直接通信，从而将生产者和消费者进行解耦，生产者不需要知道消费者的存在，消费者也不需要知道生产者的存在。</p>
<p>同时，由于内存缓冲区的存在，允许生产者和消费者在执行速度上存在时间差，无论是生产者在某一局部时间内速度高于消费者，或是消费者在局部时间内高于生产者，都可以通过共享内存缓冲区得到缓解，确保系统正常运行。</p>
<h3 id="2-生产者-消费者模式主要角色"><a href="#2-生产者-消费者模式主要角色" class="headerlink" title="2. 生产者-消费者模式主要角色"></a>2. 生产者-消费者模式主要角色</h3><table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>生产者</td>
<td>用于提交用户请求，提取用户任务，并装入内存缓冲区</td>
</tr>
<tr>
<td>消费者</td>
<td>在内存缓冲区中提取并处理任务</td>
</tr>
<tr>
<td>内存缓冲区</td>
<td>缓冲生产者提交的任务或数据，供消费者使用</td>
</tr>
<tr>
<td>任务</td>
<td>生产者向内存缓冲区提交的数据结构</td>
</tr>
<tr>
<td>Main</td>
<td>使用生产者和消费者的客户端</td>
</tr>
</tbody>
</table>
<h3 id="3-类图"><a href="#3-类图" class="headerlink" title="3. 类图"></a>3. 类图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-21/96135924.jpg" alt=""></p>
<h3 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h3><h4 id="1-共享数据模型不可变类PCData"><a href="#1-共享数据模型不可变类PCData" class="headerlink" title="1) 共享数据模型不可变类PCData"></a>1) 共享数据模型不可变类<code>PCData</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public final class PCData &#123;</div><div class="line">    private final int intData;</div><div class="line"></div><div class="line">    public PCData(int d) &#123;</div><div class="line">        intData = d;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public PCData(String d) &#123;</div><div class="line">        intData = Integer.valueOf(d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getIntData() &#123;</div><div class="line">        return intData;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;data:&quot; + intData;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-生产者Producer"><a href="#2-生产者Producer" class="headerlink" title="2) 生产者Producer"></a>2) 生产者<code>Producer</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Producer implements Runnable &#123;</div><div class="line">    private volatile boolean isRunning = true;</div><div class="line">    private BlockingQueue&lt;PCData&gt; queue;</div><div class="line">    private static AtomicInteger count = new AtomicInteger();</div><div class="line"></div><div class="line">    private static final int SLEEP_TIME = 100;</div><div class="line"></div><div class="line">    public Producer(BlockingQueue&lt;PCData&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        PCData data = null;</div><div class="line">        Random r = new Random();</div><div class="line">        System.out.println(&quot;start producer id =&quot; + Thread.currentThread().getId());</div><div class="line"></div><div class="line">        try&#123;</div><div class="line">            while (isRunning) &#123;</div><div class="line">                Thread.sleep(r.nextInt(SLEEP_TIME));</div><div class="line">                // 构造任务数据</div><div class="line">                data = new PCData(count.incrementAndGet());</div><div class="line">                System.out.println(data + &quot; is put into queue&quot;);</div><div class="line">                if (!queue.offer(data,2, TimeUnit.SECONDS)) &#123;</div><div class="line">                    System.err.println(&quot;fail to put data: &quot; + data);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void stop() &#123;</div><div class="line">        isRunning = false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-消费者Consumer"><a href="#3-消费者Consumer" class="headerlink" title="3) 消费者Consumer"></a>3) 消费者<code>Consumer</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Consumer implements Runnable &#123;</div><div class="line">    private BlockingQueue&lt;PCData&gt; queue;</div><div class="line">    private static final int SLEEP_TIME = 100;</div><div class="line"></div><div class="line">    public Consumer(BlockingQueue&lt;PCData&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;start consumer id = &quot; + Thread.currentThread().getId());</div><div class="line">        Random r = new Random();</div><div class="line"></div><div class="line">        try&#123;</div><div class="line">            while (true) &#123;</div><div class="line">                PCData data = queue.take();</div><div class="line">                if( null != data) &#123;</div><div class="line">                    int re = data.getIntData() * data.getIntData();</div><div class="line">                    System.out.println(MessageFormat.format(&quot;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&quot;,data.getIntData(), data.getIntData(),re));</div><div class="line">                &#125;</div><div class="line">                Thread.sleep(r.nextInt(SLEEP_TIME));</div><div class="line">            &#125;</div><div class="line">        &#125;catch (InterruptedException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-入口Run"><a href="#4-入口Run" class="headerlink" title="4) 入口Run"></a>4) 入口<code>Run</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        // 建立缓冲区</div><div class="line">        BlockingQueue&lt;PCData&gt; queue = new LinkedBlockingQueue&lt;&gt;(10);</div><div class="line"></div><div class="line">        // 建立生产者</div><div class="line">        Producer producer1 = new Producer(queue);</div><div class="line">        Producer producer2 = new Producer(queue);</div><div class="line">        Producer producer3 = new Producer(queue);</div><div class="line"></div><div class="line">        // 建立消费者</div><div class="line">        Consumer consumer1 = new Consumer(queue);</div><div class="line">        Consumer consumer2 = new Consumer(queue);</div><div class="line">        Consumer consumer3 = new Consumer(queue);</div><div class="line"></div><div class="line">        // 建立线程池</div><div class="line">        ExecutorService service = Executors.newCachedThreadPool();</div><div class="line"></div><div class="line">        // 运行生产者</div><div class="line">        service.execute(producer1);</div><div class="line">        service.execute(producer2);</div><div class="line">        service.execute(producer3);</div><div class="line"></div><div class="line">        // 运行消费者</div><div class="line">        service.execute(consumer1);</div><div class="line">        service.execute(consumer2);</div><div class="line">        service.execute(consumer3);</div><div class="line">        Thread.sleep(1000);</div><div class="line"></div><div class="line">        // 停止生产者</div><div class="line">        producer1.stop();</div><div class="line">        producer2.stop();</div><div class="line">        producer3.stop();</div><div class="line"></div><div class="line">        Thread.sleep(1000);</div><div class="line">        service.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5 运行结果"></a>5 运行结果</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-21/49301344.jpg" alt=""></p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><ol>
<li>Java程序性能优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;生产者-消费者模式是一个经典的多线程设计模式，它为多线程的协作提供了良好的解决方案。在生产者与消费者模式中，通常有两类线
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA之Future模式</title>
    <link href="http://jianwl.com/2017/06/20/JAVA%E4%B9%8BFuture%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/20/JAVA之Future模式/</id>
    <published>2017-06-20T13:36:05.000Z</published>
    <updated>2017-06-20T15:24:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>Future模式有点类似商品订单，比如在进行网上购物时，当看中某一件商品时，就可以提交订单。当订单处理完毕后，便可在家里等待商品送货上门。卖家根据订单从仓库里取货，并配送到客户手上。在大部分情况下，商家对订单的处理并不那么快，而在这段时间内，客户完全不必傻傻地在家里等待，可以出门处理其他事物。</p>
<h3 id="2-传统串行调用-VS-Future模式"><a href="#2-传统串行调用-VS-Future模式" class="headerlink" title="2. 传统串行调用 VS Future模式"></a>2. 传统串行调用 <code>VS</code> Future模式</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-20/29048455.jpg" alt=""></p>
<p>图1所示，客户端发出call请求，这个请求需要相当长一段时间才能返回。客户端一直等待，直到数据返回，随后，在进行其他任务的处理。</p>
<p>图2显示了一个广义Future模式的实现，从Data_Future对象可以看到，虽然call本身处理仍然需要很长一段时间来处理程序，但是服务程序不等数据处理完成便立即返回客户端一个伪造的数据，实现了Future模式的客户。</p>
<h3 id="3-Future模式的主要参与者"><a href="#3-Future模式的主要参与者" class="headerlink" title="3. Future模式的主要参与者"></a>3. Future模式的主要参与者</h3><table>
<thead>
<tr>
<th>参与者</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Main</td>
<td>系统启动，调用Client发出请求</td>
</tr>
<tr>
<td>Client</td>
<td>返回Data对象，立即返回FutureData，并开启ClientThread线程装配RealData</td>
</tr>
<tr>
<td>Data</td>
<td>返回数据接口</td>
</tr>
<tr>
<td>FutureData</td>
<td>Future数据，构造很快，但是是一个虚拟的数据，需要装配RealData</td>
</tr>
<tr>
<td>RealData</td>
<td>真实数据，其构造是比较慢的</td>
</tr>
</tbody>
</table>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-20/16429145.jpg" alt=""></p>
<h3 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h3><h4 id="1-Data接口"><a href="#1-Data接口" class="headerlink" title="1) Data接口"></a>1) Data接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Data &#123;</div><div class="line">    String getResult();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-真实数据RealData"><a href="#2-真实数据RealData" class="headerlink" title="2) 真实数据RealData"></a>2) 真实数据<code>RealData</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class RealData implements Data &#123;</div><div class="line">    protected final String result;</div><div class="line"></div><div class="line">    public RealData(String para) &#123;</div><div class="line">        StringBuffer sb = new StringBuffer();</div><div class="line">        for(int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            sb.append(para);</div><div class="line">            try&#123;</div><div class="line">                Thread.sleep(100);</div><div class="line">            &#125;catch (InterruptedException e)&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        result = sb.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String getResult() &#123;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3）FutureData"><a href="#3）FutureData" class="headerlink" title="3）FutureData"></a>3）FutureData</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class FutureData implements Data &#123;</div><div class="line">    protected RealData realData = null;</div><div class="line">    protected boolean isReady = false;</div><div class="line">    public synchronized void setRealData(RealData realData) &#123;</div><div class="line">        if (isReady) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        this.realData = realData;</div><div class="line">        isReady = true;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public synchronized String getResult() &#123;</div><div class="line">        while (!isReady) &#123;</div><div class="line">            try &#123;</div><div class="line">                wait();</div><div class="line">            &#125;catch (InterruptedException e)&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return realData.result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-客户端Client"><a href="#4-客户端Client" class="headerlink" title="4) 客户端Client"></a>4) 客户端<code>Client</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public Data request(final String queryStr) &#123;</div><div class="line">        final FutureData future = new FutureData();</div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            RealData realData = new RealData(queryStr);</div><div class="line">            future.setRealData(realData);</div><div class="line">        &#125;).start();</div><div class="line">        return future;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-入口Run"><a href="#5-入口Run" class="headerlink" title="5) 入口Run"></a>5) 入口<code>Run</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Client client = new Client();</div><div class="line">        Data data = client.request(&quot;name&quot;);</div><div class="line">        System.out.println(&quot;请求完毕!&quot;);</div><div class="line">        try&#123;</div><div class="line">            Thread.sleep(100);</div><div class="line">        &#125;catch (InterruptedException e)&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;数据 =&gt; &quot; + data.getResult());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-运行结果"><a href="#6-运行结果" class="headerlink" title="6) 运行结果"></a>6) 运行结果</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-20/38834317.jpg" alt=""></p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><ol>
<li>Java程序性能优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;Future模式有点类似商品订单，比如在进行网上购物时，当看中某一件商品时，就可以提交订单。当订单处理完毕后，便可在家里
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA观察者模式</title>
    <link href="http://jianwl.com/2017/06/18/JAVA%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/18/JAVA观察者模式/</id>
    <published>2017-06-18T14:27:32.000Z</published>
    <updated>2017-06-18T15:00:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>观察者模式是非常常用的一种设计模式，在软件系统中，当一个对象的行为依赖另一个对象的状态时，观察者模式相当有用。若不使用观察者模式提供的通用结构，而需要实现其类似的功能，则只能在另一个线程中不停监听对象所依赖的状态。在一个复杂系统中，可能会因此开启很多线程来实现这一功能，这将使系统的性能产生额外的负担。</p>
<h3 id="2-观察者模式角色"><a href="#2-观察者模式角色" class="headerlink" title="2. 观察者模式角色"></a>2. 观察者模式角色</h3><table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>主题接口</td>
<td>指被观察的对象，当其状态发生变化或者某事件发生时，它会将这个变化通知观察者。它维护了观察者所需要依赖的状态</td>
</tr>
<tr>
<td>具体主题</td>
<td>具体主题实现了主题接口中的方法，如新增观察者、删除观察者和通知观察者。其内部维护一个观察者列表</td>
</tr>
<tr>
<td>观察者接口</td>
<td>观察者接口定义了观察者的基本方法，当依赖状态发生改变时，主题接口就会调用观察者的update()方法</td>
</tr>
<tr>
<td>具体观察者</td>
<td>实现了观察者接口的update()，具体处理当被观察者状态改变或者某一事件发生时的业务逻辑</td>
</tr>
</tbody>
</table>
<h3 id="3-观察者模式类图"><a href="#3-观察者模式类图" class="headerlink" title="3. 观察者模式类图"></a>3. 观察者模式类图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-18/26557541.jpg" alt=""></p>
<h3 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h3><h4 id="主题接口ISubject"><a href="#主题接口ISubject" class="headerlink" title="主题接口ISubject"></a>主题接口<code>ISubject</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface ISubject &#123;</div><div class="line">    void attach(IObserver observer); // 添加观察者</div><div class="line">    void detach(IObserver observer); // 删除观察者</div><div class="line">    void inform(String msg); // 通知所有观察者</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="具体主题ConcreteSubject"><a href="#具体主题ConcreteSubject" class="headerlink" title="具体主题ConcreteSubject"></a>具体主题<code>ConcreteSubject</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class ConcreteSubject implements ISubject &#123;</div><div class="line">    Vector&lt;IObserver&gt; observers = new Vector&lt;IObserver&gt;();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void attach(IObserver observer) &#123;</div><div class="line">        observers.addElement(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void detach(IObserver observer) &#123;</div><div class="line">        observers.removeElement(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void inform(String msg) &#123;</div><div class="line">        for(IObserver ob:observers) &#123;</div><div class="line">            ob.update(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="观察者接口"><a href="#观察者接口" class="headerlink" title="观察者接口"></a>观察者接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface IObserver &#123;</div><div class="line">    void update(String msg); // 更新观察者</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="具体观察者"><a href="#具体观察者" class="headerlink" title="具体观察者"></a>具体观察者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class ConcreteObserve implements IObserver &#123;</div><div class="line">    @Override</div><div class="line">    public void update(String msg) &#123;</div><div class="line">        System.out.println(&quot;observe receive information =&gt; &quot; + JSON.toJSONString(msg));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="入口Run"><a href="#入口Run" class="headerlink" title="入口Run"></a>入口<code>Run</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ConcreteSubject subject = new ConcreteSubject();</div><div class="line">        ConcreteObserve observeA = new ConcreteObserve();</div><div class="line">        ConcreteObserve observeB = new ConcreteObserve();</div><div class="line">        subject.attach(observeA);</div><div class="line">        subject.attach(observeB);</div><div class="line">        subject.inform(&quot;notify-1&quot;);</div><div class="line">        subject.detach(observeB);</div><div class="line">        subject.inform(&quot;notify-2&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-18/64270257.jpg" alt=""></p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><ol>
<li>JAVA程序性能优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;观察者模式是非常常用的一种设计模式，在软件系统中，当一个对象的行为依赖另一个对象的状态时，观察者模式相当有用。若不使用观
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA之享元模式</title>
    <link href="http://jianwl.com/2017/06/17/JAVA%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/17/JAVA之享元模式/</id>
    <published>2017-06-17T10:05:18.000Z</published>
    <updated>2017-06-18T06:41:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>享元模式是设计模式中少数几个以提高系统性能为目的的模式之一；它的核心思想是：<strong>如果在一个系统中存在多个相同的对象，那么只需要共享一份对象的拷贝，而不必为每一次使用都创建新的对象。</strong></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>可以节省重复创建对象的开销；</li>
<li>创建对象的数量减少，对系统的内存需求也减小，使得GC的压力降低；</li>
</ol>
<h3 id="2-享元模式角色"><a href="#2-享元模式角色" class="headerlink" title="2. 享元模式角色"></a>2. 享元模式角色</h3><table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>享元工厂</td>
<td>用以创建具体享元类，维护相同的单元对象。它保证相同的享元对象可以被系统共享。即内部使用了类似单例模式的算法，当请求对象已经存在时，直接返回对象，不存在时，再创建对象</td>
</tr>
<tr>
<td>抽象享元</td>
<td>定义需共享的对象的业务接口。享元类被创建出来总是为了实现某些特定的业务逻辑，而抽象享元便定义这些逻辑的语义行为</td>
</tr>
<tr>
<td>具体享元类</td>
<td>实现抽象享元类的接口，完成某一具体的逻辑</td>
</tr>
<tr>
<td>Main</td>
<td>使用享元模式的组件，通过享元工厂取得享元对象</td>
</tr>
</tbody>
</table>
<h3 id="3-实战"><a href="#3-实战" class="headerlink" title="3. 实战"></a>3. 实战</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-18/33093517.jpg" alt=""></p>
<h4 id="可运行实例"><a href="#可运行实例" class="headerlink" title="可运行实例"></a>可运行实例</h4><h5 id="1、-抽象享元IReportManager"><a href="#1、-抽象享元IReportManager" class="headerlink" title="1、 抽象享元IReportManager"></a>1、 抽象享元<code>IReportManager</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface IReportManager &#123;</div><div class="line">     String createReport();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2、-具体享元类-EmployeeReportManager"><a href="#2、-具体享元类-EmployeeReportManager" class="headerlink" title="2、 具体享元类 EmployeeReportManager"></a>2、 具体享元类 <code>EmployeeReportManager</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class EmployeeReportManager implements IReportManager &#123;</div><div class="line">    protected String tenantId = null;</div><div class="line"></div><div class="line">    public EmployeeReportManager(String tenantId) &#123;</div><div class="line">        this.tenantId = tenantId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String createReport() &#123;</div><div class="line">        return &quot;This is a employee report&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3、-具体享元类-FinancialReportManager"><a href="#3、-具体享元类-FinancialReportManager" class="headerlink" title="3、 具体享元类 FinancialReportManager"></a>3、 具体享元类 <code>FinancialReportManager</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class FinancialReportManager implements IReportManager &#123;</div><div class="line">    protected String tenantId = null;</div><div class="line"></div><div class="line">    public FinancialReportManager(String tenantId) &#123;</div><div class="line">        this.tenantId = tenantId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String createReport() &#123;</div><div class="line">        return &quot;This is a financial report&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4、-享元工厂ReportManagerFactory"><a href="#4、-享元工厂ReportManagerFactory" class="headerlink" title="4、 享元工厂ReportManagerFactory"></a>4、 享元工厂<code>ReportManagerFactory</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ReportManagerFactory &#123;</div><div class="line">    Map&lt;String,IReportManager&gt; finanacialReportManager = new HashMap&lt;String,IReportManager&gt;();</div><div class="line">    Map&lt;String,IReportManager&gt; employeeReportManager = new HashMap&lt;String,IReportManager&gt;();</div><div class="line"></div><div class="line">    IReportManager getFinancialReportManager(String tenantId)&#123;</div><div class="line">        IReportManager r = finanacialReportManager.get(tenantId);</div><div class="line">        if (r == null) &#123;</div><div class="line">            r = new FinancialReportManager(tenantId);</div><div class="line">            finanacialReportManager.put(tenantId,r);</div><div class="line">        &#125;</div><div class="line">        return r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    IReportManager getEmployeeReportReportManger(String tenantId)&#123;</div><div class="line">        IReportManager r = employeeReportManager.get(tenantId);</div><div class="line">        if (r == null) &#123;</div><div class="line">            r = new EmployeeReportManager(tenantId);</div><div class="line">            employeeReportManager.put(tenantId,r);</div><div class="line">        &#125;</div><div class="line">        return r;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5、-入口Run"><a href="#5、-入口Run" class="headerlink" title="5、 入口Run"></a>5、 入口<code>Run</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ReportManagerFactory rmf = new ReportManagerFactory();</div><div class="line">        IReportManager rm = rmf.getFinancialReportManager(&quot;A&quot;);</div><div class="line">        System.out.println(rm.createReport());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="6-运行结果"><a href="#6-运行结果" class="headerlink" title="6. 运行结果"></a>6. 运行结果</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-18/81872942.jpg" alt=""></p>
<h3 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h3><ol>
<li>JAVA程序性能优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;享元模式是设计模式中少数几个以提高系统性能为目的的模式之一；它的核心思想是：&lt;strong&gt;如果在一个系统中存在多个相同
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA之装饰者模式</title>
    <link href="http://jianwl.com/2017/06/09/JAVA%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/09/JAVA之装饰者模式/</id>
    <published>2017-06-09T00:31:39.000Z</published>
    <updated>2017-06-10T03:23:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>装饰者模式拥有一个设计非常精巧的结构，它可以动态添加对象功能，在基本的设计原则中，有一条重要的设计准则叫做<strong>合成/聚合复用原则。</strong>根据该原则的思想，代码复用应该尽可能使用委托，而不是使用继承。因为继承是一种紧密耦合，任何父类的改动都会影响其子类，不利于系统维护。而委托则是松散耦合，只要接口不变，委托类的改动并不会影响上层对象。</p>
<p>装饰者模式就充分运用了这种思想，通过委托机制，复用系统中的各个组件，在运行时，可以将这些功能进行叠加，从而构造一个“超级对象”，使其拥有所有这些组件的功能。而各个子模块功能，被很好地维护在各个组件的相关类中 ，拥有整洁的系统结构。</p>
<h3 id="2-装饰者模式基本结构"><a href="#2-装饰者模式基本结构" class="headerlink" title="2. 装饰者模式基本结构"></a>2. 装饰者模式基本结构</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-9/53287711.jpg" alt=""></p>
<p>装饰者(Decorator) 和被装饰者(ConcreteComponent)拥有相同的接口Component，被装饰者通常是系统的核心组件，完成特定的功能目标。而装饰者则可以在被装饰者的方法前后，加上特定的前置处理和后置处理，增强被装饰者的功能。</p>
<p>装饰者模式角色</p>
<table>
<thead>
<tr>
<th style="text-align:left">角色</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">组件接口</td>
<td style="text-align:center">组件接口是装饰者和被装饰者的超类或接口，它定义了被装饰者的核心功能和装饰者需要加强的功能点。</td>
</tr>
<tr>
<td style="text-align:left">具体组件</td>
<td style="text-align:center">具体组件实现了组件接口的核心方法，完成某一个具体的业务逻辑，它也是被装饰的对象</td>
</tr>
<tr>
<td style="text-align:left">装饰者</td>
<td style="text-align:center">实现组件接口，并持有一个具体的被装饰对象</td>
</tr>
<tr>
<td style="text-align:left">具体装饰者</td>
<td style="text-align:center">具体实现装饰的业务逻辑，即实现了被分离的各个增强功能点，各个具体装饰者是可以相互叠加的，从而可以构成一个功能更强大的组件对象</td>
</tr>
</tbody>
</table>
<h3 id="3-实战"><a href="#3-实战" class="headerlink" title="3. 实战"></a>3. 实战</h3><h4 id="1）场景描述"><a href="#1）场景描述" class="headerlink" title="1）场景描述"></a>1）场景描述</h4><p>将某一结果通过HTML进行发布，那么首先就需要将内容转化为一个HTML文本，同时由于内容要在网络上通过HTTP流传，故还需要为其增加HTTP头。</p>
<h4 id="2）类图"><a href="#2）类图" class="headerlink" title="2）类图"></a>2）类图</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-10/63142422.jpg" alt=""></p>
<h4 id="3-可运行实例"><a href="#3-可运行实例" class="headerlink" title="3) 可运行实例"></a>3) 可运行实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">// Component</div><div class="line">public interface IPacketCreator &#123;</div><div class="line">    String handleContent();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Concrete Component</div><div class="line">public class PacketBodyCreator implements IPacketCreator &#123;</div><div class="line">    @Override</div><div class="line">    public String handleContent() &#123;</div><div class="line">        return &quot;Content of Packet&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Decorator</div><div class="line">public abstract class PacketDecorator implements IPacketCreator &#123;</div><div class="line">    IPacketCreator component;</div><div class="line"></div><div class="line">    public PacketDecorator(IPacketCreator component) &#123;</div><div class="line">        this.component = component;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Concrete Decorator</div><div class="line">public class PacketHTTPHeaderCreator extends PacketDecorator &#123;</div><div class="line">    public PacketHTTPHeaderCreator(IPacketCreator component) &#123;</div><div class="line">        super(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String handleContent() &#123;</div><div class="line">        StringBuffer sb = new StringBuffer();</div><div class="line">        sb.append(&quot;Cache-Control:no-cache\n&quot;);</div><div class="line">        sb.append(&quot;Date:2017-06-10\n&quot;);</div><div class="line">        sb.append(component.handleContent());</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Concrete Decorator</div><div class="line">public class PacketHTMLHeaderCreator extends PacketDecorator &#123;</div><div class="line"></div><div class="line">    public PacketHTMLHeaderCreator(IPacketCreator component) &#123;</div><div class="line">        super(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String handleContent() &#123;</div><div class="line">        StringBuffer sb = new StringBuffer();</div><div class="line">        sb.append(&quot;&lt;html&gt;&quot;);</div><div class="line">        sb.append(&quot;&lt;body&gt;&quot;);</div><div class="line">        sb.append(component.handleContent());</div><div class="line">        sb.append(&quot;&lt;/body&gt;&quot;);</div><div class="line">        sb.append(&quot;&lt;/html&gt;\n&quot;);</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 运行</div><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        IPacketCreator pc = new PacketHTTPHeaderCreator(new PacketHTMLHeaderCreator(new PacketBodyCreator()));</div><div class="line">        System.out.println(pc.handleContent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-10/21550495.jpg" alt=""></p>
<h3 id="4-JDK中用装饰者的实例"><a href="#4-JDK中用装饰者的实例" class="headerlink" title="4. JDK中用装饰者的实例"></a>4. JDK中用装饰者的实例</h3><h4 id="1-描述"><a href="#1-描述" class="headerlink" title="1) 描述"></a>1) 描述</h4><p>OutStream为核心的装饰者模式的实现，其中FileOutputStream为系统的核心类，它实现了向文件写入数据。使用DataOutputStream可以在FileOutputStream的基础上，增加对多种数据类型的写操作，而BufferedOutputStream秀使其，可以对FileOutputStream增加缓冲功能，优化I/O的性能，以BufferedOutputStream为代表的性能组件，是将性能模块和功能模块分离的一种典型实现。</p>
<h4 id="2-类图"><a href="#2-类图" class="headerlink" title="2) 类图"></a>2) 类图</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-10/56315217.jpg" alt=""></p>
<h4 id="3）可运行实例"><a href="#3）可运行实例" class="headerlink" title="3）可运行实例"></a>3）可运行实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class OutputStreamTest &#123;</div><div class="line">    public static void notBufferOut()&#123;</div><div class="line">        long start = System.currentTimeMillis();</div><div class="line">        try &#123;</div><div class="line">            DataOutputStream dout = new DataOutputStream(new FileOutputStream(&quot;/Users/jianweilin/Desktop/output1.txt&quot;));</div><div class="line">            for (int i=0; i&lt; 1000; i++) &#123;</div><div class="line">                dout.writeInt(i);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;notBufferOut spend =&gt; &quot; + (System.currentTimeMillis() - start));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void bufferOut()&#123;</div><div class="line">        long start = System.currentTimeMillis();</div><div class="line">        try &#123;</div><div class="line">            DataOutputStream dout = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(&quot;/Users/jianweilin/Desktop/output2.txt&quot;)));</div><div class="line">            for (int i=0; i&lt; 1000; i++) &#123;</div><div class="line">                dout.writeInt(i);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;bufferOut spend =&gt; &quot; + (System.currentTimeMillis() - start));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        notBufferOut();</div><div class="line">        bufferOut();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结果</div><div class="line">// notBufferOut spend =&gt; 11</div><div class="line">// bufferOut spend =&gt; 1</div></pre></td></tr></table></figure>
<h4 id="4-工作流程图"><a href="#4-工作流程图" class="headerlink" title="4) 工作流程图"></a>4) 工作流程图</h4><p><code>FileOutputStream.write()</code>的调用之前，会首先调用<code>BufferedOutputStream.write()</code>。且<code>BufferedOutputStream.write()</code>不会每次都去磁盘写数据，而是将数据写入缓存，当缓存满时，才会调用<code>FileOutputStream.write()</code>方法，实际写入数据。以此实现性能组件与功能组件的分离。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-10/51627202.jpg" alt=""></p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><ol>
<li>Java程序性能优化 by 葛一鸣</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;装饰者模式拥有一个设计非常精巧的结构，它可以动态添加对象功能，在基本的设计原则中，有一条重要的设计准则叫做&lt;strong
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>单例模式之性能比较</title>
    <link href="http://jianwl.com/2017/06/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"/>
    <id>http://jianwl.com/2017/06/08/单例模式之性能比较/</id>
    <published>2017-06-08T14:00:55.000Z</published>
    <updated>2017-06-08T14:48:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>设计模式是前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是对某一特定问题的成熟解决方案。如果能合理地使用设计模式，不仅能使系统更容易被他人理解，同时也能使系统拥有更加合理的结构。本节将对单例模式多种实现进行性能分析。</p>
<h3 id="2-单例模式的好处"><a href="#2-单例模式的好处" class="headerlink" title="2. 单例模式的好处"></a>2. 单例模式的好处</h3><ol>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于new操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间。</li>
</ol>
<h3 id="3-多种实现方式"><a href="#3-多种实现方式" class="headerlink" title="3. 多种实现方式"></a>3. 多种实现方式</h3><h4 id="1-简单的单例实现"><a href="#1-简单的单例实现" class="headerlink" title="1) 简单的单例实现"></a>1) 简单的单例实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton instance = new Singleton();</div><div class="line"></div><div class="line">    private Singleton() &#123;</div><div class="line">        System.out.println(&quot;Singleton is create&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Singleton getInstance()&#123;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void createString()&#123;</div><div class="line">        System.out.println(&quot;createString in Singleton&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Singleton.createString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缺点是无法对instance实例延迟加载，在任何地方使用这个单例类都会初始化这个单例变量，就如例子中的一样，仅仅只调用<code>createString</code>方法，也会初始化单例变量；</p>
<h4 id="2-延迟加载"><a href="#2-延迟加载" class="headerlink" title="2) 延迟加载"></a>2) 延迟加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class LazySingleton &#123;</div><div class="line">    private static LazySingleton instance = null;</div><div class="line"></div><div class="line">    private LazySingleton()&#123;</div><div class="line">        System.out.println(&quot;LazySingleton is create&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static synchronized LazySingleton getInstance()&#123;</div><div class="line">        if (instance == null) &#123;</div><div class="line">            instance = new LazySingleton();</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void createString()&#123;</div><div class="line">        System.out.println(&quot;createString in Singleton&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        LazySingleton.createString()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 结果</div><div class="line">// createString in Singleton</div></pre></td></tr></table></figure>
<p>为了解决例1中的问题，引入延迟加载机制，但这种延迟加载有一致命的缺点，因为引入了同步关键字，在多线程环境时耗远远大于第一种单例模式。</p>
<h4 id="3-改进"><a href="#3-改进" class="headerlink" title="3) 改进"></a>3) 改进</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class StaticSingleton &#123;</div><div class="line">    private StaticSingleton()&#123;</div><div class="line">        System.out.println(&quot;StaticSingleton is create&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class SingletonHolder &#123;</div><div class="line">        private static StaticSingleton instance = new StaticSingleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static StaticSingleton getInstance()&#123;</div><div class="line">        return SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例2为了使用延迟加载引入同步关键字降低了性能，为了解决这个问题，引入例3。当StaticSingleton被加载时，内部类不会被初始化。</p>
<h4 id="4-三种模式性能比较"><a href="#4-三种模式性能比较" class="headerlink" title="4) 三种模式性能比较"></a>4) 三种模式性能比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">// 实现1</div><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton instance = new Singleton();</div><div class="line"></div><div class="line">    public static Singleton getInstance()&#123;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实现2</div><div class="line">public class LazySingleton &#123;</div><div class="line">    private static LazySingleton instance = null;</div><div class="line"></div><div class="line">    public static synchronized LazySingleton getInstance()&#123;</div><div class="line">        if (instance == null) &#123;</div><div class="line">            instance = new LazySingleton();</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实现3</div><div class="line">public class StaticSingleton &#123;</div><div class="line">    private static class SingletonHolder &#123;</div><div class="line">        private static StaticSingleton instance = new StaticSingleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static StaticSingleton getInstance()&#123;</div><div class="line">        return SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 主类</div><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            long startTime = System.currentTimeMillis();</div><div class="line">            for (int j = 0; j &lt; 100000000; j++) &#123;</div><div class="line">                Singleton.getInstance();</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;Singleton spend =&gt; &quot; + (System.currentTimeMillis() - startTime));</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            long startTime = System.currentTimeMillis();</div><div class="line">            for (int j = 0; j &lt; 100000000; j++) &#123;</div><div class="line">                LazySingleton.getInstance();</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;LazySingleton spend =&gt; &quot; + (System.currentTimeMillis() - startTime));</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            long startTime = System.currentTimeMillis();</div><div class="line">            for (int j = 0; j &lt; 100000000; j++) &#123;</div><div class="line">                StaticSingleton.getInstance();</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;StaticSingleton spend =&gt; &quot; + (System.currentTimeMillis() - startTime));</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结果</div><div class="line">// Singleton spend =&gt; 8</div><div class="line">// StaticSingleton spend =&gt; 10</div><div class="line">// LazySingleton spend =&gt; 3268</div></pre></td></tr></table></figure>
<h3 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h3><ol>
<li>Java程序性能优化 by 葛一鸣</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;设计模式是前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是对某一特定问题的成熟解决方案。如果能合理地使用设计模式
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Java之异常</title>
    <link href="http://jianwl.com/2017/06/04/Java%E4%B9%8B%E5%BC%82%E5%B8%B8-0/"/>
    <id>http://jianwl.com/2017/06/04/Java之异常-0/</id>
    <published>2017-06-04T04:26:45.000Z</published>
    <updated>2017-06-04T05:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-4/26082118.jpg" alt=""></p>
<p>在Java程序运行时，常常会出现一些非正常现象，根据其性质分为<strong>错误和异常。</strong> Java程序中，所有抛出的异常都必须从<code>Throwable</code>派生而来。Throwable有两个直接子类：Error和Exception。</p>
<p>Error</p>
<p>常见的错误有程序进入死循环、内存泄露等</p>
<p>Exception</p>
<p>异常分为受检异常 &amp; 非受检异常。受检异常是去除RuntimeExeption的其他直接继承Exception的子类；非受检异常是直接继承RunTimeException的子类；</p>
<p>对于受检异常，必须要用<code>try catch</code>去处理这个异常，或者在方法加上<code>throws</code>暗示这个方法可能会抛出某种异常。</p>
<p>非受检异常，不需要明确地去处理这个异常；</p>
<h3 id="2-受检异常-amp-非受检异常实战"><a href="#2-受检异常-amp-非受检异常实战" class="headerlink" title="2. 受检异常 &amp; 非受检异常实战"></a>2. 受检异常 &amp; 非受检异常实战</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-4/31638990.jpg" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://stackoverflow.com/questions/2190161/difference-between-java-lang-runtimeexception-and-java-lang-exception" target="_blank" rel="external">difference between java.lang.RuntimeException and java.lang.Exception</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 基本概念&quot;&gt;&lt;/a&gt;1. 基本概念&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.clouddn.com/17-6-4/26
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Java之ClassLoader</title>
    <link href="http://jianwl.com/2017/06/03/Java%E4%B9%8BClassLoader/"/>
    <id>http://jianwl.com/2017/06/03/Java之ClassLoader/</id>
    <published>2017-06-03T01:44:51.000Z</published>
    <updated>2017-06-04T05:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ClassLoader基本概念"><a href="#1-ClassLoader基本概念" class="headerlink" title="1. ClassLoader基本概念"></a>1. ClassLoader基本概念</h3><p>Java程序是由许多独立的类文件组成的，每一个文件对应一个Java类。此外，<strong>这些类文件并非全部装入内存，而是根据程序需要逐渐载入。</strong> </p>
<p>ClassLoader是JVM实现的一部分，ClassLoader 包括 bootstrap classloader(启动类加载器), ClassLoader在JVM运行的时候加载Java核心的API，以满足Java程序最基本的需求，其中就包括用户定义的ClassLoader: <strong>一个是ExtClassLoader，它的作用是用来加载Java的扩展API，也就是/lib/ext中的类；第二个是AppClassLoader,它是用来加载用户机器上CLASSPATH设置目录中的Class的，通常在没有指定ClassLoader的情况下，自定义的类就由该ClassLoader进行加载。</strong></p>
<h3 id="2-ClassLoader加载流程"><a href="#2-ClassLoader加载流程" class="headerlink" title="2. ClassLoader加载流程"></a>2. ClassLoader加载流程</h3><p>当运行一个程序的时候，JVM启动，运行bootstrap classloader，该ClassLoader加载Java核心API(ExtClassLoader和AppClassLoader也在此时被加载)，然后调用ExtClassLoader加载扩展API，最后AppClassLoader加载CLASSPATH目录下定义的Class，这就是一个程序最基本的加载流程。</p>
<p>核心代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</div><div class="line">    throws ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    synchronized (getClassLoadingLock(name)) &#123;</div><div class="line">        // 首先检查该name指定的class是否被加载</div><div class="line">        Class&lt;?&gt; c = findLoadedClass(name);</div><div class="line">        if (c == null) &#123;</div><div class="line">            long t0 = System.nanoTime();</div><div class="line">            try &#123;</div><div class="line">                if (parent != null) &#123;</div><div class="line">                // 如果parent不为null，则调用parent的loadclass进行加载</div><div class="line">                    c = parent.loadClass(name, false);</div><div class="line">                &#125; else &#123;</div><div class="line">                // parent为null，则调用BootstrapClassLoader进行加载</div><div class="line">                    c = findBootstrapClassOrNull(name);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (c == null) &#123;</div><div class="line">                long t1 = System.nanoTime();</div><div class="line">                // 如果仍然无法加载成功，则调用自身的findClass进行加载；</div><div class="line">                c = findClass(name);</div><div class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class="line">                sun.misc.PerfCounter.getFindClasses().increment();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (resolve) &#123;</div><div class="line">            resolveClass(c);</div><div class="line">        &#125;</div><div class="line">        return c;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述代码中可以看出，<strong>一个类加载的过程使用了一种父类委托模式。</strong>为什么要使用这种模式？</p>
<ol>
<li>可以避免重复加载，当父类已经加载了该类的时候，就没有必要子ClassLoader再加载一次。</li>
<li>考虑到安全因素，如果不使用这种委托模式，那么可以随时使用自定义的String来动态替换Java核心API中定义的类型，这样会存在非常大的安全隐患，而父类委托的方式可以避免这种情况，因为String已经在启动时被加载，所以，用户自定义类无法加载一个自定义的ClassLoader</li>
</ol>
<h3 id="3-JVM加载类的流程"><a href="#3-JVM加载类的流程" class="headerlink" title="3. JVM加载类的流程"></a>3. JVM加载类的流程</h3><p>JVM加载类的时候，需要经过三个步骤：装载、连接、初始化。装载就是找到相应的class文件，读入JVM；初始化就是class文件初始化，这里详述一下连接，连接分为三步：</p>
<ol>
<li>验证class是否符合规范</li>
<li>准备，为类变量分配内存的同时设置默认初始值</li>
<li>解释，这步可选，根据loadClass中的是否需要解析的参数。解释指: 根据类中的符号引用查找相应的实体，再把符号引用替换成一个直接引用的过程。</li>
</ol>
<h3 id="4-一些重要的方法"><a href="#4-一些重要的方法" class="headerlink" title="4. 一些重要的方法"></a>4. 一些重要的方法</h3><h4 id="1-loadClass"><a href="#1-loadClass" class="headerlink" title="1) loadClass"></a>1) loadClass</h4><p>ClassLoader.loadClass()ClassLoader的入口点，定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class loadClass( String name, boolean resolve );</div></pre></td></tr></table></figure>
<p>name是JVM需要的类名称，如java.lang.Object。resolve参数告诉方法是否需要解析类。如果JVM只需要知道该类是否存在或找出该类的超类，那么就不需要解析；</p>
<h4 id="2-defineClass"><a href="#2-defineClass" class="headerlink" title="2) defineClass"></a>2) defineClass</h4><p>defineClass方法接受由原始字节组成的数组，并把它转换成Class对象。</p>
<h4 id="3-findSystemClass"><a href="#3-findSystemClass" class="headerlink" title="3) findSystemClass"></a>3) findSystemClass</h4><p>findSystemClass方法从本地文件系统装入文件。</p>
<h4 id="4）resolveClass"><a href="#4）resolveClass" class="headerlink" title="4）resolveClass"></a>4）resolveClass</h4><p>当我们编写自己的loadClass时，可以调用 resolveClass,这取决于 loadClass的resolve参数的值。</p>
<h4 id="5-findLoadedClass"><a href="#5-findLoadedClass" class="headerlink" title="5) findLoadedClass"></a>5) findLoadedClass</h4><p>findLoadedClass充当一个缓存，当请求loadClass装入类时，它调用该方法来查看ClassLoader是否已装入这个类，这样可以避免重新装入已存在类所造成的麻烦。</p>
<h4 id="6-findClass"><a href="#6-findClass" class="headerlink" title="6) findClass"></a>6) findClass</h4><p>findClass可以从本地文件系统使用实现的类装载器装载一个类。</p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h3><ol>
<li>Java面试宝典 by 欧立奇 朱梅等</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-ClassLoader基本概念&quot;&gt;&lt;a href=&quot;#1-ClassLoader基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. ClassLoader基本概念&quot;&gt;&lt;/a&gt;1. ClassLoader基本概念&lt;/h3&gt;&lt;p&gt;Java程序是由
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>数据库读写分离&amp;水分拆分&amp;垂直拆分</title>
    <link href="http://jianwl.com/2017/05/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB-%E6%B0%B4%E5%88%86%E6%8B%86%E5%88%86-%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86/"/>
    <id>http://jianwl.com/2017/05/21/数据库读写分离-水分拆分-垂直拆分/</id>
    <published>2017-05-21T07:14:15.000Z</published>
    <updated>2017-05-21T09:28:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数据库读写分离"><a href="#1-数据库读写分离" class="headerlink" title="1. 数据库读写分离"></a>1. 数据库读写分离</h3><p>随着业务的发展，我们的数据量和访问量都在增长，对于大型网站来说，有不少业务是读多写少的，这个状况也会直接反应到数据库上，那么对于这样的情况，我们可以考虑使用读写分离的方式。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/96626968-file_1495352158645_1675c.png" alt=""></p>
<p>通过读库来分担主库上读的压力，数据库提供了数据复制的功能，我们可以直接使用数据库系统自身的功能，但对于数据复制，我们还需要考虑数据复制时延问题，以及复制过程中数据的源和目标之间的映射关系及过滤条件的支持问题。<strong>数据复制延迟带来的就是短期的数据不一致。</strong>例如我们修改了用户信息，在这个信息还没有复制到读库时(因为延时)，我们从读库上读出来的信息就不是最新的，如果把这个信息给进行修改的人看，就会让他觉得没有修改成功。</p>
<h3 id="2-专库专用，数据库垂直拆分"><a href="#2-专库专用，数据库垂直拆分" class="headerlink" title="2. 专库专用，数据库垂直拆分"></a>2. 专库专用，数据库垂直拆分</h3><p>读写分离能够降低主库的压力，解决读的问题，但却无法解决主库写的问题。随着业务的发展，我们的主库也会遇到瓶颈，因此需要解决这个问题，有数据垂直拆分和水平拆分两种选择。</p>
<p>垂直拆分的意思是把数据库中不同的业务数据拆分到不同的数据库中。结合现在的例子，就是把交易、商品、用户的数据分开。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/73834200-file_1495353291315_4f78.png" alt=""></p>
<h4 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h4><p>这样的变化给我们带来的影响是什么呢？应用需要配置多个数据源，这就增加了所需的配置，不过带来的是每个数据库连接池的隔离。不同业务的数据，从原来一个数据库拆分到了多个数据库中，那么就需要<strong>考虑如何处理原来单机中跨业务的事务</strong>。一种办法是使用分布式事务，其性能要明显低于之前的单机事务；而另一种办法就是去掉事务或者不去追求强事务支持，则原来在单裤中可以使用的表关联的查询也就需要改变实现了。</p>
<p>对数据垂直拆分之后，解决了把所有业务数据放在一个数据库中的压力问题。并且也可以根据不同业务的特定进行更多优化。</p>
<h3 id="3-垂直拆分后的单机遇到瓶颈，数据库水平拆分"><a href="#3-垂直拆分后的单机遇到瓶颈，数据库水平拆分" class="headerlink" title="3. 垂直拆分后的单机遇到瓶颈，数据库水平拆分"></a>3. 垂直拆分后的单机遇到瓶颈，数据库水平拆分</h3><p>数据库水平拆分就是把同一个表的数据拆分到两个数据库中。产生数据水平拆分的原因是某个业务的数据表的数据量或者更新量达到了单个数据库的瓶颈，这时就可以把这个表拆分到两个或者多个数据库中。</p>
<p><strong>数据水平拆分</strong>与<strong>读写分离</strong>的区别是，读写分离解决的是读压力大的问题，对于数据库量大或者更新量的情况并不起作用。</p>
<p><strong>数据水平拆分与数据垂直拆分</strong>的区别是，垂直拆分是把不同的表拆分到不同的数据库中，而水平拆分是把一个表拆到不同的数据库中。</p>
<p>例如，经过垂直拆分后，用户表与交易表、商品表不在一个数据库中了，如果数据量或者更新量太大，我们可以进一步把用户表拆分到两个数据库中，他们拥有结构一模一样的用户表，而且每个库中的用户表都只涵盖了一部分的用户，两个数据库的用户合在一起就相当于没有拆分之前的用户表。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/29829023-file_1495358662307_17eca.png" alt=""></p>
<h4 id="水平拆分给业务应用带来的影响"><a href="#水平拆分给业务应用带来的影响" class="headerlink" title="水平拆分给业务应用带来的影响"></a>水平拆分给业务应用带来的影响</h4><ol>
<li>访问用户信息的应用系统应该解决SQL路由的问题，因为现在用户信息分在两个数据库中，需要在进行数据库操作时了解需要操作的数据在哪里。</li>
<li>主键的处理也会变得不同。原来依赖单个数据库的一些机制需要变化。例如原来使用MYSQL表上的自增字段，现在不能简单地继续使用了，并且在不同的数据库中也不能直接使用一些数据库的限制来保证主键不重复。</li>
<li>由于同一个业务的数据被拆分到了不同的数据库中，因此一些查询需要从两个数据库中取数据，如果数据量太大而需要分页，就比较难处理了。</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>大型网站与Java中间件实践 by 曾宪杰</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-数据库读写分离&quot;&gt;&lt;a href=&quot;#1-数据库读写分离&quot; class=&quot;headerlink&quot; title=&quot;1. 数据库读写分离&quot;&gt;&lt;/a&gt;1. 数据库读写分离&lt;/h3&gt;&lt;p&gt;随着业务的发展，我们的数据量和访问量都在增长，对于大型网站来说，有不少业务是读多
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>应用服务器变为集群后的Session问题</title>
    <link href="http://jianwl.com/2017/05/21/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%98%E4%B8%BA%E9%9B%86%E7%BE%A4%E5%90%8E%E7%9A%84Session%E9%97%AE%E9%A2%98/"/>
    <id>http://jianwl.com/2017/05/21/应用服务器变为集群后的Session问题/</id>
    <published>2017-05-21T04:17:24.000Z</published>
    <updated>2017-05-21T07:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h3><p>用户使用网站的服务，基本上需要浏览器与Web服务器的多次交互，HTTP协议本身是无状态的，需要基于HTTP协议支持会话状态(Session State)机制。而这样的机制应该可以使Web服务器从多次单独的HTTP请求中看到”会话”，也就是知道哪些请求是来自哪个会话。具体实现方式为：在会话开始时，分配一个唯一的会话标识(SessionId),通过Cookie把这个标识告诉浏览器，以后每次请求的时候，浏览器都会带上这个会话标识来告诉Web服务器请求是属于哪个会话的。在Web服务器上，各个会话有独立的存储，保存不同会话的信息。如果遇到禁用Cookie的情况，一般的做法就是把这个会话标识放到URL的参数中。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/73320721-file_1495340830067_51c1.png" alt=""></p>
<p>当我们的应用服务器从一台变成两台后，我们会遇到Session的问题，具体是指什么问题？</p>
<p>当一个带有会话标识的HTTP请求到了Web服务器后，需要在HTTP请求的处理过程中找到对应的会话数据(Session)。而问题就在于，会话数据是需要保存在单机上的。如果我第一次访问网站时请求到了A服务器，那么我的Session就创建在A服务器上，如果我们不做处理，就不能保证接下来的请求每次都落在A服务器上了，这就是Session问题。以下提供几种解决方案。</p>
<h3 id="1-Session-Sticky"><a href="#1-Session-Sticky" class="headerlink" title="1. Session Sticky"></a>1. Session Sticky</h3><p>在单机的情况下，会话保存在单机上，请求也都是由这个机器处理，所以不会有问题。Web服务器变成多台后，如果保证同一个会话的请求都在同一个Web服务器上处理，那么对这个会话的个体来说，与之前的单机情况是一样的。</p>
<p>如果要做到这样，就需要负责均衡器能够根据每次请求的会话标识来进行请求转发，如图所示：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/57581734-file_1495341619642_c22b.png" alt=""></p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>如果有一台Web服务器宕机或者重启，那么这台机器上的会话数据会丢失。<strong>如会话中有登录状态的数据，那么用户就要重新登录了。</strong></li>
<li>会话标识是应用层的信息，那么负载均衡要将同一个会话的请求保存到一个Web服务器上的话，就需要进行应用层(第7层)的解析，这个开销比传输层(第四层)的交换要大。</li>
<li>负载均衡器变为一个有状态的节点，要将会话保存到Web服务器的映射。和无状态的节点相比，内存消耗会更大，容灾方面会更麻烦。</li>
</ol>
<p>这种方式我们成为Session Sticky。打个比方来说，如果说Web服务器是我们每次吃饭的饭店，会话数据就是我们吃饭用的碗筷。要保证每次吃饭都用自己的碗筷的话，我就餐具存在某一家，并且每次都去这家店吃，是个不错的主要。</p>
<h3 id="2-Session-Replication"><a href="#2-Session-Replication" class="headerlink" title="2. Session Replication"></a>2. Session Replication</h3><p>在Session Replication 方式中，不再要求负载均衡器来保存同一个会话的多次请求必须到同一个Web浏览器上了。而我们的Web服务器之间则增加了会话数据的同步。通过同步就保证了不同Web服务器之间的Session数据的一致。就如同每家饭店都有我的碗筷，我就能随便选择去哪家吃饭了。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/38549929-file_1495343662631_181a9.png" alt=""></p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>同步Session数据造成了网络带宽的开销，只要Session数据有变化，就需要将数据同步到所有其他机器上，机器数越多，同步带来的网络带宽开销就越大。</li>
<li>每台Web服务器都需要保存所有的Session数据，如果整个集群的Session数很多(很多人在同时访问网站)的话，每台机器用于保存Session数据的内容占用会很严重。</li>
</ol>
<p>这个方案<strong>不适合集群机器数很多</strong>的场景，如果只有几台机器，用这个方案是可以的。</p>
<h3 id="3-Session数据集中存储"><a href="#3-Session数据集中存储" class="headerlink" title="3. Session数据集中存储"></a>3. Session数据集中存储</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/2688929-file_1495344473634_f8d1.png" alt=""></p>
<p>不论哪台Web服务器，也不论修改的是哪个Session数据，最终的修改都发生在这个集中存储的地方，而Web服务器使用Session时，也是从这个集中存储Sesson数据的地方读取。这样的方式保证了不同服务器上读到的Session数据都是一样的，而存储Session数据的具体方式，可以使用数据库，也可以使用其他分布式存储系统。这个方案解决了Session Replication方案中内存的问题，而对于网络带宽，这个方案也比Session Replication更好。</p>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>读写Session数据引入了网络操作，这相对于本机的数据读取来说，问题就在于存在时延和不稳定性，不过我们的通信基本都是发生在内网，问题不大。</li>
<li>如果集中存储Session机制或者集群出现问题，会影响应用。</li>
</ol>
<p>当Web服务器数据量比较大，Session数比较多的时候，这个集中存储方案的优势非常明显。</p>
<h3 id="4-Cookie-Based"><a href="#4-Cookie-Based" class="headerlink" title="4. Cookie Based"></a>4. Cookie Based</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/66593639-file_1495345259153_114b5.png" alt=""></p>
<p>相对于前面的方案，这个方案不会依赖外部的一个存储系统，也不存在从外部系统获取，写入Session数据的网络时延，不稳定性了。但这个方案依然有不足。</p>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>Cookie长度的限制，我们知道Cookie是有长度限制的，而这也会限制Session数据的长度。</li>
<li>安全性。Session数据本来都是服务器数据，而这个方案是让这些服务器数据到了外部网络及客户端，因此存在<strong>安全性上</strong>的问题。我们可以对写入Cookie的Session数据做加密，不过对于安全来说，物理上不能接触才是安全的。</li>
<li>带宽消耗，这里指的不是内部Web服务器之间的带宽消耗，而是我们数据中心的整体外部带宽的消耗。</li>
<li>性能影响，每次HTTP请求和响应都带有Session数据，对Web服务器来说，在同样的处理情况下，响应的结果输出越少，支持的并发请求就会越多。</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>大型网站系统与Java中间件实践 by 曾宪杰</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是session&quot;&gt;&lt;a href=&quot;#什么是session&quot; class=&quot;headerlink&quot; title=&quot;什么是session&quot;&gt;&lt;/a&gt;什么是session&lt;/h3&gt;&lt;p&gt;用户使用网站的服务，基本上需要浏览器与Web服务器的多次交互，HTTP协议本
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统的基础知识</title>
    <link href="http://jianwl.com/2017/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://jianwl.com/2017/05/21/分布式系统的基础知识/</id>
    <published>2017-05-21T01:21:40.000Z</published>
    <updated>2017-05-21T02:22:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-用户访问网站"><a href="#1-用户访问网站" class="headerlink" title="1. 用户访问网站"></a>1. 用户访问网站</h3><h4 id="1）-用户访问单台服务器的场景"><a href="#1）-用户访问单台服务器的场景" class="headerlink" title="1） 用户访问单台服务器的场景"></a>1） 用户访问单台服务器的场景</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/35909323-file_1495331531540_101c3.png" alt=""></p>
<p>随着压力增大，我们需要变为多台服务器，例如从一台变为两台。两台服务器一起完成工作，这里面就有一个问题，用户应该去访问哪个服务器呢？</p>
<h4 id="2）用户访问集群服务器的场景-一"><a href="#2）用户访问集群服务器的场景-一" class="headerlink" title="2）用户访问集群服务器的场景(一)"></a>2）用户访问集群服务器的场景(一)</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/34398153-file_1495331435274_126a5.png" alt=""></p>
<p>通过DNS服务器进行调度和控制，在用户解析DNS的时候，就会被给予一个服务器的地址，中间没有代理设备，用户能直接知道提供服务的服务器地址。</p>
<h4 id="3）用户访问集群服务器的场景-二"><a href="#3）用户访问集群服务器的场景-二" class="headerlink" title="3）用户访问集群服务器的场景(二)"></a>3）用户访问集群服务器的场景(二)</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/54140669-file_1495331354090_1306.png" alt=""></p>
<p>在用户和网站服务器中间增加了负载均衡设备（纯硬件或者LVS等软件都可以）。DNS返回的永远是负载均衡的地址，而用户的访问都是通过负载均衡达到后面的网站服务器的。</p>
<h3 id="2-日志的处理"><a href="#2-日志的处理" class="headerlink" title="2. 日志的处理"></a>2. 日志的处理</h3><h4 id="1）单日志处理器"><a href="#1）单日志处理器" class="headerlink" title="1）单日志处理器"></a>1）单日志处理器</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/11945650-file_1495332619288_15a0c.png" alt=""></p>
<p>用一台日志处理器从3台服务器上收集日志并处理，随着应用服务器的增多，单台日志处理服务器一定会遇到问题，那么，我们可以通过增加日志处理服务器的数量来提升处理日志的能力。</p>
<h4 id="2-使用Master控制日志处理服务器集群"><a href="#2-使用Master控制日志处理服务器集群" class="headerlink" title="2) 使用Master控制日志处理服务器集群"></a>2) 使用Master控制日志处理服务器集群</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/641019-file_1495333108869_a18.png" alt=""></p>
<p>使用Master + Worker方式的控制器来处理日志</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>大型网站系统与Java中间件实践 by 曾宪杰</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-用户访问网站&quot;&gt;&lt;a href=&quot;#1-用户访问网站&quot; class=&quot;headerlink&quot; title=&quot;1. 用户访问网站&quot;&gt;&lt;/a&gt;1. 用户访问网站&lt;/h3&gt;&lt;h4 id=&quot;1）-用户访问单台服务器的场景&quot;&gt;&lt;a href=&quot;#1）-用户访问单台服务器
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>在工作的前三年里快速成长</title>
    <link href="http://jianwl.com/2017/05/17/%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%89%8D%E4%B8%89%E5%B9%B4%E9%87%8C%E5%BF%AB%E9%80%9F%E6%88%90%E9%95%BF/"/>
    <id>http://jianwl.com/2017/05/17/在工作的前三年里快速成长/</id>
    <published>2017-05-17T12:19:24.000Z</published>
    <updated>2017-05-17T15:02:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>有人可以靠中彩票，然后一夜暴富；有人随随便便发几张自拍，就一不小心一夜成名。可技术成长，要一步一个脚印地练习，才能掌握某项特定技术。等到我们掌握了学习的技巧，才能用更短的时间，来掌握某项特定的技术。</p>
<p>而练习也不是<strong>一天里写一万行代码</strong>，也不是<strong>重复写一百行代码</strong>，而是在<strong>一百天里，每天写下一百行代码。</strong>它需要一定的技巧，不懈的坚持，还有一些休息。因此在这篇文章里，我将分享几年里的练习技巧：</p>
<ul>
<li>基础篇：正确的练习姿势，从程序员的基本技能：盲打，到练习使用快捷键、重构技能等，再到如何使用新的框架练习。</li>
<li>进阶篇：如何通过练习提高。初学时，我们可以使用Vue、React去高仿一些项目；有经验以后，高仿应用只会让我们更累。我们便需要一些更高级的技巧，从引入别的框架思想，到造各式各样的轮子。</li>
<li>找到合适的时间练习，早上，慢慢进入状态；中午，适合做一些Review；碎片时间，可以做一些知识的管理等等。</li>
<li>怎样才能持之以恒下去，分享一些特定目标的技巧，及激励自己的方式。</li>
</ul>
<p>当然，练习有一个大前提是：<strong>我们有充足的时间。</strong>时间是一种很珍惜的资源，特别是对于长期加班的开发人员来说。因为<strong>技术能力不足导致的加班，</strong>会变成恶性循环。</p>
<p>如果你还没工作，那么便相当的幸运，你有相当多的时间。工作的时候，大家都忙于实现业务时候，没有时间让你提升自己，如果你已经工作了，那么你需要每天预留一些时间，才有机会联系。每天会占用一些游戏、看电视时间，哪怕只是半个小时、一周、一个月、一年下来，帮助就很大了。</p>
<p>进行这些练习之前，请不要忘了根本 – <strong>能熟练地用框架、语言完成工作。</strong>完成工作，相当于必须达到的60分及格要求，在胜任工作之外，提高能力到80、90分，追求更好的技术能力，才是正确的路线。</p>
<p>下面，让我们开始第一部分的内容吧。</p>
<h3 id="基础篇：正确的练习姿势"><a href="#基础篇：正确的练习姿势" class="headerlink" title="基础篇：正确的练习姿势"></a>基础篇：正确的练习姿势</h3><p>编程的时候，我们只是在码字 – 编程的过程(即思路)实际上是在脑子里完成的，娴熟的码字能力，可以帮助我们更好地编程。</p>
<p>小学时，自参加了五笔打字比赛后，便开启了我的编程生涯。可当工作的时候，已经可以熟练的完成工作的我，仍然无法打对每一个字符。有一天，看到了一个名为Typing的在线打字练习工具，练习了一次之后，发现它会给出一些建议，便开始进行了一些编码练习。但是得到的反馈能表名，在打字这方面，仍然有一些提升的空间：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-17/57142401-file_1495025245549_10d78.png" alt=""></p>
<p>我的“自我解释”是：<strong>今天的编程语言设计得不合理</strong> – 使用了各种字符，导致了右手在这方面的负担比较大。在那之后，我便陆续进行了一些基础的练习，并整理他们的因果关系，便有了下面的一些练习项目：</p>
<ul>
<li>作为经常用电脑的人，应当掌握好打字的基本技巧，比如说采用正确的打字姿势，以及盲打技能。</li>
<li>作为一个程序员，应当精通使用手上各式IDE，编辑器，熟练使用它们的快捷键</li>
<li>作为一个专业的程序员，我们还要将重构代码，命名等高级的技巧掌握好。</li>
</ul>
<p>这些练习，可以让我们成长为一个更专业的程序员。</p>
<h4 id="语言与框架的练习"><a href="#语言与框架的练习" class="headerlink" title="语言与框架的练习"></a>语言与框架的练习</h4><p>对于语言与框架的练习，算是比较简单的，于我而言，这种练习过程便是：</p>
<ol>
<li>买本相关书籍，或者寻找份教程、官方指南。</li>
<li>再找个合适的Demo，熟悉基础概念，并掌握好相关基础。</li>
<li>在Demo的基础上，实现一些业务功能，了解各种功能、特性。</li>
<li>查看官方文档，查有没有漏掉了什么重要的东西。</li>
<li>写博客、日志来记录这个过程。</li>
</ol>
<p>因此，只需要找一个合适的网站、APP作为模仿的对象，一步步往下练习即可。唯一的难点在于，第一次写Web应用的时候，可能会花费更多的时间，新手期的程序员，对很多的概念都不清楚，如若能找到一个新手社区、群体，提高起来就会方便多了。</p>
<p>熟练使用语言或者框架，不能帮助我们成为一个「优秀」的成员。只能带领我们成为一个“胜任”的程序员，即我们可以凭借着这种练习，找到一份养家糊口的工作。</p>
<h4 id="模仿开源软件"><a href="#模仿开源软件" class="headerlink" title="模仿开源软件"></a>模仿开源软件</h4><p>工作的时候，写的都是业务代码，纯技术的实践并不多，这意味着，<strong>多年的工作经验，与技术能力的关系并无太大关联</strong>。如果有一天，我们看到几年前写的代码和今天写的代码并没有太大的区别，那么说明了：我们已经陷入了这样的一个瓶颈。</p>
<p>在学校写的代码，与工作写的代码，最大的区别在于：<strong>软件工程实践</strong>。单单凭借工作经验，那么在软件工程实践的提高可能不会太大。受限于上线deadline的影响，多数项目的软件工程实践，并不能做到最好，甚至可能很差劲。如我们所见，国内的大部分公司(包括BAT)在这方面的实践也很难做全。这些实践包括：</p>
<ul>
<li>使用版本管理，诸如Github上的项目采用的Git，基本已经普及；</li>
<li>使用持续集成，它可以为团队协作，提供一个可靠的帮助。</li>
<li>完整的测试用例，编写单元测试、功能测试等待</li>
<li>代码检视，用于提高整个项目的质量</li>
</ul>
<p>而对于一个优秀的开源软件来说，为了保证好项目的质量，拥有者往往付出了很多的精力，在提高软件工程的实践上，因此，对于软件工程来说，最好的练习，便是模仿开源软件，并自己去创造一些轮子。以React为例，其在首页拥有下面的几个徽章(bage):</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-17/36438562-file_1495026815302_19d9.png" alt=""></p>
<p>分别是：</p>
<ol>
<li>Circle CI,即持续集成、诸如测试是否都通过、部署是否成功等。</li>
<li>Travis CI，同上。</li>
<li>Coverage，代码的测试覆盖率，81%</li>
<li>npm, 当前版本号</li>
<li>PRs welcome,即欢迎来Pull Request</li>
</ol>
<p>那么，我们在实践的时候，就可以模仿这样的项目组成，一步步往下实践：</p>
<ol>
<li>为项目添加测试框架、如Java里的Junit，Node.js里的Mocha等</li>
<li>添加自动化测试脚本，如Java里的Gradle，Node.js里的Grunt、Gulp、NPM等</li>
<li>添加测试覆盖率工具</li>
<li>添加持续集成，如Travi CI或者Circle CI</li>
<li>添加代码质量分析工具，如Code Climate</li>
<li>指定目标，并完成。</li>
</ol>
<p>最难的实际上是最后一步，指定一个目标并实现。它可以是测试覆盖率要达到90%以上，这就需要一步步来完成，如先将目标放到60%，再慢慢地网上提升，知道90%，甚至100%，在这个过程中，会不断地原道一些挑战，如<strong>难以测试的代码，为了编写测试而修改功能代码等。</strong>但是，它能确确实实地帮助我们提高工程能力。</p>
<h4 id="基础练习：从码字到盲打"><a href="#基础练习：从码字到盲打" class="headerlink" title="基础练习：从码字到盲打"></a>基础练习：从码字到盲打</h4><p>编码的时候，如果我们心里想输入的是一个print，结果打下的字符是oront，那么我们就需要删了重来，又或者是小心翼翼地，边看键盘边输入一个个字符。虽说，编码只是一个打字的过程，但是很多时候，经常出现的错字会中断我们的思路。因此，盲打应该成为程序员的基本技能，而这里的盲打，指的并不是我们可以闭上眼睛打字聊天，而是可以完成编码工作，即能盲打下26个字母，以及各种字符，还有各种功能键。</p>
<p>而在进行这一类练习的时候，<strong>我们经常会遇到一个障碍：度量</strong>。即以某种方式来衡量练习的成果，我们做了很多的练习来提高自己，但是没有数据来支撑。它不像编码，我们写了几行代码，完成了一个功能，那么写下的这些代码的价值就是可以衡量的。因而练习的时候，我们可以寻找一些适合的工具，如Typing.io，Keybr.com这一类工具，如果Typing使用的是真实的代码片段，它能帮我们发现真实场景下：我们容易打错哪些字，容易按错哪些键，我们打字的速度是多少等等的内容。</p>
<p>对于<strong>可以衡量</strong>的打字速度，我们可以定下每天十几分钟的时间，一段时间要提升到什么水平的目标，这样它变能满足<strong>SMART原则</strong>，就能让我们看到我们在这段时间内的提升。</p>
<p>当时，我拿Typing练习的时候，差不多练习了一个月，每天大概半小时左右，因为打字速度比较快，所以容易出错，所以便将注意力放在减少错误上，而对于有些人来说，则是相反的，即打字速度比较慢，但是准确率比较高，而这个练习的主要目的是，能够熟练地做到盲打，不让它影响我们的效率。</p>
<p>掌握了熟练开关机、键盘上的各种按键后，我们就在使用工具上做一个效率的提升。</p>
<h4 id="基础练习：掌握开发工具"><a href="#基础练习：掌握开发工具" class="headerlink" title="基础练习：掌握开发工具"></a>基础练习：掌握开发工具</h4><p>刚工作的时候，发现每个有经验的程序员，几乎可以不用鼠标编程。熟练的使用各种快捷键，进行代码重构、打开新页面、开启新窗口等操作。慢慢的，我觉得自己再这方面上有相当大的提升空间。</p>
<p>这意味着，我要学习、探索开发工具的功能，也要能使用快捷键来控制。尽管在日常结对编程、代码检视、交流的时候，可以请从别人身上学习，但是理想的方式，还是自己去练习。</p>
<p>对于大部分的开发工具，他们都有对应的手册，Keymap或者cheatsheet,即”作弊表”。</p>
<p>需要注意的是：对于开发工具而言，没有必要掌握所有的快捷键，而是只掌握常用的功能，我曾陷入了一个误区，练习使用快捷键的时候，边练习一些重构的技巧，同时也花费时间在联系一些「屠龙之术」上 – 一些非常少用的功能，除了炫耀，也没有什么用，时间一久，我便忘了很多的快捷键。再举些例子：如Vim、对我而言，一般用于服务器维护及Git修改。因此，主要使用的功能辨识：快速地改几个字符，更新配置，保存并退出。如Chrome浏览器，在日常使用时，配合下Vim插件，便不需要鼠标，在进行前端开发的时候，便需要使用鼠标来调试。</p>
<p>对于大部分的工具来说，我们只需要一个CheatSheet，复杂的工具，如Vim,Emacs，则需要一本更专业的数。他们是高度可定制的，这也意味着我们需要一步步的定制这些工具，寻找合适的插件，自定义快捷键，又或者是使用别人的配置。而要衡量快捷键使用方面的提升，目前还没有看到有效的度量工具。如果有的话，那么就是编码的时候，使用鼠标的频率，因此，在某些特定的时候，可以通过禁用鼠标来提升自己在这方面的能力。</p>
<h3 id="进阶篇：如何通过练习来提高"><a href="#进阶篇：如何通过练习来提高" class="headerlink" title="进阶篇：如何通过练习来提高"></a>进阶篇：如何通过练习来提高</h3><p>尽管我在上面指出，学习新框架的最好姿势是：基于现有的业务来学习，即从工作中学习，从做中学。但是，如果一直<strong>只使用</strong>新的框架来重写旧的业务，那么你的成长就会趋于0.第一次，使用新框架时收获可能颇丰；第二次，收获的东西就更少了；第三次，你可能就学不到东西。</p>
<p>因此，在业余的练习时间里，不要一直练习新的框架，不要再拿Vue、ReactNative去高仿一些应用。<strong>当且仅当，你所处的项目正在使用新的框架，</strong>这种练习才是有意义的。</p>
<p>经过上面的练习，我们提高了我们的工作效率。同时，在别人的眼里，我们更像是一个专业的程序员，在这之上，我们还需要提高顶层的能力。下面介绍的是，我尝试过的一些，比较有效果的提升方法：</p>
<ul>
<li>阅读开源软件与重构代码</li>
<li>造自己的轮子来重写应用</li>
<li>结合设计模式</li>
<li>引入其他领域的思想</li>
</ul>
<p>总的来说，收获还是蛮多的，特别是造轮子，能有更大的提升。与其他的练习稍有不同的是，因为设计到代码设计，这里的练习有些难以衡量。这时候，我们应该是保持着<strong>练习的心态</strong>，并意识到我们是做这方面的练习。</p>
<h4 id="阅读开源软件与重构代码"><a href="#阅读开源软件与重构代码" class="headerlink" title="阅读开源软件与重构代码"></a>阅读开源软件与重构代码</h4><p>如果在工作环境中，没有代码写的比较好的人，那么我们就只能从开源代码中去学习。笔者之前写过一篇「如何以“正确的姿势”阅读开源软件代码」的文章，文中我建议的阅读开源软件代码的方式是：</p>
<ul>
<li>clone某个项目的代码到本地</li>
<li>查看这个项目的release列表</li>
<li>找到一个看得懂的release版本，如1.0或者更早的版本。</li>
<li>读懂上一个版本的代码</li>
<li>向后阅读大版本的源码</li>
<li>读最新的源码</li>
</ul>
<p>可只读这些代码，不能让我们显著的提高水平，我们应该结合「重构」这个技能来练习。从我的练习经验来看，<strong>对于重构的练习是最有意思的</strong>我们可以见证，一段不好的代码在我们的调教之下，焕发出新的光彩。当我们重构一段坏味道的代码，对比重构前后的代码，便会发现自己竟然有这样的神奇的能力。</p>
<p>如果找不到合适的练习项目，可以到Github上找一些star多，但是没有测试，缺少CI等的项目练习，这样的项目在Github上也是蛮多的。</p>
<p>有一次，我在寻找一个迷你的Markdown解析器，看到Github上有一个精巧的实现。它有100+的star，但是没有测试，四百行的代码里，有一个方法有三百多行等等的坏味道。于是，便花了几天的时间，边思考便重构这个项目，这样对编码的提升比较大，因为工作的时候，完成任务是第一优先级，然后才是质量。因此，对于我们联系来说，我们只需要：</p>
<ul>
<li>找到一个不错的开源库</li>
<li>阅读其中的代码</li>
<li>找到代码中设计不好的地方</li>
<li>对<strong>自己认为设计</strong>得不好的代码重构</li>
<li>结合「重构」一书，来改进设计。</li>
</ul>
<p>要注意的是：不同的人对于代码设计，有着不同的关店，因此，在这时如果只是因为代码的设计不好，而不是代码里有各种坏味道(code smell)，那么，就不应该去给别人的代码提Pull Request。</p>
<h4 id="造自己的轮子来重写应用"><a href="#造自己的轮子来重写应用" class="headerlink" title="造自己的轮子来重写应用"></a>造自己的轮子来重写应用</h4><p>与阅读代码、重构相比，造一个自己轮子，来实现同样的功能，便是一个更不错的选择。在Web开发领域，大部分的开发框架本身都是「通用型」的框架。即它拥有相当多的功能，其中有很多的功能都不会用到。如你使用JQuery的时候，你可能只会使用到其中的Ajax、Event功能，那么你就可以写一个新的框架，兼容这两个接口。</p>
<p>练习时间充裕的时候，便可以自己动手去做一个。上面说到的阅读框架代码，是一种好的方法。除此无论是前端还是后端，我们都可以找到从零创建框架的资料，来帮助我们理解框架的组成。</p>
<p>通过阅读诸如Python里的Flask、Ruby里的Sinatra等轻量级的框架，我们就能理解一个框架所需要的元素，并模仿他们做出一个新的系统。这些框架的关注点是：处理HTTP请求的CGI、与数据库的交互的ORM、控制逻辑的Controller层，返回HTML的View层等等，除了相关的框架，我们还能再Github上看到很多人模仿这些框架。做一个这样的后台框架，搭建自己的博客，那就能理解好这一些列的逻辑了。</p>
<p>对于前端来说，也是类似，诸如Building React From Scratch,可以让我们在250行理解React的原理，并做出一个类似的框架，除了MVC，还有模块化设计、数据请求等等的内容。在两三年前，「JavaScript框架设计」就是这方面一个不错的选择。</p>
<p>我曾经造过一个名为 Lettuce 的前端框架，它的主要目的就是用于：学习前端框架的设计，便在自己的多个业余项目上使用这个框架。而在前端领域，定制自己的 UI 框架、CSS 框架也是一个很不错的选择。再用到自己的博客上，再写上「自豪地采用xx框架」，岂不是更加的自豪？</p>
<p>在底层领域，又有各式各样的《自制操作系统》、《自制编程语言》、《自己动手设计物联网》等等的书籍，它们都能让我们从底层理解一个系统的组成。除此，还有各种各样的剖析类书籍，可以让我们理解底层机制的同时，也能让我们制作出一个框架。最后，我们只需要能不改写或少数改写代码，将我们的应用运行在上面，便是成功的一个仿造的轮子了。</p>
<h4 id="结合设计模式"><a href="#结合设计模式" class="headerlink" title="结合设计模式"></a>结合设计模式</h4><p>设计模式，不同的人有不同的看法。在我看来，一个优秀的程序是要能「看懂」的。即不一定要精通，但要能识别出来，它是一种设计模式。当我们看到了一次又一次的相似设计时，应该猜想到，其背后应该是一种设计模式。如在前端开发框架中的「双向绑定」，它实际上就是发布-订阅模式，又或者称观察者模式的一种实现。</p>
<p>在笔者看来，模式就是一种高级的语言。当别人一说「工厂模式」，多数人瞬间就明白了，不犹得会发出：原来如此，这一类的感叹。认识了一些模式后，一遇到一些特定的场景，我们就能一下子套用这种模式。</p>
<p>可只凭借Gof的「设计模式」一书，又或者「Head First设计模式」、「重构与模式」等设计模式书籍，我们所学的知识便是有限的。我们要做的是：</p>
<ul>
<li>先熟悉书本上的示例代码，来对不同的设计模式有一个大的了解。</li>
<li>识别日常代码中的设计模式</li>
<li>练习这些设计模式，并掌握常见的设计模式</li>
<li>尝试在日常的代码中，套用设计模式。</li>
<li>重构现有的代码到设计模式</li>
</ul>
<p>要对设计模式进行练习，不是一件容易的事情，并且很多时候，容易模棱两可，即适合使用A模式，又适合使用B模式，这是因为我们是在为设计而设计，因此会尽可能的贴近现有情况。</p>
<h4 id="引入其他领域的思想"><a href="#引入其他领域的思想" class="headerlink" title="引入其他领域的思想"></a>引入其他领域的思想</h4><p>不同的领域里，都有自己领域的优秀思想。如我们熟知的设计模式，便是受建筑领域的「建筑的永恒之道」中描述的 253个 建筑模式的启发。又如今天流行的精益思想，最早是来自汽车制造业，可它对软件行来说，有着令人受益匪浅的启发。好的框架、软件是会相互学习，如 iPhone 与 Android，都在不断地借鉴——通知中心，但是又在那之上做一些改进。</p>
<p>又比如，今天的前端框架里，很多思想都是从后端“借鉴”过来的。如 Angular 中采用的依赖注入，便是深受 Java 语言的影响。近一点来说，Redux，框架最初是用在 React 上，但是它已经被推广到了 React 和 Vue.js 上。</p>
<p>因此，当我们发现一个新的优秀思想产生时，便可以尝试引入到自己的领域里。又或者我们所处的领域，正遇到一些难题，答案可能就在别的领域里。可在这方面的练习，往往都是一些创新性的练习。多数时候，我们的探索可能没有结果，但是它往往能对自己有更大的启发。</p>
<h4 id="找到合适的时间练习"><a href="#找到合适的时间练习" class="headerlink" title="找到合适的时间练习"></a>找到合适的时间练习</h4><p>每天能有半小时、一小时甚至更长时间的稳定练习，比三天打鱼两天晒网的效果要好得多。清理出一些固定的时间，用于为自己腾出时间来提高自己。既然，你都有时间到这篇文章，那么你应该属于能腾出时间的人。</p>
<p>如果不能的话，那么我们也可以尝试去挤出一些时间，如从上下班去寻找空间。即使是同一公司，不同的人都有不同的上下班时间，所花费在路上的时间也有所不同。有的人，需要在几环外坐个一个多小时的地铁，再转公交才能到公司；有的人，只需要出门左转，走个十分钟就到公司了。因为在路上花费的时间不同，也在一定程度上影响了学习、练习等等的时间。</p>
<p>因此，如果可能的话，应该减少花费在上班路上的时间，才能避免继续陷入这样一个恶性循环：<strong>租不起近的房子，花费大量的时间在路上，没有时间提升技能</strong>。</p>
<p>早上</p>
<p>早上的练习，是一种慢慢进入一天工作状态的感觉。一旦上班时间到来的时候，就已经进入工作姿态了——对于“资本家”来说，可谓好事一件。早晨刚醒来，总会想不起昨天项目做到哪一步，便更容易反思哪里做得有问题。</p>
<p>如笔者已经习惯了，每天七点起床、洗漱，随后写会代码，再去上班。有时候，可以有一个半小时的练习时间，有时候会有半个小时，将这些时间浪费在梦里总是有些可惜。同时，之前为了能成功地上公交，便提前半个小时到公司，写一些开源软件的代码。毕竟，作为一家非产品公司，你无法和别人解释说，我们做了些什么、取得了哪些成就。</p>
<p>在很多地方，这是一个很好的策略：<strong>错开高峰期上下班，路上就不容易堵车</strong>。所花在路上的时间就缩短了，那么我们就有时间来练习了。</p>
<p>需要注意的是：<strong>练习的时候不要关注时间，而是关注怎么于提高</strong>。关键点在于：让每天进步一点。</p>
<p>中午</p>
<p>吃完饭后，因为米饭血糖指数高的缘故，容易犯困。对于北方的同学来说，因为主食不是米饭，所以这就不算是一个问题了。这个时候，身体会妨碍我们进行一些练习。可如果你的午休时间比较长，那么也可以做一些练习，再去休息片刻。</p>
<p>碎片时间</p>
<p>对着屏幕写代码，时间一久，集中力就会开始涣散，便应该休息会儿。刷刷资讯、朋友圈，又或者收集各种资料，开放我们的视野。接收各种新的知识，来扩大自己的视野，以便于自己了解整个市场的水平。</p>
<p>常见的方式有：</p>
<ul>
<li>阅读个人博客、微信公众号</li>
<li>维护自己的Awesome列表 – 寻找自己觉得好的开源项目</li>
<li>IT新闻、技术文章聚合网站 – 我很不喜欢聚合网站，不部分的聚合站点的行为无异于文章抄袭。</li>
<li>Github Trending</li>
</ul>
<p>将这些内容存储到 Evernote、WunderList、OneNote 等各式各样的云笔记里，然后定期清理、定期清理、定期清理。收集只是一种方式——没有啥用的方式，因此建议先读完一遍，再去收藏这样的文章。多数时候，我们会发现自己收藏了很多的内容、买了很多的书，但是却没有时间去读。</p>
<p>晚上</p>
<p>经历了漫长的加班，回到住的地方，可能就会想休息了。如果白天没时间练习，晚上也不能抽出时间练习，长期以往，一年的工作经验就要变成五年来用了。</p>
<p>晚上练习的同时，我们应该注意：在睡觉前 30~60 分钟停止编码，否则上床的时候，脑子里可能还是这些代码，就容易失眠。万一灵感一来，那就还要爬起来继续写。这个时候，可以阅读一些相关或者无关的书籍、资料。在阅读的过程中，尽管我们已经不在思考内容。但是潜意识里还在思考中，这时就能很容易就会遇到一些灵感。</p>
<p>最后，休息的时候，尽情睡觉吧~。</p>
<h3 id="怎样才能持之以恒下去"><a href="#怎样才能持之以恒下去" class="headerlink" title="怎样才能持之以恒下去"></a>怎样才能持之以恒下去</h3><p>在上文里，我们只谈论一些方法和技巧，可是它们并没有什么用。每个人都知道所谓的「一万小时理论」，但是真正要坚持下来，并没有我们想象中的那么容易。</p>
<p>我们需要从娱乐时间里抽到一部分，原本舒适的玩游戏、睡觉、刷微博时间，现在要成为另外一种「痛苦」？可是，既然这些“无聊的事情”我们都能上瘾，那么我们是不是没有找到合适的路？</p>
<h4 id="设定目标与-SMART-原则"><a href="#设定目标与-SMART-原则" class="headerlink" title="设定目标与 SMART 原则"></a>设定目标与 SMART 原则</h4><p>按上文中的分法，练习可以分为：<strong>日常固定时间的练习</strong>，及针对某一特定主题的练习等多种类型。当我们开始练习某一个具体的技术、框架、模式时，最好能制定一个简单的练习计划，如每几天练习某一内容、多少天内用某一个框架实现什么功能。</p>
<p>先设计<strong>一个小的目标，并且能在短期实现</strong>。当发现自己可以轻松地坚持下来时，再慢慢的扩大目标，直至我们能做得更好。可是，设定一个练习目标也不是一件简单的事，它也有很多考量的地方。</p>
<p>毕业的时候，在公司接受了针对于毕业生的培训，期间学习到了一个用于制定任务、目标的 SMART 原则：</p>
<ul>
<li>具体的（Specific）。即我们要有一个明确的目标，如在一周内用 Django 写一个博客系统，而不是用 Django 写个东西。</li>
<li>可度量的（Measurable）。即衡量是否达成目标，我们只需要能创建、查看、删除博客，那么我们就算完成了这样的任务。它可以用来不断地突破自己。</li>
<li>可实现性（Attainable）。即这个目标一定是可以实现的，不能实现的目标没有啥意义。与些同时，练习初期定下的目标不能困难。</li>
<li>相关性（Relevant）。即目标与其他目标的关联情况，如我们练习 Django 是为了提高 Django 或者后台的技能。如果我们的大目标是提高前端技能，那么这个目标对于当前的意义并不是太大。</li>
<li>时限（Time-based）。即时间限制，如上面提到的一周内用 Django 写一个博客系统的期限。</li>
</ul>
<p>经常能在微信朋友圈看到，朋友的 100 天英语阅读计划，这样的目标就是合理的——可实现的、具体的、有时间限制、可度量的。</p>
<p>如果我们想每天固定时间进行练习，那么我们应该做一个短暂的尝试，如七天，再慢慢的不断扩大时间目标，二十一天、两个月，随后再扩大到一个更大的目标。</p>
<h4 id="坚持与激励自己"><a href="#坚持与激励自己" class="headerlink" title="坚持与激励自己"></a>坚持与激励自己</h4><p>我们可以使用 GitHub 上的 Contributions 来激励自己，每一天的痕迹都很明显，甚至于可以拉拢一些小伙伴，与我们一起参加类似的活动。GitHub 本身具有社交属性，可以让我们看到别人做了什么，做了多久。</p>
<p>由于 GitHub 的服务器在国外，访问的时候可能会受限于网络。国内的开源中国的码云和Coding 也有类似的活跃度，建议访问 GitHub 有问题的读者，可以使用这些服务。</p>
<p>上文中提到的朋友圈 100 天英语阅读计划，也是相似的，它可以让别人监督你是否完成<br>——前提是，有人一起和你做相同的事，<strong>因此可以找个人和你一起练习，相互监督。</strong></p>
<p>刚开始练习的时候，练习的内容基本上很充实。时间一长，可能就会陷入一些瓶颈：要么找不到合适的练习内容，要么觉得练习过于乏味。因此这个时候，可以切换不同类型的练习项目——如，做一些自己觉得有意思的小项目练习。又或者，当我们完成一个目标时，给自己一些奖励，以此来鼓舞自己。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>练习完之后，还有一种很好的提高方式，就是输出、总结。整理自己练习过程中学到的知识，将之与我们需要的技能做对比，我们就会发现：在哪些地方还需要提高。我们就能制作出下一次练习的目标，不断地反复，以些来提高自己。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-17/40653819-file_1495033238660_44f8.png" alt=""></p>
<p>经常做总结，除了看到自己提高的地方，还能让阅读文章的人，鼓励你更好的前进。那么，现在让我们创建一个项目，更新一次 README，开始练习吧！</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>在工作的前三年里快速成长 by Phodal</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有人可以靠中彩票，然后一夜暴富；有人随随便便发几张自拍，就一不小心一夜成名。可技术成长，要一步一个脚印地练习，才能掌握某项特定技术。等到我们掌握了学习的技巧，才能用更短的时间，来掌握某项特定的技术。&lt;/p&gt;
&lt;p&gt;而练习也不是&lt;strong&gt;一天里写一万行代码&lt;/stron
    
    </summary>
    
      <category term="思绪" scheme="http://jianwl.com/categories/%E6%80%9D%E7%BB%AA/"/>
    
    
      <category term="思绪" scheme="http://jianwl.com/tags/%E6%80%9D%E7%BB%AA/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记(二)</title>
    <link href="http://jianwl.com/2017/05/14/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <id>http://jianwl.com/2017/05/14/Linux学习笔记-二/</id>
    <published>2017-05-14T07:15:23.000Z</published>
    <updated>2017-05-14T08:22:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="1-查询已启动的网络监听服务"><a href="#1-查询已启动的网络监听服务" class="headerlink" title="1. 查询已启动的网络监听服务"></a>1. 查询已启动的网络监听服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">netstat 参数解释：</div><div class="line"></div><div class="line">-t tcp协议</div><div class="line">-u udp协议</div><div class="line">-n numeric</div><div class="line">-l listen状态</div><div class="line">-p program</div></pre></td></tr></table></figure>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-14/26146003-file_1494746273274_17eb1.png" alt=""></p>
<h4 id="2-查询系统中是否安装了某软件"><a href="#2-查询系统中是否安装了某软件" class="headerlink" title="2. 查询系统中是否安装了某软件"></a>2. 查询系统中是否安装了某软件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rpm 参数详解：</div><div class="line"></div><div class="line">-q query 查询操作</div><div class="line">-a all 所有软件</div></pre></td></tr></table></figure>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-14/81383025-file_1494746859638_3b28.png" alt=""></p>
<h4 id="3-host检测主机名与IP的对应关系"><a href="#3-host检测主机名与IP的对应关系" class="headerlink" title="3. host检测主机名与IP的对应关系"></a>3. host检测主机名与IP的对应关系</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-14/15833663-file_1494748081467_e93c.png" alt=""></p>
<h4 id="4-telnet远程连接检测端口是否启动"><a href="#4-telnet远程连接检测端口是否启动" class="headerlink" title="4. telnet远程连接检测端口是否启动"></a>4. telnet远程连接检测端口是否启动</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-14/35985253-file_1494748318696_110f5.png" alt=""></p>
<h4 id="5-wget网页数据的获取"><a href="#5-wget网页数据的获取" class="headerlink" title="5. wget网页数据的获取"></a>5. wget网页数据的获取</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-14/75884486-file_1494748586137_7e4b.png" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>鸟哥的Linux私房菜 - 服务器架设篇</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实战&quot;&gt;&lt;a href=&quot;#实战&quot; class=&quot;headerlink&quot; title=&quot;实战&quot;&gt;&lt;/a&gt;实战&lt;/h3&gt;&lt;h4 id=&quot;1-查询已启动的网络监听服务&quot;&gt;&lt;a href=&quot;#1-查询已启动的网络监听服务&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="Linux" scheme="http://jianwl.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://jianwl.com/tags/Linux/"/>
    
  </entry>
  
</feed>
