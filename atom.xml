<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录点滴成长</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianwl.com/"/>
  <updated>2018-09-02T03:41:42.963Z</updated>
  <id>http://jianwl.com/</id>
  
  <author>
    <name>流云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Astah之时序图教程</title>
    <link href="http://jianwl.com/2018/09/02/Astah%E4%B9%8B%E6%97%B6%E5%BA%8F%E5%9B%BE%E6%95%99%E7%A8%8B/"/>
    <id>http://jianwl.com/2018/09/02/Astah之时序图教程/</id>
    <published>2018-09-02T03:38:31.000Z</published>
    <updated>2018-09-02T03:41:42.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://astah.net/manual/434-sequence-diagram" target="_blank" rel="noopener">时序图 - Astah官方教程</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://astah.net/manual/434-sequence-diagram&quot; t
      
    
    </summary>
    
      <category term="UML" scheme="http://jianwl.com/categories/UML/"/>
    
    
      <category term="UML" scheme="http://jianwl.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>声明不可变类的策略</title>
    <link href="http://jianwl.com/2018/09/01/%E5%A3%B0%E6%98%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E7%9A%84%E7%AD%96%E7%95%A5/"/>
    <id>http://jianwl.com/2018/09/01/声明不可变类的策略/</id>
    <published>2018-09-01T10:08:48.000Z</published>
    <updated>2018-09-01T10:28:28.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不可变类定义"><a href="#不可变类定义" class="headerlink" title="不可变类定义"></a>不可变类定义</h3><ol><li>方法所有属性均不提供setter方法</li><li>所有属性均为final、private</li><li>不允许子类重构方法，最简单的方式，就是在类上加上final关键字，这样类不可继承，即所有方法均不会被重构；</li><li>如果属性为可变类的引用，则 ① 不提供改变可变类的方法 ② 不要共享对可变对象的引用。 永远不要存储对传递给构造函数的外部可变对象的引用; 如有必要，创建副本并存储对副本的引用。 同样，必要时创建内部可变对象的副本，以避免在方法中返回原始对象。</li></ol><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><h4 id="1-不可变类-包含可变引用属性"><a href="#1-不可变类-包含可变引用属性" class="headerlink" title="1. 不可变类(包含可变引用属性)"></a>1. 不可变类(包含可变引用属性)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class Employee&#123;</span><br><span class="line">    private final int id;</span><br><span class="line">    private final Address address;</span><br><span class="line">    public Employee(int id, Address address)</span><br><span class="line">    &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.address=new Address();  // defensive copy</span><br><span class="line">        this.address.setStreet(address.getStreet());</span><br><span class="line">    &#125;</span><br><span class="line">    pulbic int getId()&#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public Address getAddress() &#123;</span><br><span class="line">        Address nuAdd = new Address(); // must copy here too</span><br><span class="line">        nuAdd.setStreet(address.getStreet());</span><br><span class="line">        return nuAdd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-可变类"><a href="#2-可变类" class="headerlink" title="2. 可变类"></a>2. 可变类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Address&#123;</span><br><span class="line">    private String street;</span><br><span class="line">    public String getStreet()&#123;</span><br><span class="line">        return street;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setStreet(String street)&#123;</span><br><span class="line">        this.street = street;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/imstrat.html" target="_blank" rel="noopener">不可变类策略 - 官方链接</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;不可变类定义&quot;&gt;&lt;a href=&quot;#不可变类定义&quot; class=&quot;headerlink&quot; title=&quot;不可变类定义&quot;&gt;&lt;/a&gt;不可变类定义&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;方法所有属性均不提供setter方法&lt;/li&gt;
&lt;li&gt;所有属性均为final、private&lt;
      
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>spring bean加载</title>
    <link href="http://jianwl.com/2018/08/28/spring-bean%E5%8A%A0%E8%BD%BD/"/>
    <id>http://jianwl.com/2018/08/28/spring-bean加载/</id>
    <published>2018-08-28T13:09:16.000Z</published>
    <updated>2018-08-28T13:39:48.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Bean获取时序图"><a href="#1-Bean获取时序图" class="headerlink" title="1. Bean获取时序图"></a>1. Bean获取时序图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-28/85819316.jpg" alt=""></p><h5 id="1-尝试从缓存中加载单例-P-1-1"><a href="#1-尝试从缓存中加载单例-P-1-1" class="headerlink" title="1. 尝试从缓存中加载单例(P.1.1)"></a>1. 尝试从缓存中加载单例(P.1.1)</h5><p>单例在Spring的同一个容器内只会被创建一次，后续再获取bean，就直接从单例缓存中获取了。当然这里也只是尝试加载，首先尝试从缓存中加载，如果加载不成功则再次尝试从singletonFactories中加载。因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖，在spring中创建bean的原则是不等bean创建完成就会将创建bean的ObjectFactory提早曝光加入到缓存中，一旦下一个bean创建时候需要依赖上一个bean则直接使用ObjectFactory。</p><h5 id="2-bean的实例化-P-1-2"><a href="#2-bean的实例化-P-1-2" class="headerlink" title="2. bean的实例化(P.1.2)"></a>2. bean的实例化(P.1.2)</h5><p>如果从缓存中得到了bean的原始状态，则需要对bean进行实例化，这里有必要强调下，缓存中记录的只是原始的bean状态，并不一定是我们最终想要的bean。举个例子，假如我们需要对工厂bean进行处理，那么这里得到的其实是工厂bean的初始状态，但是我们真正需要的是工厂中定义的factory-method方法中返回的bean，而getObjectForBeanInstance就是完成这个工作的。</p><h5 id="3-原型模式的依赖检查"><a href="#3-原型模式的依赖检查" class="headerlink" title="3. 原型模式的依赖检查"></a>3. 原型模式的依赖检查</h5><p>只有在单例情况下才会尝试解决循环依赖，如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，就会产生当A还未创建完的时候，因为对B的依赖的创建再次返回创建A，造成循环依赖，也就是情况：isPrototypeCurrentlyInCreation(beanName)判断为true。</p><h5 id="4-检测parentBeanFactory-P-3"><a href="#4-检测parentBeanFactory-P-3" class="headerlink" title="4. 检测parentBeanFactory(P.3)"></a>4. 检测parentBeanFactory(P.3)</h5><p>从代码上看，如果缓存没有数据的话直接转到工厂上去加载了，这是为什么呢？可能读者忽略了一个很重要的判断条件：!constainsBeanDefinition(beanName),当前加载的XML配置文件中不包含beanName所对应的配置，就只能到parentBeanFactory去尝试下了，然后再去递归的调用getBean方法。</p><h5 id="5-将存储XML配置文件的GenericBeanDefinition转换为RootBeanDefinition。-P-4"><a href="#5-将存储XML配置文件的GenericBeanDefinition转换为RootBeanDefinition。-P-4" class="headerlink" title="5. 将存储XML配置文件的GenericBeanDefinition转换为RootBeanDefinition。(P.4)"></a>5. 将存储XML配置文件的GenericBeanDefinition转换为RootBeanDefinition。(P.4)</h5><p>因为XML配置文件中读取到的Bean信息是存储在GenericBeanDefinition中的，但是所有Bean后续处理都是针对RootBeanDefinition的，所以这里需要进行一个转换，转换的同时，如果父类bean不为空的话，则会合并父类的属性。</p><h5 id="6-寻找依赖"><a href="#6-寻找依赖" class="headerlink" title="6. 寻找依赖"></a>6. 寻找依赖</h5><p>因为bean的初始化过程很可能会用到某些属性，而某些属性很可能是动态配置的，并且配置成依赖于其他的bean，那么这个时候就有必要先加载依赖的bean，所以在spring的加载顺序中，在初始化某一个bean的时候，首先会初始化这个bean所对应的依赖</p><h5 id="7-针对不同的scope进行bean的创建-P-6"><a href="#7-针对不同的scope进行bean的创建-P-6" class="headerlink" title="7. 针对不同的scope进行bean的创建(P.6)"></a>7. 针对不同的scope进行bean的创建(P.6)</h5><p>在Spring中存在不同的scope，其中默认的是singleton,但是还有些其他的配置诸如prototype、request之类的，在这个步骤中，Spring会根据不同的配置进行不同的初始化策略。</p><h5 id="8-类型转换-P-7"><a href="#8-类型转换-P-7" class="headerlink" title="8. 类型转换(P.7)"></a>8. 类型转换(P.7)</h5><p>程序到这里返回bean已经基本结束，通常对方法调用参数requiredType是为空的，但是可能存在这种情况，返回的bean其实是个String,但是requiredType却传入Integer类型，那么这个时候，这个步骤就会起作用，它的功能是将返回的bean转换为requiredType所指定的类型。在Spring中提供了各种各样的转换器，用户也可以自己扩展转换器来满足需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Bean获取时序图&quot;&gt;&lt;a href=&quot;#1-Bean获取时序图&quot; class=&quot;headerlink&quot; title=&quot;1. Bean获取时序图&quot;&gt;&lt;/a&gt;1. Bean获取时序图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.c
      
    
    </summary>
    
      <category term="Spring" scheme="http://jianwl.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://jianwl.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>spring bean scope</title>
    <link href="http://jianwl.com/2018/08/25/spring-bean-scope/"/>
    <id>http://jianwl.com/2018/08/25/spring-bean-scope/</id>
    <published>2018-08-25T14:51:41.000Z</published>
    <updated>2018-08-25T14:52:19.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes" target="_blank" rel="noopener">Spring官方文档 bean scope</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/current/spri
      
    
    </summary>
    
      <category term="Spring" scheme="http://jianwl.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://jianwl.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>spring bean lifecycle</title>
    <link href="http://jianwl.com/2018/08/25/spring-bean-lifecycle/"/>
    <id>http://jianwl.com/2018/08/25/spring-bean-lifecycle/</id>
    <published>2018-08-25T13:08:14.000Z</published>
    <updated>2018-08-25T14:42:21.990Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>传统java对象的生命始于调用实例化对象的new运算符，并且当对象符合垃圾收集条件时调用finalize()方法。与传统的java对象相比，spring bean的生命周期不同。Spring框架提供了一下可用于控制bean生命周期的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InitializingBean和DisposableBean接口分别用于初始化Bean前和销毁Bean前调用方法。</span><br><span class="line"></span><br><span class="line">BeanNameAware、BeanFactoryAware和ApplicationContextAware用于特定行为的接口</span><br></pre></td></tr></table></figure><h3 id="生命周期流程图"><a href="#生命周期流程图" class="headerlink" title="生命周期流程图"></a>生命周期流程图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-25/58356701.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/spring-learning/blob/master/src/test/java/com/frank/springlearning/SpringLearningApplicationTests.java" target="_blank" rel="noopener">Bean生命周期测试 - 请移步源码 SpringLearningApplicationTests#test_002</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;传统java对象的生命始于调用实例化对象的new运算符，并且当对象符合垃圾收集条件时调用finalize()方法。与传统的java对象相比，
      
    
    </summary>
    
      <category term="Spring" scheme="http://jianwl.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://jianwl.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mockito入门与实战</title>
    <link href="http://jianwl.com/2018/08/23/Mockito%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <id>http://jianwl.com/2018/08/23/Mockito入门与实战/</id>
    <published>2018-08-23T15:12:52.000Z</published>
    <updated>2018-08-23T15:23:51.265Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在本地环境下，如果某个接口依赖第三方接口，在做单元测试时，如果本地环境没有第三方接口，那么该怎么办呢？这个场景下，Mock框架就非常有用了。当调用第三方接口时，直接返回模拟的数据。这样可以绕过第三方接口的阻断，实现整个流程的测试。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/spring-learning/blob/master/src/test/java/com/frank/springlearning/MockApiTest.java" target="_blank" rel="noopener">Mockito常用特性实战 - 请移步源码</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://static.javadoc.io/org.mockito/mockito-core/2.21.0/org/mockito/Mockito.html" target="_blank" rel="noopener">Mockito官方快速入门文档</a></li><li><a href="https://site.mockito.org/" target="_blank" rel="noopener">Mockito官方介绍</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在本地环境下，如果某个接口依赖第三方接口，在做单元测试时，如果本地环境没有第三方接口，那么该怎么办呢？这个场景下，Mock框架就非常有用了。
      
    
    </summary>
    
      <category term="Mock" scheme="http://jianwl.com/categories/Mock/"/>
    
    
      <category term="Mock" scheme="http://jianwl.com/tags/Mock/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot使用Converter实现类型转换</title>
    <link href="http://jianwl.com/2018/08/20/SpringBoot%E4%BD%BF%E7%94%A8Converter%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://jianwl.com/2018/08/20/SpringBoot使用Converter实现类型转换/</id>
    <published>2018-08-20T00:07:10.000Z</published>
    <updated>2018-08-20T00:26:37.146Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Spring3引入了Converter，实现从一个Object转为另外一个Object；</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="1-注册Convert实现"><a href="#1-注册Convert实现" class="headerlink" title="1. 注册Convert实现"></a>1. 注册Convert实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class StringToDateConverter implements Converter&lt;String,Date&gt;&#123;</span><br><span class="line">    private SimpleDateFormat sdf;</span><br><span class="line"></span><br><span class="line">    public StringToDateConverter() &#123;</span><br><span class="line">        sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public Date convert(String s) &#123;</span><br><span class="line">        Date date = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            date = sdf.parse(s);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-HelloController-API层"><a href="#2-HelloController-API层" class="headerlink" title="2. HelloController(API层)"></a>2. HelloController(API层)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @RequestMapping(value = &quot;/date&quot;)</span><br><span class="line">    public String date(@RequestParam Date dateTime)&#123;</span><br><span class="line">        return &quot;hello: &quot; + dateTime.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-调用层"><a href="#3-调用层" class="headerlink" title="3. 调用层"></a>3. 调用层</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 启动SpringBoot服务，端口为1111</span><br><span class="line"></span><br><span class="line"># 使用CURL命令调用</span><br><span class="line">curl &quot;localhost:1111/date?dateTime=2018-08-10&quot;</span><br><span class="line"></span><br><span class="line"># 得到结果</span><br><span class="line">hello: 1533830400000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在Spring3引入了Converter，实现从一个Object转为另外一个Object；&lt;/p&gt;
&lt;h3 id=&quot;实战&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://jianwl.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://jianwl.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>java8之Funtion学习</title>
    <link href="http://jianwl.com/2018/08/13/java8%E4%B9%8BFuntion%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/08/13/java8之Funtion学习/</id>
    <published>2018-08-13T14:08:38.000Z</published>
    <updated>2018-08-13T14:37:36.462Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>function是java8的特性，之前零零散散接触过，但是都没怎么深入研究过这块，先来个扫盲篇，后续再好好整理。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">package functiondemo;</span><br><span class="line"></span><br><span class="line">import java.util.function.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author jianweilin</span><br><span class="line"> * @date 2018/8/13</span><br><span class="line"> */</span><br><span class="line">public class FunctionDemo &#123;</span><br><span class="line">    /**</span><br><span class="line">     * BiConsumer&lt;T,U&gt;</span><br><span class="line">     * T、U 均为入参，无返回值</span><br><span class="line">     */</span><br><span class="line">    public static void biConsumer() &#123;</span><br><span class="line">        BiConsumer&lt;String, String&gt; consumer = (x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(String.format(&quot;x = %s,y=%s&quot;, x, y));</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.accept(&quot;test01&quot;, &quot;test02&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BiFunction&lt;T,U,R&gt;</span><br><span class="line">     * T,U 为入参，R为返回值</span><br><span class="line">     */</span><br><span class="line">    public static void biFunction() &#123;</span><br><span class="line">        BiFunction&lt;String, String, String&gt; bi = (x, y) -&gt; &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(bi.apply(&quot;jian&quot;, &quot;.com&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BiPredicate&lt;T,U&gt;</span><br><span class="line">     * T，U 为入参，Boolean会返回值</span><br><span class="line">     */</span><br><span class="line">    public static void biPredicate() &#123;</span><br><span class="line">        BiPredicate&lt;Integer, Integer&gt; bi = (x, y) -&gt; x &gt; y;</span><br><span class="line">        BiPredicate&lt;Integer, Integer&gt; eq = (x, y) -&gt; x - 2 &gt; y;</span><br><span class="line"></span><br><span class="line">        System.out.println(bi.test(2, 3));</span><br><span class="line">        System.out.println(bi.and(eq).test(2, 3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BinaryOperator&lt;T&gt;</span><br><span class="line">     * 两个入参，得到一个返回值</span><br><span class="line">     */</span><br><span class="line">    public static void binaryOperator() &#123;</span><br><span class="line">        BinaryOperator&lt;Integer&gt; operator = (n1, n2) -&gt; n1 + n2;</span><br><span class="line">        System.out.println(operator.apply(3,4));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回一个boolean类型</span><br><span class="line">     */</span><br><span class="line">    public static void booleanSupplier()&#123;</span><br><span class="line">        BooleanSupplier bs = () -&gt; true;</span><br><span class="line">        System.out.println(bs.getAsBoolean());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 一个函数接受一个入参，无返回值</span><br><span class="line">     */</span><br><span class="line">    public static void consumer()&#123;</span><br><span class="line">        Consumer&lt;String&gt; c = (x) -&gt; System.out.println(x.toUpperCase());</span><br><span class="line">        c.accept(&quot;hello world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Function&lt;T,R&gt;</span><br><span class="line">     * 接受一个参数，并得到一个返回结果</span><br><span class="line">     */</span><br><span class="line">    public static void function()&#123;</span><br><span class="line">        Function&lt;Integer,String&gt; converter = (i) -&gt; Integer.toString(i);</span><br><span class="line">        System.out.println(converter.apply(3).length());</span><br><span class="line">        System.out.println(converter.apply(30).length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">Oracle Function文档</a></li><li><a href="http://www.java2s.com/Tutorials/Java_Lambda/java.util.function/" target="_blank" rel="noopener">Function实战</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;function是java8的特性，之前零零散散接触过，但是都没怎么深入研究过这块，先来个扫盲篇，后续再好好整理。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>mac终端崩溃</title>
    <link href="http://jianwl.com/2018/08/11/mac%E7%BB%88%E7%AB%AF%E5%B4%A9%E6%BA%83/"/>
    <id>http://jianwl.com/2018/08/11/mac终端崩溃/</id>
    <published>2018-08-11T06:07:15.000Z</published>
    <updated>2018-08-11T06:19:31.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>执行<code>brew update</code>，在更新过程中，手动退出更新进程，导致Mac的终端崩溃，每次打开终端时都出现以下界面：</p><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/91155821.jpg" alt=""></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-打开「自动操作」应用"><a href="#1-打开「自动操作」应用" class="headerlink" title="1. 打开「自动操作」应用"></a>1. 打开「自动操作」应用</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/91467398.jpg" alt=""></p><h4 id="2-在「自动操作」中选择：编辑-gt-新建-gt-工作流程-gt-shell脚本"><a href="#2-在「自动操作」中选择：编辑-gt-新建-gt-工作流程-gt-shell脚本" class="headerlink" title="2. 在「自动操作」中选择：编辑 -&gt; 新建 -&gt; 工作流程 -&gt; shell脚本"></a>2. 在「自动操作」中选择：编辑 -&gt; 新建 -&gt; 工作流程 -&gt; shell脚本</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/31642310.jpg" alt=""></p><h4 id="3-shell脚本，选择-bin-bash并执行以下命令"><a href="#3-shell脚本，选择-bin-bash并执行以下命令" class="headerlink" title="3. shell脚本，选择/bin/bash并执行以下命令"></a>3. shell脚本，选择<code>/bin/bash</code>并执行以下命令</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/27114106.jpg" alt=""></p><p>至此完成终端的修复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;执行&lt;code&gt;brew update&lt;/code&gt;，在更新过程中，手动退出更新进程，导致Mac的终端崩溃，每次打开终端时都出现以下界面：&lt;
      
    
    </summary>
    
      <category term="Mac" scheme="http://jianwl.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://jianwl.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>23.访问者模式</title>
    <link href="http://jianwl.com/2018/08/10/23-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/23-访问者模式/</id>
    <published>2018-08-10T00:32:45.000Z</published>
    <updated>2018-08-11T10:27:40.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>军营里，有指挥官的访问者、有中士的访问者、也有军士的访问者。</p><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义这些元素的新操作。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><p>访问者模式的目的是要把处理从数据结构分离出来。很多系统按照算法和数据结构分开，如果系统有稳定的数据结构，又有易于变化的算法，使用访问者模式比较合适。</p><h4 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h4><p>增加新的操作很容易，因为增加新的操作就以为这增加一个新的访问者。访问模式将有关的行为集中到一个访问者对象中。</p><h4 id="4-UML"><a href="#4-UML" class="headerlink" title="4. UML"></a>4. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/25786652.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/visitor" target="_blank" rel="noopener">访问者模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;军营里，有指挥官的访问者、有中士的访问者、也有军士的访问者。&lt;/p&gt;
&lt;h3 id=&quot;访问者模式&quot;&gt;&lt;a href=&quot;#访问者模式&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>22.解释器模式</title>
    <link href="http://jianwl.com/2018/08/10/22-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/22-解释器模式/</id>
    <published>2018-08-10T00:32:35.000Z</published>
    <updated>2018-08-11T10:02:57.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>实现一个计算器，实现加减法。</p><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>给定一个语言，定义它的语法的一种表示并定义一个解释器。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><ol><li>如果一个特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。</li></ol><h4 id="3-不足"><a href="#3-不足" class="headerlink" title="3. 不足"></a>3. 不足</h4><p>解释器模式为语法的每一条规则至少定义了一个类，因此包含许多规则的语法可能难以管理和维护。</p><h4 id="4-UML"><a href="#4-UML" class="headerlink" title="4. UML"></a>4. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/45885692.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/interpreter" target="_blank" rel="noopener">解释器模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;实现一个计算器，实现加减法。&lt;/p&gt;
&lt;h3 id=&quot;解释器模式&quot;&gt;&lt;a href=&quot;#解释器模式&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>21.享元模式</title>
    <link href="http://jianwl.com/2018/08/10/21-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/21-享元模式/</id>
    <published>2018-08-10T00:32:26.000Z</published>
    <updated>2018-08-11T09:57:56.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>炼金术商铺的货架上摆满了药水，每种药水都有多瓶。为了实现对象的复用，每种药水可以返回同一对象，实现对象的复用。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>运用共享技术有效地支持大量细粒度的对象</p><h4 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h4><p>如果有一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销就应该考虑使用；</p><h4 id="3-UML"><a href="#3-UML" class="headerlink" title="3. UML"></a>3. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/90836786.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/flyweight" target="_blank" rel="noopener">享元模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;炼金术商铺的货架上摆满了药水，每种药水都有多瓶。为了实现对象的复用，每种药水可以返回同一对象，实现对象的复用。&lt;/p&gt;
&lt;h3 id
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>20.中介者模式</title>
    <link href="http://jianwl.com/2018/08/10/20-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/20-中介者模式/</id>
    <published>2018-08-10T00:32:19.000Z</published>
    <updated>2018-08-11T09:50:20.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>举办一个相亲的Party，所有人并不知道有谁会参加，只知道来参加这个Party即可。</p><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><p>中介者模式一般用于一组对象以定义良好但是复杂的方式进行通信的场合。</p><h4 id="3-UML"><a href="#3-UML" class="headerlink" title="3. UML"></a>3. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/27571060.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/mediator" target="_blank" rel="noopener">中介者模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;举办一个相亲的Party，所有人并不知道有谁会参加，只知道来参加这个Party即可。&lt;/p&gt;
&lt;h3 id=&quot;中介者模式&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>19.责任链模式</title>
    <link href="http://jianwl.com/2018/08/10/19-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/19-责任链模式/</id>
    <published>2018-08-10T00:32:07.000Z</published>
    <updated>2018-08-11T09:43:41.741Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>国王发出指令：保卫城堡、释放囚犯、多征税收，这一些列的指令都会有特定的人来处理。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之前的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><ol><li>接收者和发送者都没有对方的明确信息，且链中的对象也不知道链的结构，结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需要保持它所有的候选者的引用。</li></ol><h4 id="3-UML"><a href="#3-UML" class="headerlink" title="3. UML"></a>3. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/99125541.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/chain" target="_blank" rel="noopener">责任链模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;国王发出指令：保卫城堡、释放囚犯、多征税收，这一些列的指令都会有特定的人来处理。&lt;/p&gt;
&lt;h3 id=&quot;责任链模式&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>18.命令模式</title>
    <link href="http://jianwl.com/2018/08/10/18-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/18-命令模式/</id>
    <published>2018-08-10T00:31:59.000Z</published>
    <updated>2018-08-11T09:33:18.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>巫师对妖精，使用了收缩咒和隐身咒。</p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。对请求排队或记录请求记录，以及支持可撤销的操作。</p><h4 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h4><ol><li>它能容易地设计一个命令队列</li><li>在需要的情况下，可以较容易地将命令记入日志。</li><li>允许接受请求的一方决定是否要否决请求</li><li>较为容易实现对请求的撤销或重做</li><li>由于加进新的命令模式类不影响其他类。</li></ol><h4 id="3-UML"><a href="#3-UML" class="headerlink" title="3. UML"></a>3. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/52368763.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/command" target="_blank" rel="noopener">命令模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;巫师对妖精，使用了收缩咒和隐身咒。&lt;/p&gt;
&lt;h3 id=&quot;命令模式&quot;&gt;&lt;a href=&quot;#命令模式&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>17.桥接模式</title>
    <link href="http://jianwl.com/2018/08/10/17-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/17-桥接模式/</id>
    <published>2018-08-10T00:31:51.000Z</published>
    <updated>2018-08-11T09:18:48.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>需要对武器进行附魔，武器和魔力属性是通过某种方式桥接在一起。</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>将抽象部分与它的实现部分分离，使他们都可以独立的变化。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><ol><li>使用聚合的关系，将两种对象聚合在一起形成一个整体。</li></ol><h4 id="3-UML"><a href="#3-UML" class="headerlink" title="3. UML"></a>3. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/99073982.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/bridge" target="_blank" rel="noopener">桥接模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;需要对武器进行附魔，武器和魔力属性是通过某种方式桥接在一起。&lt;/p&gt;
&lt;h3 id=&quot;桥接模式&quot;&gt;&lt;a href=&quot;#桥接模式&quot; c
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>16.单例模式</title>
    <link href="http://jianwl.com/2018/08/10/16-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/16-单例模式/</id>
    <published>2018-08-10T00:31:42.000Z</published>
    <updated>2018-08-11T09:01:39.567Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>保证一个类仅有一个实例，有多种实现方式，理解每种方式的优缺点。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><ol><li>保证类只有唯一实例</li></ol><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/singleton" target="_blank" rel="noopener">单例模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;保证一个类仅有一个实例，有多种实现方式，理解每种方式的优缺点。&lt;/p&gt;
&lt;h3 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; 
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>15.迭代器模式</title>
    <link href="http://jianwl.com/2018/08/10/15-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/15-迭代器模式/</id>
    <published>2018-08-10T00:31:31.000Z</published>
    <updated>2018-08-11T08:56:51.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>有个宝库，里面有很多宝箱，每个宝箱都能爆出不同的装备。可能是首饰类、武器、药剂。请遍历宝库里所有的宝箱里装备。</p><h3 id="迭代模式"><a href="#迭代模式" class="headerlink" title="迭代模式"></a>迭代模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象内部表示。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><ol><li>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样即可以不暴露集合的内部结构，又可让外部代码透明地访问集合内部数据。</li></ol><h4 id="3-UML"><a href="#3-UML" class="headerlink" title="3. UML"></a>3. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/35337447.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/Iterator" target="_blank" rel="noopener">迭代模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;有个宝库，里面有很多宝箱，每个宝箱都能爆出不同的装备。可能是首饰类、武器、药剂。请遍历宝库里所有的宝箱里装备。&lt;/p&gt;
&lt;h3 id
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>14.组合模式</title>
    <link href="http://jianwl.com/2018/08/10/14-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/10/14-组合模式/</id>
    <published>2018-08-10T00:31:16.000Z</published>
    <updated>2018-08-11T08:41:51.657Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>多个字母组成一个单词，多个单词组成一句话。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>将对象组合成树状结构以表示’部分-整体’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><h4 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h4><ol><li>需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑使用组合模式了。</li></ol><h4 id="3-UML"><a href="#3-UML" class="headerlink" title="3. UML"></a>3. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-11/63835290.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/composite" target="_blank" rel="noopener">组合模式，请移步源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;多个字母组成一个单词，多个单词组成一句话。&lt;/p&gt;
&lt;h3 id=&quot;组合模式&quot;&gt;&lt;a href=&quot;#组合模式&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>13.适配器模式</title>
    <link href="http://jianwl.com/2018/08/09/13-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2018/08/09/13-适配器模式/</id>
    <published>2018-08-09T15:33:38.000Z</published>
    <updated>2018-08-10T00:51:39.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h3><p>一群人在海上遇到了海盗，大船搁浅了，刚好这群人中有个舰长，还有个渔船。舰长需要适配掌控这个渔船带着所有人逃生。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口模式不兼容而不能一起工作的接口的那些类可以一起工作。</p><h4 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h4><ol><li>两个类所作的事情相同或相似，但是使用它时，需要调用不同的接口。这种情况应该用适配器模式，调用一个接口即可。</li></ol><h4 id="3-UML"><a href="#3-UML" class="headerlink" title="3. UML"></a>3. UML</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-8-10/98252317.jpg" alt=""></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><a href="https://github.com/frank-jian/design-pattern-action/tree/master/src/main/java/adapter" target="_blank" rel="noopener">适配器模式实战，请移步看源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小故事&quot;&gt;&lt;a href=&quot;#小故事&quot; class=&quot;headerlink&quot; title=&quot;小故事&quot;&gt;&lt;/a&gt;小故事&lt;/h3&gt;&lt;p&gt;一群人在海上遇到了海盗，大船搁浅了，刚好这群人中有个舰长，还有个渔船。舰长需要适配掌控这个渔船带着所有人逃生。&lt;/p&gt;
&lt;h3 id
      
    
    </summary>
    
      <category term="设计模式" scheme="http://jianwl.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://jianwl.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
