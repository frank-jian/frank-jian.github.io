<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录点滴成长</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianwl.com/"/>
  <updated>2018-04-18T01:10:06.649Z</updated>
  <id>http://jianwl.com/</id>
  
  <author>
    <name>流云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThreadPoolExecutor线程池源码学习</title>
    <link href="http://jianwl.com/2018/04/18/ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/18/ThreadPoolExecutor线程池源码学习/</id>
    <published>2018-04-18T00:24:37.000Z</published>
    <updated>2018-04-18T01:10:06.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-使用线程池的好处"><a href="#1-使用线程池的好处" class="headerlink" title="1. 使用线程池的好处"></a>1. 使用线程池的好处</h3><p>合理利用线程池能够带来三个好处。</p>
<p>① 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</p>
<p>② 提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
<p>③ 提高线程的可管理性。线程时稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h3 id="2-线程池的工作原理"><a href="#2-线程池的工作原理" class="headerlink" title="2. 线程池的工作原理"></a>2. 线程池的工作原理</h3><p>首先我们看下当一个新的任务提交到线程池之后，线程池是如何处理的；</p>
<p>① 线程池判断核心线程池里的线程是否都在执行任务；如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则执行第二步；</p>
<p>② 线程池判断工作队列是否已经满。如果工作队列已经满，则将新提交的任务存储在这个工作队列里进行等待。如果工作队列满了，则执行第三步；</p>
<p>③ 线程池判断线程池的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务</p>
<h4 id="线程池饱和策略"><a href="#线程池饱和策略" class="headerlink" title="线程池饱和策略"></a>线程池饱和策略</h4><p>这里提到了线程池的饱和策略，那我们就简单介绍下有哪些饱和策略</p>
<table>
<thead>
<tr>
<th style="text-align:center">策略类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AbortPolicy</td>
<td style="text-align:center">直接抛出异常，线程池默认处理策略；切记ThreadPoolExecutor.execute需要try catch，否则程序会直接退出</td>
</tr>
<tr>
<td style="text-align:center">DiscardPolicy</td>
<td style="text-align:center">不处理，丢弃掉</td>
</tr>
<tr>
<td style="text-align:center">DiscardOldestPolicy</td>
<td style="text-align:center">丢弃队里里最近一个任务，并执行当前任务</td>
</tr>
<tr>
<td style="text-align:center">CallerRusPolicy</td>
<td style="text-align:center">只用调用者所在线程来运行任务</td>
</tr>
<tr>
<td style="text-align:center">自定义策略</td>
<td style="text-align:center">可以根据引用场景需要来实现RejectedExecutionHandler接口自定义策略，如记录日志或持久化不能处理的任务</td>
</tr>
</tbody>
</table>
<h3 id="3-线程池工作流程图"><a href="#3-线程池工作流程图" class="headerlink" title="3. 线程池工作流程图"></a>3. 线程池工作流程图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-12/20324843.jpg" alt=""></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-12/82099386.jpg" alt=""></p>
<p>① 如果当前运行的线程小于corePoolSize,则创建新线程来执行任务（注意执行这一步需要获取全局锁）</p>
<p>② 如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue；</p>
<p>③ 如果BlockingQueue队列已满，则在非corePool中创建新的线程来处理任务（注意执行这一步需要获取全局锁）</p>
<p>④ 如果创建新线程将使当前运行的线程超出maximumPoolSize,任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</p>
<h3 id="4-线程池的使用"><a href="#4-线程池的使用" class="headerlink" title="4. 线程池的使用"></a>4. 线程池的使用</h3><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><p>我们可以通过ThreadPoolExecutor来创建一个线程池；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds, runnableTaskQueue,threadFactory, handler);</div></pre></td></tr></table></figure>
<p>创建一个线程池需要输入几个参数：</p>
<h5 id="1）corePoolSize（线程池的基本大小）"><a href="#1）corePoolSize（线程池的基本大小）" class="headerlink" title="1）corePoolSize（线程池的基本大小）"></a>1）corePoolSize（线程池的基本大小）</h5><p>当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程池</p>
<h5 id="2）runnableTaskQueue（任务队列）"><a href="#2）runnableTaskQueue（任务队列）" class="headerlink" title="2）runnableTaskQueue（任务队列）"></a>2）runnableTaskQueue（任务队列）</h5><p>用于保存等待执行的任务的阻塞队列，可以选择一下几个阻塞队列</p>
<p>① ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO(先进先出)原则对元素进行排序；</p>
<p>② LinkedBlockingQueue: 一个基于链表结构的阻塞队列，此队列按FIFO(先进先出)排序元素，吞吐量通常高于ArrayBlockingQueue，静态工厂方法Executors.newFixedThreadPool()使用这个队列</p>
<p>③ SyschronousQueue: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常高于LinkedBlockingQueue，静态工作方法 Executors.newCachedThreadPool使用这个队列；</p>
<p>④ PriorityBlockingQueue： 一个具有优先级的无限阻塞队列；</p>
<h5 id="3）maxmumPoolSize（线程池最大大小）"><a href="#3）maxmumPoolSize（线程池最大大小）" class="headerlink" title="3）maxmumPoolSize（线程池最大大小）"></a>3）maxmumPoolSize（线程池最大大小）</h5><p>线程池允许创建的最大线程数，如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的队列这个参数就没有效果了；</p>
<h5 id="4-ThreadFactory"><a href="#4-ThreadFactory" class="headerlink" title="4) ThreadFactory"></a>4) ThreadFactory</h5><p>用于设置创建线程工厂，可以通过线程工厂给创建出来的线程设置有语义的名字</p>
<h5 id="5）RejectedExecutionHandler（饱和策略）"><a href="#5）RejectedExecutionHandler（饱和策略）" class="headerlink" title="5）RejectedExecutionHandler（饱和策略）"></a>5）RejectedExecutionHandler（饱和策略）</h5><p>参考上述步骤2中的，饱和策略分析</p>
<h5 id="6）keepAliveTime（线程活动保持时间）"><a href="#6）keepAliveTime（线程活动保持时间）" class="headerlink" title="6）keepAliveTime（线程活动保持时间）"></a>6）keepAliveTime（线程活动保持时间）</h5><p>大于corePool(线程池基本大小)的空闲工作线程，保持存活的时间<strong>(在存活时间内，如果没有接受新任务，就会被销毁)</strong>。如果任务很多，每个任务执行的时间比较短，可以调整这个时间，提高线程的利用率；</p>
<h5 id="7）TimeUnit（线程活动保持时间的单位）"><a href="#7）TimeUnit（线程活动保持时间的单位）" class="headerlink" title="7）TimeUnit（线程活动保持时间的单位）"></a>7）TimeUnit（线程活动保持时间的单位）</h5><p>可选单位有天(DAYS)、小时(HOURS)、分钟(MINUTES)、毫秒(MILLISECONDS)、微秒(MICROSECONDS)</p>
<h3 id="5-源码分析"><a href="#5-源码分析" class="headerlink" title="5. 源码分析"></a>5. 源码分析</h3><h4 id="1）提问"><a href="#1）提问" class="headerlink" title="1）提问"></a>1）提问</h4><p>1、线程池新增任务的流程；execute(Runnable command)</p>
<p>2、线程池如何实现，在RUNING状态下，接受新任务，且处理队列里的任务；在SHUTDOWN状态下，不接受新任务，但处理新任务的 ;以及在STOP、TIDYING和TERMINATE状态下的处理方式；</p>
<p>3、线程池如何处理新增任务时，出现异常的；addWorkerFailed(Worker w)</p>
<p>4、线程池如何实现关闭的；</p>
<h5 id="1-1-execute-Runnable-command"><a href="#1-1-execute-Runnable-command" class="headerlink" title="1-1) execute(Runnable command)"></a>1-1) execute(Runnable command)</h5><p><code>execute</code>方法三个主要步骤：① 活动线程小于<code>corePoolSize</code>的时候创建新的线程；②活动线程大于<code>corePoolSize</code>先加入到任务队列当中；③ 任务队列满了再去启动新的线程，如果线程数达到最大值就拒绝任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void execute(Runnable command) &#123; </div><div class="line">    if (command == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">  </div><div class="line">    int c = ctl.get();</div><div class="line"></div><div class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        if (addWorker(command, true))</div><div class="line">            return;</div><div class="line">        c = ctl.get();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        int recheck = ctl.get();</div><div class="line"></div><div class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line"></div><div class="line">        else if (workerCountOf(recheck) == 0)</div><div class="line">            addWorker(null, false);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    else if (!addWorker(command, false))</div><div class="line">        reject(command);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第 5 行：ctl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</div></pre></td></tr></table></figure>
<p><code>ThreadPoolExecutor</code>用这一变量保存了两个内容：① 所有有效线程数量「workerCount」② 线程池运行状态「runState」; 低29位存<code>workerCounter</code>，高3位存<code>runState</code>, 这样<code>runState</code>有5个值；</p>
<ul>
<li>RUNNING: -1 &lt;&lt; 29</li>
<li>SHOTDOWN: 0 &lt;&lt; 29</li>
<li>STOP: 1 &lt;&lt; 29</li>
<li>TIDYING: 2 &lt;&lt; 29</li>
<li>TERMINATED: 3 &lt;&lt; 29</li>
</ul>
<p>线程池各状态转换比较复杂，记住下面内容就可以了：</p>
<ul>
<li>RUNNING状态：线程池正常运行，可以接受新的任务并处理队列中的任务；</li>
<li>SHUTDOWN状态：不再接受新的任务，但是会执行队列中的任务；</li>
<li>STOP状态：不再接受新任务，不处理队列中的任务，中断正在进行中的任务；</li>
<li>TIDYING: 所有任务都已关闭，有效线程数为0，将运行<code>terminated()</code>钩子方法；</li>
<li>TERMINATED: <code>terminated()</code>方法执行完毕；</li>
</ul>
<p>第 7 行：当有效线程数 小于 核心线程数时；</p>
<p><code>workerCountOf(ctl.get())</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private static final int COUNT_BITS = 29;</div><div class="line"></div><div class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</div><div class="line"></div><div class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</div></pre></td></tr></table></figure>
<p>ctl的低29位存着有效线程数，通过 <code>c &amp; 00011111111111111111111111111</code>的方式得到<code>有效线程数</code></p>
<p>第 8 行：线程池有效线程数小于核心线程数时，新增任务成功，则退出；</p>
<p>源码中：<code>Worker类</code>、<code>addWorkerFailed()方法</code>在后文继续分析</p>
<p><code>addWorker(command,true)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</div><div class="line">    retry:</div><div class="line">    for (;;) &#123;</div><div class="line">        int c = ctl.get();</div><div class="line">        int rs = runStateOf(c); // 当前线程池状态</div><div class="line"></div><div class="line">        // 线程池状态为：SHUTDOWN STOP TIDYING TERMINATED 均不在接受新任务；</div><div class="line">        // 但是当状态为SHUTDOWN时，若此时队列不为空，为了保证队列中的任务能够被执行完；</div><div class="line">        // SHUTDOWN时通过addWoker(null,false)方法,新增有效线程数；「执行addWorker(null,false)，此时workerCounter == 0」</div><div class="line">        // 所以当线程池的状态为SHUTDOWN，firstTask == null，队列不为空时，将继续往下执行；</div><div class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">            ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">               firstTask == null &amp;&amp;</div><div class="line">               ! workQueue.isEmpty()))</div><div class="line">            return false;</div><div class="line"></div><div class="line">        for (;;) &#123;</div><div class="line">            int wc = workerCountOf(c); // 有效线程数</div><div class="line"></div><div class="line">            if (wc &gt;= CAPACITY ||</div><div class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                return false;</div><div class="line"></div><div class="line">            if (compareAndIncrementWorkerCount(c)) // 原子操作递增workerCount</div><div class="line">                break retry; // 操作成功跳出重试循环</div><div class="line">            c = ctl.get();  // Re-read ctl</div><div class="line">            if (runStateOf(c) != rs) // 如果线程池的状态发生变化则重试</div><div class="line">                continue retry;</div><div class="line">            // else CAS failed due to workerCount change; retry inner loop</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // workerCount递增成功</div><div class="line">    boolean workerStarted = false;</div><div class="line">    boolean workerAdded = false;</div><div class="line">    Worker w = null;</div><div class="line">    try &#123;</div><div class="line">        w = new Worker(firstTask);</div><div class="line">        final Thread t = w.thread;</div><div class="line">        if (t != null) &#123;</div><div class="line">            final ReentrantLock mainLock = this.mainLock;</div><div class="line">            // 并发的访问线程池workers对象必须加锁</div><div class="line">            mainLock.lock();</div><div class="line">            try &#123;</div><div class="line">                // Recheck while holding lock.</div><div class="line">                // Back out on ThreadFactory failure or if</div><div class="line">                // shut down before lock acquired.</div><div class="line">                int rs = runStateOf(ctl.get());</div><div class="line"></div><div class="line">                // RUNNING 状态 || SHUTDOWN状态下清理队列中剩余的任务</div><div class="line">                if (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</div><div class="line">                    if (t.isAlive()) // precheck that t is startable</div><div class="line">                        throw new IllegalThreadStateException();</div><div class="line">                    // 将线程放到线程列表中</div><div class="line">                    workers.add(w);</div><div class="line">                    int s = workers.size();</div><div class="line">                    if (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = true;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            // 启动新添加的线程，这个线程首先执行firstTask，然后不停的从队列中取任务执行；</div><div class="line">            if (workerAdded) &#123;</div><div class="line">                t.start(); // 最终执行的是ThreadPoolExecutor的runWorker方法</div><div class="line">                workerStarted = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        // 线程启动失败，则从workers中移除w并递减workerCount</div><div class="line">        if (! workerStarted)</div><div class="line">            // 递减workerCount会触发tryTerminate方法</div><div class="line">            addWorkerFailed(w);</div><div class="line">    &#125;</div><div class="line">    return workerStarted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第13 ~ 21行：</p>
<p><code>runState</code>为RUNNING状态且队列未满，双重检查，再次获取线程池ctl，判断当前线程池状态；若线程池为非RUNNING状态，则从workQueue中移除任务，并执行线程池拒绝任务策略；若当前有效线程数为0，则添加一个空任务到队列里；「理由是：当线程池状态为SHUTDOWN时，若队列不为空，有效线程数为0，需要通过添加空任务的方法，增加有效线程数」</p>
<p>第 23 ~ 25行：</p>
<p>① 线程池非RUNNING状态，拒绝新任务，执行拒绝策略 ② 队列满了且当且有效线程数大于最大线程数时，执行拒绝策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final void reject(Runnable command) &#123;</div><div class="line">    handler.rejectedExecution(command, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-2-Worker"><a href="#1-2-Worker" class="headerlink" title="1-2 Worker"></a>1-2 Worker</h5><p>任务添加成功后，实际执行的是runWorker(this)的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">private final class Worker</div><div class="line">    extends AbstractQueuedSynchronizer</div><div class="line">    implements Runnable</div><div class="line">&#123;</div><div class="line">    private static final long serialVersionUID = 6138294804551838833L;</div><div class="line"></div><div class="line">    final Thread thread;</div><div class="line"></div><div class="line">    Runnable firstTask;</div><div class="line"></div><div class="line">    volatile long completedTasks;</div><div class="line"></div><div class="line">    Worker(Runnable firstTask) &#123;</div><div class="line">        setState(-1); // inhibit interrupts until runWorker</div><div class="line">        this.firstTask = firstTask;</div><div class="line">        this.thread = getThreadFactory().newThread(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void run() &#123;</div><div class="line">        runWorker(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean isHeldExclusively() &#123;</div><div class="line">        return getState() != 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean tryAcquire(int unused) &#123;</div><div class="line">        if (compareAndSetState(0, 1)) &#123;</div><div class="line">            setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected boolean tryRelease(int unused) &#123;</div><div class="line">        setExclusiveOwnerThread(null);</div><div class="line">        setState(0);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void lock()        &#123; acquire(1); &#125;</div><div class="line">    public boolean tryLock()  &#123; return tryAcquire(1); &#125;</div><div class="line">    public void unlock()      &#123; release(1); &#125;</div><div class="line">    public boolean isLocked() &#123; return isHeldExclusively(); &#125;</div><div class="line"></div><div class="line">    void interruptIfStarted() &#123;</div><div class="line">        Thread t;</div><div class="line">        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;</div><div class="line">            try &#123;</div><div class="line">                t.interrupt();</div><div class="line">            &#125; catch (SecurityException ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第 20 行：runWorker简单来说做了两件事：</p>
<p>① 第一次启动会执行传进来的任务firstTask;</p>
<p>② 如果firstTask为空，则从workQueue中取任务，如果队列为空则等待<code>keepAliveTime</code>这么长的时间；</p>
<p>runWorker的核心代码为第10行代码中的<code>getTask()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">final void runWorker(Worker w) &#123;</div><div class="line">        Thread wt = Thread.currentThread();</div><div class="line">        Runnable task = w.firstTask;</div><div class="line">        w.firstTask = null;</div><div class="line">        // 任务被锁住了，需要解锁才能被中断？「这个解释需要验证」</div><div class="line">        w.unlock(); // allow interrupts</div><div class="line">        boolean completedAbruptly = true;</div><div class="line">        try &#123;</div><div class="line">            // 先执行firstTask，若firstTask为空，则从队列里取任务执行；</div><div class="line">            while (task != null || (task = getTask()) != null) &#123;</div><div class="line">                w.lock();</div><div class="line">                if ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                     (Thread.interrupted() &amp;&amp;</div><div class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                    !wt.isInterrupted())</div><div class="line">                    wt.interrupt();</div><div class="line">                try &#123;</div><div class="line">                    // 任务执行前可以插入一些处理、子类重载该方法</div><div class="line">                    beforeExecute(wt, task);</div><div class="line">                    Throwable thrown = null;</div><div class="line">                    try &#123;</div><div class="line">                        task.run(); // 执行用户任务</div><div class="line">                    &#125; catch (RuntimeException x) &#123;</div><div class="line">                        thrown = x; throw x;</div><div class="line">                    &#125; catch (Error x) &#123;</div><div class="line">                        thrown = x; throw x;</div><div class="line">                    &#125; catch (Throwable x) &#123;</div><div class="line">                        thrown = x; throw new Error(x);</div><div class="line">                    &#125; finally &#123;</div><div class="line">                        // 和beforeExecute一样，留给子类去重载；</div><div class="line">                        afterExecute(task, thrown);</div><div class="line">                    &#125;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    task = null;</div><div class="line">                    w.completedTasks++;</div><div class="line">                    w.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            completedAbruptly = false;</div><div class="line">        &#125; finally &#123;</div><div class="line">            // 结束线程的一些清理工作</div><div class="line">            processWorkerExit(w, completedAbruptly);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="1-3-runWorker-中的getTask-方法"><a href="#1-3-runWorker-中的getTask-方法" class="headerlink" title="1-3 runWorker()中的getTask()方法"></a>1-3 runWorker()中的getTask()方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private Runnable getTask() &#123;</div><div class="line">    boolean timedOut = false; // Did the last poll() time out?</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line">        int c = ctl.get();</div><div class="line">        int rs = runStateOf(c);</div><div class="line"></div><div class="line">        // SHUTDOWN状态：队列不为空，不接受新任务，但有队列中的任务需要执行；</div><div class="line">        // Check if queue empty only if necessary.</div><div class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">            decrementWorkerCount();</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int wc = workerCountOf(c);</div><div class="line"></div><div class="line">        // Are workers subject to culling?</div><div class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">        // timed == false 不允许核心线程超时，即使核心线程处于闲置装填也不会被回收；</div><div class="line">        // timed == true 允许核心线程超时,只要核心线程处于闲置状态就会被回收;</div><div class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</div><div class="line">            if (compareAndDecrementWorkerCount(c))</div><div class="line">                return null;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            Runnable r = timed ?</div><div class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                workQueue.take();</div><div class="line">            if (r != null)</div><div class="line">                return r;</div><div class="line">            timedOut = true;</div><div class="line">        &#125; catch (InterruptedException retry) &#123;</div><div class="line">            timedOut = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-4-addWorkerFailed"><a href="#1-4-addWorkerFailed" class="headerlink" title="1-4 addWorkerFailed"></a>1-4 addWorkerFailed</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private void addWorkerFailed(Worker w) &#123;</div><div class="line">    final ReentrantLock mainLock = this.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    try &#123;</div><div class="line">        if (w != null)</div><div class="line">            workers.remove(w); // 移除任务</div><div class="line">        decrementWorkerCount(); // 递减workerCount</div><div class="line">        tryTerminate();</div><div class="line">    &#125; finally &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在addWorker时，出现异常时，需要做回滚操作，① 将任务从队列中移除； ② 将有效线程数减1 ③ 因为有效线程数发生变化了，所有需要尝试调用<code>tryTerminate</code>来终止线程池;</p>
<p><code>tryTerminate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">final void tryTerminate() &#123;</div><div class="line">    for (;;) &#123;</div><div class="line">        int c = ctl.get();</div><div class="line">        // 以下状态直接返回</div><div class="line">        // 1. 线程池还处于RUNNING状态</div><div class="line">        // 2. runState &gt;= TIDYING 线程池已经停止了或正在停止了</div><div class="line">        // 3. SHUTDOWN状态但队列非空</div><div class="line">        if (isRunning(c) ||</div><div class="line">            runStateAtLeast(c, TIDYING) ||</div><div class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</div><div class="line">            return;</div><div class="line"></div><div class="line">        // workerCount不为0，则还不能停止线程池，</div><div class="line">        if (workerCountOf(c) != 0) &#123; // Eligible to terminate</div><div class="line">            // ONLY_ONE: 只需中断1个线程去处理shutdown信号就可以了；</div><div class="line">            interruptIdleWorkers(ONLY_ONE);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final ReentrantLock mainLock = this.mainLock;</div><div class="line">        mainLock.lock();</div><div class="line">        try &#123;</div><div class="line">            // 进入TIDYING状态</div><div class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</div><div class="line">                try &#123;</div><div class="line">                    // 子类重载：一些资源清理工作</div><div class="line">                    terminated();</div><div class="line">                &#125; finally &#123;</div><div class="line">                    // TERMINATED状态</div><div class="line">                    ctl.set(ctlOf(TERMINATED, 0));</div><div class="line">                    // 进行awaitTermination</div><div class="line">                    termination.signalAll();</div><div class="line">                &#125;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line">        // else retry on failed CAS</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-5-关闭线程池shutdown"><a href="#1-5-关闭线程池shutdown" class="headerlink" title="1-5 关闭线程池shutdown"></a>1-5 关闭线程池shutdown</h5><p>shutdown这个方法会将<code>runState</code>置为SHUTDOWN，会终止所有空闲的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void shutdown() &#123;</div><div class="line">    final ReentrantLock mainLock = this.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    try &#123;</div><div class="line">        checkShutdownAccess();</div><div class="line">        // 线程池状态设为SHUTDOWN，如果已经至少是这个状态那么则直接返回</div><div class="line">        advanceRunState(SHUTDOWN);</div><div class="line">        // 注意这里是中断所有空闲的线程：runWorker中等待的线程被中断 → 进入processWorkerExit →</div><div class="line">        // tryTerminate方法中会保证队列中剩余的任务得到执行。</div><div class="line">        interruptIdleWorkers();</div><div class="line">        onShutdown(); // hook for ScheduledThreadPoolExecutor</div><div class="line">    &#125; finally &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line">    tryTerminate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-使用线程池的好处&quot;&gt;&lt;a href=&quot;#1-使用线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;1. 使用线程池的好处&quot;&gt;&lt;/a&gt;1. 使用线程池的好处&lt;/h3&gt;&lt;p&gt;合理利用线程池能够带来三个好处。&lt;/p&gt;
&lt;p&gt;① 降低资源消耗。通过重
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>StringBuilder源码学习</title>
    <link href="http://jianwl.com/2018/04/02/StringBuilder%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/02/StringBuilder源码学习/</id>
    <published>2018-04-02T14:06:55.000Z</published>
    <updated>2018-04-04T00:39:36.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段"><a href="#常用方法-amp-字段" class="headerlink" title="常用方法 &amp; 字段"></a>常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-3/88149991.jpg" alt=""></p>
<p>StringBuilder常用于单线程字符串的拼接，可以减小堆内存的开销；</p>
<p>StringBuilder继承<code>AbstractStringBuilder</code>抽象类，且实现了<code>CharSequence</code>、<code>Serializable</code>接口</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>通过append方法拼接字符串，为什么能够减少内存的开销呢，append();</li>
<li>StringBuffer和StringBuilder有什么区别？</li>
</ol>
<h4 id="1-如何拼接字符串"><a href="#1-如何拼接字符串" class="headerlink" title="1) 如何拼接字符串"></a>1) 如何拼接字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">    @Override</div><div class="line">    public StringBuilder append(String str) &#123;</div><div class="line">        super.append(str);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// AbstractStringBuilder类   </div><div class="line">    public AbstractStringBuilder append(String str) &#123;</div><div class="line">        if (str == null)</div><div class="line">            return appendNull();</div><div class="line">        int len = str.length();</div><div class="line">        ensureCapacityInternal(count + len);</div><div class="line">        str.getChars(0, len, value, count);</div><div class="line">        count += len;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private AbstractStringBuilder appendNull() &#123;</div><div class="line">        int c = count;</div><div class="line">        ensureCapacityInternal(c + 4);</div><div class="line">        final char[] value = this.value;</div><div class="line">        value[c++] = &apos;n&apos;;</div><div class="line">        value[c++] = &apos;u&apos;;</div><div class="line">        value[c++] = &apos;l&apos;;</div><div class="line">        value[c++] = &apos;l&apos;;</div><div class="line">        count = c;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line">      </div><div class="line">    private void ensureCapacityInternal(int minimumCapacity) &#123;</div><div class="line">        // overflow-conscious code</div><div class="line">        if (minimumCapacity - value.length &gt; 0)</div><div class="line">            expandCapacity(minimumCapacity);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void expandCapacity(int minimumCapacity) &#123;</div><div class="line">        int newCapacity = value.length * 2 + 2;</div><div class="line">        if (newCapacity - minimumCapacity &lt; 0)</div><div class="line">            newCapacity = minimumCapacity;</div><div class="line">        if (newCapacity &lt; 0) &#123;</div><div class="line">            if (minimumCapacity &lt; 0) // overflow</div><div class="line">                throw new OutOfMemoryError();</div><div class="line">            newCapacity = Integer.MAX_VALUE;</div><div class="line">        &#125;</div><div class="line">        value = Arrays.copyOf(value, newCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// Arrays类</div><div class="line">    public static char[] copyOf(char[] original, int newLength) &#123;</div><div class="line">        char[] copy = new char[newLength];</div><div class="line">        System.arraycopy(original, 0, copy, 0,</div><div class="line">                         Math.min(original.length, newLength));</div><div class="line">        return copy;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">// String类</div><div class="line">    public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123;</div><div class="line">        if (srcBegin &lt; 0) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcBegin);</div><div class="line">        &#125;</div><div class="line">        if (srcEnd &gt; value.length) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd);</div><div class="line">        &#125;</div><div class="line">        if (srcBegin &gt; srcEnd) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</div><div class="line">        &#125;</div><div class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="1、拼接元素为null"><a href="#1、拼接元素为null" class="headerlink" title="1、拼接元素为null"></a>1、拼接元素为null</h5><p>第 9 ~ 10 行：如果拼接字符串为<code>null值</code>，则拼接<code>null</code>字符串；</p>
<p>第 20 行：确保当前字符数组数量加4，小于字符数组长度，否则扩容；</p>
<p>第 36 ~ 45行: 执行扩容；新容量为当前字符数组长度的2倍 + 2；如果新容量仍然小于，实际字符数量，则新容量等于实际字符数量；如果新容量溢出，则新容量赋值为Integer.MAX_VALUE;将原字符数组，赋值到扩容后的数组中；</p>
<p>第 49 ~ 53行：新建容量为扩容后的长度的字符数组，将原数组元素赋值到新数组中;</p>
<h5 id="2-新增元素不为null"><a href="#2-新增元素不为null" class="headerlink" title="2 新增元素不为null"></a>2 新增元素不为null</h5><p>第 11 ~12行: 获取新增字符串的长度，确保当前字符数量 + 新增字符串长度，在字符数组容量范围内，否则执行扩容；</p>
<p>第 13行: 将新增字符串转为字符数组，将其赋值到当前字符数组中实际元素的尾部，具体如图所示；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-4/53045816.jpg" alt=""></p>
<h5 id="3-为什么可以减少堆内存的开销？"><a href="#3-为什么可以减少堆内存的开销？" class="headerlink" title="3 为什么可以减少堆内存的开销？"></a>3 为什么可以减少堆内存的开销？</h5><p>因为字符串是不可变类，每次通过new的方式创建一个不同的字符串，都会在堆内存开辟一个空间；而通过StringBuilder的append方式拼接字符串，只会开辟一个字符数组内存空间，拼接的字符串将添加到字符数组中；从而减少了堆内存的开销；</p>
<h4 id="2）StringBuffer和StringBuilder有什么区别"><a href="#2）StringBuffer和StringBuilder有什么区别" class="headerlink" title="2）StringBuffer和StringBuilder有什么区别"></a>2）StringBuffer和StringBuilder有什么区别</h4><p>StringBuffer是线程安全的，在拼接元素方法中添加了同步锁；其他实现方式与StringBuilder一致；这里就不再赘述了；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">    @Override</div><div class="line">    public synchronized StringBuffer append(String str) &#123;</div><div class="line">        toStringCache = null;</div><div class="line">        super.append(str);</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">// AbstractStringBuilder类</div><div class="line">    public AbstractStringBuilder append(String str) &#123;</div><div class="line">        if (str == null)</div><div class="line">            return appendNull();</div><div class="line">        int len = str.length();</div><div class="line">        ensureCapacityInternal(count + len);</div><div class="line">        str.getChars(0, len, value, count);</div><div class="line">        count += len;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void ensureCapacityInternal(int minimumCapacity) &#123;</div><div class="line">        // overflow-conscious code</div><div class="line">        if (minimumCapacity - value.length &gt; 0)</div><div class="line">            expandCapacity(minimumCapacity);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void expandCapacity(int minimumCapacity) &#123;</div><div class="line">        int newCapacity = value.length * 2 + 2;</div><div class="line">        if (newCapacity - minimumCapacity &lt; 0)</div><div class="line">            newCapacity = minimumCapacity;</div><div class="line">        if (newCapacity &lt; 0) &#123;</div><div class="line">            if (minimumCapacity &lt; 0) // overflow</div><div class="line">                throw new OutOfMemoryError();</div><div class="line">            newCapacity = Integer.MAX_VALUE;</div><div class="line">        &#125;</div><div class="line">        value = Arrays.copyOf(value, newCapacity);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line"> // String类</div><div class="line">     public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123;</div><div class="line">        if (srcBegin &lt; 0) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcBegin);</div><div class="line">        &#125;</div><div class="line">        if (srcEnd &gt; value.length) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd);</div><div class="line">        &#125;</div><div class="line">        if (srcBegin &gt; srcEnd) &#123;</div><div class="line">            throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);</div><div class="line">        &#125;</div><div class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>String源码学习</title>
    <link href="http://jianwl.com/2018/04/01/String%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/04/01/String源码学习/</id>
    <published>2018-04-01T04:32:28.000Z</published>
    <updated>2018-04-01T05:59:09.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>从一段代码说起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void stringTest()&#123;</div><div class="line">    String str1 = &quot;a&quot; + &quot;b&quot; + 1;</div><div class="line">    String str2 = &quot;ab1&quot;;</div><div class="line">    System.out.println(str1 == str2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大家猜猜结果如何？如果你的结论是<code>true</code>，再来一段代码；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void stringTest2()&#123;</div><div class="line">    String str1 = new String(&quot;ab1&quot;);</div><div class="line">    String str2 = &quot;ab1&quot;;</div><div class="line">    System.out.println(str1 == str2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如何呢？正确答案是false。</p>
<p>让我们看看经过编译器编译后的代码如何：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 第一段代码</div><div class="line">    public static void stringTest()&#123;</div><div class="line">        String str1 = &quot;ab1&quot;;</div><div class="line">        String str2 = &quot;ab1&quot;;</div><div class="line">        System.out.println(str1 == str2);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">// 第二段代码  </div><div class="line">    public static void stringTest2()&#123;</div><div class="line">        String str1 = new String(&quot;ab1&quot;);</div><div class="line">        String str2 = &quot;ab1&quot;;</div><div class="line">        System.out.println(str1 == str2);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>也就是说第一段代码经过了编译器优化，原因是编译器发现”a”+”b”+1和”ab1”的效果一样，都是不可变量组成，但是为什么他们的内存地址会相同呢？如果你对此还有兴趣，那就一起来看看String类源码；</p>
<h3 id="1-String类"><a href="#1-String类" class="headerlink" title="1 String类"></a>1 String类</h3><p>String类被<code>final</code>所修饰，也就是说String对象是不可变类。String类实现了<code>Serializable</code>、<code>Comparable&lt;String&gt;</code>、<code>CharSequence</code>接口。</p>
<p>Comparable接口有compareTo(String s)方法，CharSequence接口有lengh()、chatAt(int index)、subSequence(int start,int end)方法。</p>
<h3 id="2-String属性"><a href="#2-String属性" class="headerlink" title="2 String属性"></a>2 String属性</h3><p>String类中包含一个不可变的char数组来存放字符串，一个int型的变量hash用来存放计算后的哈希值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/** The value is used for character storage. */</div><div class="line">private final char value[];</div><div class="line"></div><div class="line">/** Cache the hash code for the string */</div><div class="line">private int hash; // Default to 0</div></pre></td></tr></table></figure>
<h3 id="3-String构造函数"><a href="#3-String构造函数" class="headerlink" title="3 String构造函数"></a>3 String构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//不含参数的构造函数，一般没什么用，因为value是不可变量</div><div class="line">    public String() &#123;</div><div class="line">        this.value = &quot;&quot;.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> </div><div class="line">//参数为String类型</div><div class="line">    public String(String original) &#123;</div><div class="line">        this.value = original.value;</div><div class="line">        this.hash = original.hash;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// 声明编码类型    </div><div class="line">    public String(byte bytes[], Charset charset) &#123;</div><div class="line">        this(bytes, 0, bytes.length, charset);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">//参数为char数组，使用java.utils包中的Arrays类复制</div><div class="line">    public String(char value[]) &#123;</div><div class="line">        this.value = Arrays.copyOf(value, value.length);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">//从bytes数组中的offset位置开始，将长度为length的字节，以charsetName格式编码，拷贝到value</div><div class="line">    public String(byte bytes[], int offset, int length, Charset charset) &#123;</div><div class="line">        if (charset == null)</div><div class="line">            throw new NullPointerException(&quot;charset&quot;);</div><div class="line">        checkBounds(bytes, offset, length);</div><div class="line">        this.value =  StringCoding.decode(charset, bytes, offset, length);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="4-String-常用方法"><a href="#4-String-常用方法" class="headerlink" title="4 String 常用方法"></a>4 String 常用方法</h3><h4 id="1-equals"><a href="#1-equals" class="headerlink" title="1) equals()"></a>1) equals()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object anObject) &#123;</div><div class="line">    // 如果引用的是同一个对象，则为真</div><div class="line">    if (this == anObject) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (anObject instanceof String) &#123;</div><div class="line">        String anotherString = (String)anObject;</div><div class="line">        int n = value.length;</div><div class="line">        if (n == anotherString.value.length) &#123;</div><div class="line">            char v1[] = value;</div><div class="line">            char v2[] = anotherString.value;</div><div class="line">            int i = 0;</div><div class="line">            // 比较每一个字符是否相等</div><div class="line">            while (n-- != 0) &#123;</div><div class="line">                if (v1[i] != v2[i])</div><div class="line">                    return false;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>equals方法经常用得到，它用来判断两个对象内容是否相等，String对象判断流程：</p>
<blockquote>
<p>内存地址相同，则为真</p>
<p>如果对象类型不是String类型，则为假；否则继续判断</p>
<p>如果对象长度不相等，则为假，否则继续判断。</p>
<p>从后往前，判断String类中的char数组value的单个字符是否相等，有不相等则为假，如果一直相等直到一个数，则返回真。</p>
<p>由此可以看出，如果对两个超长的字符进行比较还是比较费时间的。</p>
</blockquote>
<h4 id="2-compareTo"><a href="#2-compareTo" class="headerlink" title="2) compareTo"></a>2) compareTo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public int compareTo(String anotherString) &#123;</div><div class="line">    // 自身字符串的长度</div><div class="line">    int len1 = value.length;</div><div class="line"></div><div class="line">    // 比较字符串的长度</div><div class="line">    int len2 = anotherString.value.length;</div><div class="line"></div><div class="line">    // 获取两个字符串的最小长度</div><div class="line">    int lim = Math.min(len1, len2);</div><div class="line">    char v1[] = value;</div><div class="line">    char v2[] = anotherString.value;</div><div class="line"></div><div class="line">    // 从头往后遍历，如果相同位置的字符不相等，则进行比较字符大小；</div><div class="line">    int k = 0;</div><div class="line">    while (k &lt; lim) &#123;</div><div class="line">        char c1 = v1[k];</div><div class="line">        char c2 = v2[k];</div><div class="line">        if (c1 != c2) &#123;</div><div class="line">            return c1 - c2;</div><div class="line">        &#125;</div><div class="line">        k++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 如果前面都相等，就等于当前字符长度 减去 比较字符长度</div><div class="line">    return len1 - len2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法写的很巧妙，先从0开始判断字符大小，如果两个对象能比较字符的地方比较完了还相等，就直接返回自身长度减比较对象长度，如果两个字符串长度相同，则返回0，巧妙地判断了三种情况。</p>
<h4 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3) hashCode()"></a>3) hashCode()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public int hashCode() &#123;</div><div class="line">    int h = hash;</div><div class="line">    if (h == 0 &amp;&amp; value.length &gt; 0) &#123;</div><div class="line">        char val[] = value;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</div><div class="line">            h = 31 * h + val[i];</div><div class="line">        &#125;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div><div class="line">    return h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>String类重写了hashCode方法，Object中的hashCode方法是一个Native调动。String类的hash采用多项式计算。不同的字符串，hashcode是有可能相同的。</p>
<h4 id="4-intern"><a href="#4-intern" class="headerlink" title="4) intern()"></a>4) intern()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public native String intern();</div></pre></td></tr></table></figure>
<p>intern方法是Native调用，它的作用是在方法区中的常量池里通过equals方法寻找字面值相等的对象，如果没有找到则在常量池中开辟一片空间存放字符串并返回字符串引用，否则直接返回常量池中已存在String对象的引用。</p>
<p>将引言中第二段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// String a = new String(&quot;ab1&quot;);</div><div class="line">// 改为</div><div class="line">String a = new String(&quot;ab1&quot;).intern();</div></pre></td></tr></table></figure>
<p>则结果为<code>true</code>，原因在于a所指向的地址来源于常量池，而b所指向的字符串默认会调用这个方法，所以a和b都指向同一个地址。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;从一段代码说起&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hashtable源码学习</title>
    <link href="http://jianwl.com/2018/03/29/Hashtable%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/29/Hashtable源码学习/</id>
    <published>2018-03-28T22:55:24.000Z</published>
    <updated>2018-03-29T23:37:47.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段"><a href="#常用方法-amp-字段" class="headerlink" title="常用方法 &amp; 字段"></a>常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-30/94194717.jpg" alt=""></p>
<p>Hashtable底层是一个数组 + 链表的数据结构，与HashMap的区别在于，其是线程安全、插入的键值对均不能为空、插入元素时，若发生哈希碰撞，Hashtable是从头结点插入，而HashMap1.8版本是从尾部插入；</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><ol>
<li>新增元素时，如何保证线程安全, put()</li>
<li>扩容与数据迁移机制，rehash()</li>
</ol>
<h4 id="1-新增元素时，如何保证线程安全"><a href="#1-新增元素时，如何保证线程安全" class="headerlink" title="1) 新增元素时，如何保证线程安全"></a>1) 新增元素时，如何保证线程安全</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public synchronized V put(K key, V value) &#123;</div><div class="line">    // Make sure the value is not null</div><div class="line">    if (value == null) &#123;</div><div class="line">        throw new NullPointerException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Makes sure the key is not already in the hashtable.</div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    int hash = key.hashCode();</div><div class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</div><div class="line">    for(; entry != null ; entry = entry.next) &#123;</div><div class="line">        if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</div><div class="line">            V old = entry.value;</div><div class="line">            entry.value = value;</div><div class="line">            return old;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addEntry(hash, key, value, index);</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void addEntry(int hash, K key, V value, int index) &#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    if (count &gt;= threshold) &#123;</div><div class="line">        // Rehash the table if the threshold is exceeded</div><div class="line">        rehash();</div><div class="line"></div><div class="line">        tab = table;</div><div class="line">        hash = key.hashCode();</div><div class="line">        index = (hash &amp; 0x7FFFFFFF) % tab.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Creates the new entry.</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</div><div class="line">    tab[index] = new Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    count++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第1行：<code>synchronized</code>关键字用于普通方法时，获取到对象实例的锁才能执行，所以在多线程环境下是线程安全的；</p>
<p>第3 ~ 9行：保证插入的键值对，key和value均不为空，否则抛出空指针异常；</p>
<p>第10行：获取插入元素，在数组中的索引位置；</p>
<p>第11 ~ 19行：获取索引位置的元素(元素为链表头结点)，遍历链表，若新增元素的key，在链表中已存在，则替换键值；</p>
<p>第28 ~ 36行: 如果当前的容量(count) 大于 扩容阈值(threshold),则进行扩容（rehash），得到插入元素在扩容后数组的索引位置；</p>
<p>第39 ~ 42行：获取索引位置的元素(链表头结点)，在头结点之前插入元素，容量 + 1；</p>
<h4 id="2-扩容与数据迁移机制"><a href="#2-扩容与数据迁移机制" class="headerlink" title="2) 扩容与数据迁移机制"></a>2) 扩容与数据迁移机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"> @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line"> protected void rehash() &#123;</div><div class="line"> 	  // ① 当前数组容量</div><div class="line">     int oldCapacity = table.length;</div><div class="line">     Entry&lt;?,?&gt;[] oldMap = table;</div><div class="line"></div><div class="line">     // overflow-conscious code ② 数组扩容为原数组的2倍 + 1</div><div class="line">     int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</div><div class="line">     // ③ 判断新容量是否溢出</div><div class="line">     if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; </div><div class="line">         if (oldCapacity == MAX_ARRAY_SIZE)</div><div class="line">             // Keep running with MAX_ARRAY_SIZE buckets</div><div class="line">             return;</div><div class="line">         newCapacity = MAX_ARRAY_SIZE;</div><div class="line">     &#125;</div><div class="line">     Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];</div><div class="line"></div><div class="line">     modCount++;</div><div class="line">     // ④ 计算出新的扩容阈值</div><div class="line">     threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</div><div class="line">     table = newMap;</div><div class="line">// ⑤ 遍历数组，将数据迁移到新数组中</div><div class="line">     for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;</div><div class="line">         for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123;</div><div class="line">             Entry&lt;K,V&gt; e = old;</div><div class="line">             old = old.next;</div><div class="line"></div><div class="line">             int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</div><div class="line">             e.next = (Entry&lt;K,V&gt;)newMap[index];</div><div class="line">             newMap[index] = e;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>第23 ~ 31行：从后往前遍历数组，得到链表首结点；若首结点不为空，继续遍历链表，将链表中的元素迁移到新容器，发生哈希碰撞时，采用从头结点插入的方式；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HashSet源码学习</title>
    <link href="http://jianwl.com/2018/03/27/HashSet%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/27/HashSet源码学习/</id>
    <published>2018-03-27T00:52:55.000Z</published>
    <updated>2018-03-28T22:51:10.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-29/4636358.jpg" alt=""></p>
<p>HashSet是以HashMap为基础类封装的对象，在新增元素E时，往HashMap中插入(E,Object)的键值对，因为在HashMap中Key是不存在重复的，所以保证了HashSet的唯一性。</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><ol>
<li>如何保证唯一性；</li>
</ol>
<h4 id="如何保证唯一性"><a href="#如何保证唯一性" class="headerlink" title="如何保证唯一性"></a>如何保证唯一性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public HashSet() &#123;</div><div class="line">    map = new HashMap&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public boolean add(E e) &#123;</div><div class="line">    return map.put(e, PRESENT)==null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化HashSet时，会初始化HashMap对象；新增元素时，通过HashMap新增(E,Object)的键值对，从而保证了Key的唯一性；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法&quot;&gt;&lt;a href=&quot;#常用方法&quot; class=&quot;headerlink&quot; title=&quot;常用方法&quot;&gt;&lt;/a&gt;常用方法&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.clouddn.com/18-3-29/4636358.jpg
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码学习</title>
    <link href="http://jianwl.com/2018/03/22/HashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/22/HashMap源码学习/</id>
    <published>2018-03-22T12:39:33.000Z</published>
    <updated>2018-03-27T00:45:45.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-常用方法-amp-字段"><a href="#1-常用方法-amp-字段" class="headerlink" title="1. 常用方法 &amp; 字段"></a>1. 常用方法 &amp; 字段</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-22/24207782.jpg" alt=""></p>
<p>JDK1.8之前，HashMap是一个数组 + 链表的数据结构；通过key的hash值与数组的长度取余，得到该键值对在数组中的索引位。如果该位置上，没有其他元素，就直接放进去；如果该位置上已经有数据了(不同的key值，hash值可能一样)，则通过链表的方式，将元素放到前一个元素的后面。如下图所示：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-22/22584621.jpg" alt="图1-1"></p>
<p>JDK1.8，引入了红黑树，当链表的长度大于等于8时，会将链表转化为红黑树，红黑树的查找时间复杂度是o(lgn)，极大加快了查询的效率。</p>
<h3 id="2-提问"><a href="#2-提问" class="headerlink" title="2. 提问"></a>2. 提问</h3><ol>
<li>HashMap是如何实现扩容的，resize();</li>
<li>为什么HashMap的容量要保持为2的幂次方;</li>
<li>HashMap如何实现新增一个键值对,put(K,V);</li>
<li>HashMap为什么是线程不安全的？</li>
</ol>
<h4 id="1）HashMap是如何实现扩容的"><a href="#1）HashMap是如何实现扩容的" class="headerlink" title="1）HashMap是如何实现扩容的"></a>1）HashMap是如何实现扩容的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</div><div class="line">    int oldThr = threshold;</div><div class="line">    int newCap, newThr = 0;</div><div class="line">    if (oldCap &gt; 0) &#123;</div><div class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 超过最大值不再扩容，随它碰撞去了;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            return oldTab;</div><div class="line">        &#125;</div><div class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 如果当前容量大于16，且扩容2倍之后小于最大整数，则将阈值扩大2倍；</div><div class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</div><div class="line">    &#125;</div><div class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold 如果当前阈值大于0，则新的容量为当前阈值；</div><div class="line">        newCap = oldThr;</div><div class="line">    else &#123;               // zero initial threshold signifies using defaults</div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    if (newThr == 0) &#123;</div><div class="line">        float ft = (float)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</div><div class="line">                  (int)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    if (oldTab != null) &#123;</div><div class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            if ((e = oldTab[j]) != null) &#123;</div><div class="line">                oldTab[j] = null;</div><div class="line">                if (e.next == null)</div><div class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</div><div class="line">                else if (e instanceof TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</div><div class="line">                else &#123; // preserve order</div><div class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</div><div class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        if ((e.hash &amp; oldCap) == 0) &#123; // 原索引</div><div class="line">                            if (loTail == null)</div><div class="line">                                loHead = e;</div><div class="line">                            else</div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        else &#123; // 原索引 + oldCap</div><div class="line">                            if (hiTail == null)</div><div class="line">                                hiHead = e;</div><div class="line">                            else</div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; while ((e = next) != null);</div><div class="line">                    if (loTail != null) &#123;</div><div class="line">                        loTail.next = null;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    if (hiTail != null) &#123;</div><div class="line">                        hiTail.next = null;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第2 ~ 25行：这十几行代码描述的是扩容时，如何确定新的容量和阈值；</p>
<table>
<thead>
<tr>
<th style="text-align:center">当前容量oldCap</th>
<th style="text-align:center">扩容后容量newCap</th>
<th style="text-align:center">扩容后阈值newThre</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">oldCap <code>&gt;=</code> Integer.MAX_VALUE</td>
<td style="text-align:center">oldCap</td>
<td style="text-align:center">Integer.MAX_VALUE</td>
</tr>
<tr>
<td style="text-align:center">16 <code>&lt;</code> oldCap <code>&lt;</code> Integer.MAX_VALUE / 2</td>
<td style="text-align:center">oldCap <code>*</code> 2</td>
<td style="text-align:center">oldThre <code>*</code> 2</td>
</tr>
<tr>
<td style="text-align:center">0 <code>&lt;</code> oldCap <code>&lt;=</code>16</td>
<td style="text-align:center">oldThre</td>
<td style="text-align:center">newCap <code>*</code> 0.75</td>
</tr>
<tr>
<td style="text-align:center">oldCap == 0</td>
<td style="text-align:center">16</td>
<td style="text-align:center">16 <code>*</code> 0.75 = 12</td>
</tr>
</tbody>
</table>
<p>扩容时有4种场景，① 当前容量大于最大整数时，此时不再扩容，随他进行碰撞；② 当前容量大于16且扩容后的容量小于最大整数时，新的容量和阈值都扩大2倍；③ 当容量小于等于16时，这种场景出现在：指定HashMap的初始容量，此时新容量等于当前阈值，新阈值等于新容量 <code>*</code> 加载因子。④ 当前容量为0时，默认初始化容量为16，阈值为12；</p>
<p>第28 ~ 72行：扩容之后，需要将原有的数据迁移到扩容后的结构中；分为三种场景：① 同一个哈希槽位上，只有一个元素；② 同一个哈希槽位上，不止一个元素但小于8个元素(这几个元素，已链表的结构存在)；③ 同一个哈希槽位上，超过8个元素，(此时为这些元素，已红黑树的结构存在)；这里我们重点分析前两种情况，对于红黑树，等后续研究透了，再来分析；</p>
<p>场景①分析：</p>
<p>对应代码为35 ~ 36行：很简单，如果当前哈希槽位只有一个元素，那么将当前元素的哈希值 取余 新数组容量，获取新数组中的索引位置即可；<code>e.hash &amp; (newcap - 1)</code> 等价于 <code>e.hash % newcap</code></p>
<p>场景②分析：</p>
<p>对应代码为39 ~ 68行：同一个哈希槽位上存在多个元素(小于8)，这些元素可分为两种情况：1、 元素的哈希值 &amp; oldCap == 0，其索引位置为原索引；2、元素的哈希值 &amp; oldCap != 0,其索引位置为原索引 + oldCap；举个例子说明下：oldCap = 8, newCap = 16;那么哈希值为15时，其在新数组中的位置为：7 + 8 = 15；哈希值为7时，在新数组中的位置为7跟原来的位置一样。</p>
<h4 id="2-HashMap的容量如何做到保持为2的幂次方"><a href="#2-HashMap的容量如何做到保持为2的幂次方" class="headerlink" title="2) HashMap的容量如何做到保持为2的幂次方"></a>2) HashMap的容量如何做到保持为2的幂次方</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</div><div class="line">    if (initialCapacity &lt; 0)</div><div class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</div><div class="line">                                           initialCapacity);</div><div class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</div><div class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</div><div class="line">                                           loadFactor);</div><div class="line">    this.loadFactor = loadFactor;</div><div class="line">    this.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 返回大于等于当前值，最接近2的n次方的数据；</div><div class="line"> * Returns a power of two size for the given target capacity.</div><div class="line"> */</div><div class="line">static final int tableSizeFor(int cap) &#123;</div><div class="line">    int n = cap - 1; // 为了避免刚好是2的n次方的情况，这样会返回 2 的n+1次方，跟预期不符合；</div><div class="line">    n |= n &gt;&gt;&gt; 1; // 前2位都是1；</div><div class="line">    n |= n &gt;&gt;&gt; 2; // 前4位都是1；</div><div class="line">    n |= n &gt;&gt;&gt; 4; // 前8位都是1</div><div class="line">    n |= n &gt;&gt;&gt; 8; // 前16位都是1；</div><div class="line">    n |= n &gt;&gt;&gt; 16;// 前32位都是1；</div><div class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化容量有两种方式：① newcap = 默认值16，loadfactor = 默认值0.75f; newthreshold = newcap <code>*</code> loadfactor; ② threshold = 最接近2的幂次方的初始化容量；之后在扩容阶段得到：newcap = threshold; newthreshold = loadfactor <code>*</code> newcap;</p>
<p>这里我们重点分析场景2：</p>
<p>核心代码为18 ~ 25行，初始化容量n，将 n - 1后的值进行移位或操作，可以保证从(n - 1)的二进制值，从高位1开始之后的二进制数都是1。这里举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">若初始化容量为6：</div><div class="line">n - 1 = 5 // 101</div><div class="line">n |= n &gt;&gt;&gt; 1 // 101 | 011 = 111 (保证1 ~ 2位，位移数都是1)</div><div class="line">n |= n &gt;&gt;&gt; 2 // 111 | 001 = 111 (保证3 ~ 4位，位移数都是1)</div><div class="line">n |= n &gt;&gt;&gt; 4 // 111 | 000 = 111 (保证5 ~ 8位，位移数都是1)</div><div class="line">n |= n &gt;&gt;&gt; 8 // 111 | 000 = 111 (保证9 ~ 16位，位移数都是1)</div><div class="line">n |= n &gt;&gt;&gt; 16 // 111 | 000 = 111 (保证17 ~ 32位，位移数都是1)</div><div class="line">最后将1加回去：</div><div class="line">n = n + 1 // 8,得到大于6，的最小2的幂次方的数值为2的3次方；</div></pre></td></tr></table></figure>
<h5 id="容量保持2的幂次方，有什么好处呢"><a href="#容量保持2的幂次方，有什么好处呢" class="headerlink" title="容量保持2的幂次方，有什么好处呢?"></a>容量保持2的幂次方，有什么好处呢?</h5><p>主要是跟HashMap的存储方式有关；这里简单介绍下：</p>
<p>1、hash(key)，得到插入元素的Key的哈希值;</p>
<p>2、hash(key) &amp; (n -1) , 得到元素在数组中的索引值；</p>
<p>这里重点说下步骤2，hash(key) &amp; (n -1)等价于 hash(key) % n,这个等价是有条件的，n必须是为n的幂次方。否则条件不成立；这里举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// n非2的幂次方</div><div class="line">hash(key): 11, n: 6</div><div class="line"></div><div class="line">hash(key) &amp; (n - 1) // 1011 &amp; 101 = 0001 明显不等于 11 % 6 = 5</div><div class="line"></div><div class="line">// n为2的幂次方</div><div class="line">hash(key): 11, n: 8</div><div class="line"></div><div class="line">hash(key) &amp; (n -1) // 1011 &amp; 111 = 0011 等于 11 % 8 = 3</div></pre></td></tr></table></figure>
<p>这就是为什么要保持容量为2的幂次方的原因。那么有人要问了，为什么要通过与操作进行求余，为什么不通过%操作符操作呢？因为与操作的执行效率高；</p>
<h4 id="3）HashMap如何实现新增一个键值对"><a href="#3）HashMap如何实现新增一个键值对" class="headerlink" title="3）HashMap如何实现新增一个键值对"></a>3）HashMap如何实现新增一个键值对</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">    return putVal(hash(key), key, value, false, true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">               boolean evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">    if ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">        n = (tab = resize()).length; // tab为空，初始化tab；</div><div class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null) // 没有hash冲突</div><div class="line">        tab[i] = newNode(hash, key, value, null); // 在指定哈希槽插入元素；</div><div class="line">    else &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        if (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // hash一直；key一致；覆盖元素；</div><div class="line">            e = p;</div><div class="line">        else if (p instanceof TreeNode) // 在指定hash位取出的元素是红黑树，往红黑树中插入元素；</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 红黑树插入元素</div><div class="line">        else &#123;</div><div class="line">            for (int binCount = 0; ; ++binCount) &#123;</div><div class="line">                if ((e = p.next) == null) &#123; // 首节点后 + 数据</div><div class="line">                    p.next = newNode(hash, key, value, null);</div><div class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 链表长度大于等于8</div><div class="line">                        treeifyBin(tab, hash); // 转化为红黑树</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 如果key值相当直接退出循环;</div><div class="line">                    break;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (e != null) &#123; // existing mapping for key</div><div class="line">            V oldValue = e.value;</div><div class="line">            if (!onlyIfAbsent || oldValue == null)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    if (++size &gt; threshold)</div><div class="line">        resize(); // 扩容</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第8 ~ 9行：当table的容量为空时，进行扩容；</p>
<p>第10 ~ 11行：获取新增元素在数组中的索引位置，若该位置上没有其他元素，则插入元素；</p>
<p>第12 ~ 40行: 这里着重解释，当存在hash冲突时(即新增元素的在数组中的索引存在其他元素)，如何解决； </p>
<p>第14 ~ 16行：当前元素与新增元素，key完全一样时，获取当前元素值；</p>
<p>第17 ~ 18行：当新增元素索引位，元素结构为红黑树时，往红黑树中插入元素；</p>
<p>第19 ~ 40行: 这里描述的是新增元素索引位，元素的结构为链表；</p>
<p>第20 ~ 26行：死循环，如果找到链表的尾部节点，则在链表后新增元素；判断链表长度 <code>&gt;=</code> 8，若是，则将链表转为红黑树；</p>
<p>第27 ~ 29行：若key与新增元素key相同，则直接退出死循环；</p>
<p>第30行：节点往后移动一位；</p>
<p>第33 ~ 38行：如何存在key相同的元素，是否需要覆盖键值；</p>
<p>第42 ~ 43行：如果元素长度大于扩容阈值，则进行扩容；</p>
<p>具体实现流程图如下：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-27/49558429.jpg" alt=""></p>
<h4 id="4）HashMap为什么是线程不安全的"><a href="#4）HashMap为什么是线程不安全的" class="headerlink" title="4）HashMap为什么是线程不安全的"></a>4）HashMap为什么是线程不安全的</h4><p>JDK1.7在并发情况下，在扩容时会造成环链问题，导致死循环，在JDK1.8版本中已经不存在了；但HashMap依旧不适用于多线程，HashMap的设计目标是简洁高效，没有采取任何措施保障put、remove操作的多线程安全；且在并发环境下，无法保障内存的可见性; </p>
<p>目前这个解释的比较含糊，后续给出具体实例，说明其线程不安全的情况；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-常用方法-amp-字段&quot;&gt;&lt;a href=&quot;#1-常用方法-amp-字段&quot; class=&quot;headerlink&quot; title=&quot;1. 常用方法 &amp;amp; 字段&quot;&gt;&lt;/a&gt;1. 常用方法 &amp;amp; 字段&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList源码学习</title>
    <link href="http://jianwl.com/2018/03/17/LinkedList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/17/LinkedList源码学习/</id>
    <published>2018-03-17T04:36:38.000Z</published>
    <updated>2018-03-18T05:22:34.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用方法-amp-字段梳理"><a href="#常用方法-amp-字段梳理" class="headerlink" title="常用方法 &amp; 字段梳理"></a>常用方法 &amp; 字段梳理</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-17/8479145.jpg" alt=""></p>
<p>LinkedList的底层数据结构是链表，链表是由许多个节点连接而成，每个节点包含三个部分,如图所示：<img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-18/30835149.jpg" alt=""></p>
<p>pre、next分别存放上一个节点的地址和下一个节点的地址，data存放该节点的数据。</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><ol>
<li>如何新增数据, add(E e)</li>
<li>如何在指定位置新增数据,add(int index,E e)</li>
<li>如何获取指定元素的位置，indexOf(Object o)</li>
<li>如何清空整个链表，clear()</li>
</ol>
<h4 id="1-如何新增数据"><a href="#1-如何新增数据" class="headerlink" title="1) 如何新增数据"></a>1) 如何新增数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line">    linkLast(e);</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void linkLast(E e) &#123;</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line">    last = newNode;</div><div class="line">    if (l == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static class Node&lt;E&gt; &#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node&lt;E&gt; prev;</div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        this.item = element;</div><div class="line">        this.next = next;</div><div class="line">        this.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第7行：首先获取链表当前的尾节点l；</p>
<p>第8行：初始化新增节点newNode，包含上一个节点位置、节点数据、下一个节点位置；</p>
<p>第9行：设置新的尾节点为新增节点,last = newNode</p>
<p>第10 ~ 13行：尾节点l为空，那么设置首节点为新节点；反之，设置尾节点l的下一个节点位置为newNode; </p>
<p>第7行 ~ 第13行描述用图示表示：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-18/1333450.jpg" alt=""></p>
<p>第18 ~ 27行：一个节点包括三部分：当前节点数据、上一个节点地址、下一个节点地址</p>
<h4 id="2-如何在指定位置新增数据"><a href="#2-如何在指定位置新增数据" class="headerlink" title="2) 如何在指定位置新增数据"></a>2) 如何在指定位置新增数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public void add(int index, E element) &#123;</div><div class="line">    checkPositionIndex(index);</div><div class="line"></div><div class="line">    if (index == size)</div><div class="line">        linkLast(element);</div><div class="line">    else</div><div class="line">        linkBefore(element, node(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void linkLast(E e) &#123;</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line">    last = newNode;</div><div class="line">    if (l == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Node&lt;E&gt; node(int index) &#123;</div><div class="line">    // assert isElementIndex(index);</div><div class="line"></div><div class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        for (int i = 0; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        return x;</div><div class="line">    &#125; else &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        for (int i = size - 1; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</div><div class="line">    // assert succ != null;</div><div class="line">    final Node&lt;E&gt; pred = succ.prev;</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</div><div class="line">    succ.prev = newNode;</div><div class="line">    if (pred == null)</div><div class="line">        first = newNode;</div><div class="line">    else</div><div class="line">        pred.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第2行：检查新增的位置是否越界了(位置范围是：[0,size])</p>
<p>第4 ~ 5行：新增的位置为链表长度(size),链表尾节点所在位置为：(size -1)，所以在该位置(size位置)新增节点，类似在尾节点新增节点。上一个功能点已描述，这里就不赘述了。</p>
<p>第22 ~ 36行：二分法，判断新增位置处于size的左部分([0,size/2])还是右部分((size/2,size -1])，左部分，从首节点，头往后找；右部分，从尾节点，从后往前找。</p>
<p>第38 ~ 48行：新增位置的原来节点为：succ;如果succ的上一个节点为null，则说明新增位置为首节点；反之，新增位置为中间节点。首节点位置新增时，初始化新增节点，并将原首节点位置的上个节点地址设置为新增节点；中间节点位置新增时，初始化新增节点，并将上一个节点的下一个节点位置，设置为新增节点。</p>
<p>第38 ~ 48行图示如下：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-18/17702167.jpg" alt=""></p>
<h4 id="3-如何获取指定元素的位置"><a href="#3-如何获取指定元素的位置" class="headerlink" title="3) 如何获取指定元素的位置"></a>3) 如何获取指定元素的位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public int indexOf(Object o) &#123;</div><div class="line">    int index = 0;</div><div class="line">    if (o == null) &#123;</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (x.item == null)</div><div class="line">                return index;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (o.equals(x.item))</div><div class="line">                return index;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从首节点开始遍历，寻找的对象分两种：空对象和非空对象；若节点值等于寻找的对象，返回游标值；</p>
<h4 id="4）如何清空整个链表"><a href="#4）如何清空整个链表" class="headerlink" title="4）如何清空整个链表"></a>4）如何清空整个链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void clear() &#123;</div><div class="line">    // Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</div><div class="line">    // - helps a generational GC if the discarded nodes inhabit</div><div class="line">    //   more than one generation</div><div class="line">    // - is sure to free memory even if there is a reachable Iterator</div><div class="line">    for (Node&lt;E&gt; x = first; x != null; ) &#123;</div><div class="line">        Node&lt;E&gt; next = x.next;</div><div class="line">        x.item = null;</div><div class="line">        x.next = null;</div><div class="line">        x.prev = null;</div><div class="line">        x = next;</div><div class="line">    &#125;</div><div class="line">    first = last = null;</div><div class="line">    size = 0;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>遍历链表，将每一个节点的数据清空，最后将头结点和尾节点的数据清空，链表长度设置为0；</p>
<p>刚开始有个疑问，清空整个链表了，首、尾两节点已经为空了，为什么在第13行代码还需要再次清空呢？其实呢，首节点和尾节点单独存到变量里，所以在清空链表的时候，first、last节点都是有数据的，所以还需要单独清空。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用方法-amp-字段梳理&quot;&gt;&lt;a href=&quot;#常用方法-amp-字段梳理&quot; class=&quot;headerlink&quot; title=&quot;常用方法 &amp;amp; 字段梳理&quot;&gt;&lt;/a&gt;常用方法 &amp;amp; 字段梳理&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码学习</title>
    <link href="http://jianwl.com/2018/03/15/ArrayList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianwl.com/2018/03/15/ArrayList源码学习/</id>
    <published>2018-03-15T15:05:33.000Z</published>
    <updated>2018-03-17T03:44:38.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-常用方法-amp-字段梳理"><a href="#1-常用方法-amp-字段梳理" class="headerlink" title="1. 常用方法 &amp; 字段梳理"></a>1. 常用方法 &amp; 字段梳理</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-15/41421167.jpg" alt=""></p>
<p>ArrayList底层的数据结构是数组，往列表中插入数据时，首先会检查列表的容量是否充足，当容量不够时，会自动扩容为当前容量的3倍，本节我们会带着问题，学习ArrayList的实现原理。</p>
<h3 id="2-提出问题"><a href="#2-提出问题" class="headerlink" title="2. 提出问题"></a>2. 提出问题</h3><ol>
<li>add(E)，新增元素时，如何实现自动扩容；</li>
<li>add(index,E)如何实现在指定位置插入元素，指定位置之后的元素如何处理？</li>
<li>clear(), 避免内存溢出，在移除元素时，我们应该注意些什么？</li>
</ol>
<h4 id="1）新增元素"><a href="#1）新增元素" class="headerlink" title="1）新增元素"></a>1）新增元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"># 新增元素入口</div><div class="line">   public boolean add(E e) &#123;</div><div class="line">       ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div class="line">       elementData[size++] = e;</div><div class="line">       return true;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   private void ensureCapacityInternal(int minCapacity) &#123;</div><div class="line">       if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       ensureExplicitCapacity(minCapacity);</div><div class="line">   &#125;</div><div class="line">       </div><div class="line">   private void ensureExplicitCapacity(int minCapacity) &#123;</div><div class="line">       modCount++;</div><div class="line"></div><div class="line">       // overflow-conscious code</div><div class="line">       if (minCapacity - elementData.length &gt; 0)</div><div class="line">           grow(minCapacity);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   private void grow(int minCapacity) &#123;</div><div class="line">       // overflow-conscious code</div><div class="line">       int oldCapacity = elementData.length;</div><div class="line">       int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 为原来的3倍；</div><div class="line">       if (newCapacity - minCapacity &lt; 0)</div><div class="line">           newCapacity = minCapacity;</div><div class="line">       if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</div><div class="line">           newCapacity = hugeCapacity(minCapacity);</div><div class="line">       // minCapacity is usually close to size, so this is a win:</div><div class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   private static int hugeCapacity(int minCapacity) &#123;</div><div class="line">       if (minCapacity &lt; 0) // overflow</div><div class="line">           throw new OutOfMemoryError();</div><div class="line">       return (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">           Integer.MAX_VALUE :</div><div class="line">           MAX_ARRAY_SIZE;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>第3 ~ 4行：新增一个元素之前，需要先确保元素加进去之后，容量是否会溢出;如果容量够用，则往数组中插入数据；</p>
<p>第9 ~ 11行：如果是一个空列表，当前最小的容量(size + 1)为默认值10；</p>
<p>第 20 ~ 21行：如果新增元素后，元素的数量(size + 1) <strong>大于</strong> 数组的长度(elementData.length),则扩容；</p>
<p>第26 ~ 33行：扩容的逻辑，将列表的容量扩大为原来的3倍即(3 elementData.length),如果扩容后的容量 <strong>仍旧小于</strong> 元素的数量(size + 1),则将列表容量设置为(size + 1)，之后判断扩容后的容量是否大于「最大的整数 - 8」，如果大于，则等于最大整数；最后将原来的数组迁移到扩容后的数组；</p>
<p>第37 ~ 38行：为了防止当容量大于整数最大值即(大于Integer.MAX_VALUE)，此时会出现整型数据溢出，为负值，此时报内存溢出异常。</p>
<h4 id="2-指定位置新增元素"><a href="#2-指定位置新增元素" class="headerlink" title="2) 指定位置新增元素"></a>2) 指定位置新增元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void add(int index, E element) &#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div class="line">    System.arraycopy(elementData, index, elementData, index + 1,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void rangeCheckForAdd(int index) &#123;</div><div class="line">    if (index &gt; size || index &lt; 0)</div><div class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第12 ~ 13行：判断索引位置会不会越界即(大于数组大小和小于0)；</p>
<p>第 4 行：新增元素前，进行容量预估，容量不足时则扩容。上一个模块已描述，这里就不赘述了；</p>
<p>第 5 行：用图示的方式来说明，如果往元素2的位置插入元素，需要将元素2及之后的元素均向后挪动一位，这行代码就是执行这样的功能。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-17/23285668.jpg" alt=""></p>
<p>第7 ~ 8行：把元素放到数组中的指定位置，同时将列表的长度加1。</p>
<h4 id="3）清空数组"><a href="#3）清空数组" class="headerlink" title="3）清空数组"></a>3）清空数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void clear() &#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    // clear to let GC do its work</div><div class="line">    for (int i = 0; i &lt; size; i++)</div><div class="line">        elementData[i] = null;</div><div class="line"></div><div class="line">    size = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第5 ~ 6行：遍历数组中的每一个元素，将其设置为null，方便后续GC回收内存。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-常用方法-amp-字段梳理&quot;&gt;&lt;a href=&quot;#1-常用方法-amp-字段梳理&quot; class=&quot;headerlink&quot; title=&quot;1. 常用方法 &amp;amp; 字段梳理&quot;&gt;&lt;/a&gt;1. 常用方法 &amp;amp; 字段梳理&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;ht
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>如何定位消耗CPU最多的线程</title>
    <link href="http://jianwl.com/2018/03/15/%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%B6%88%E8%80%97CPU%E6%9C%80%E5%A4%9A%E7%9A%84%E7%BA%BF%E7%A8%8B/"/>
    <id>http://jianwl.com/2018/03/15/如何定位消耗CPU最多的线程/</id>
    <published>2018-03-15T12:28:13.000Z</published>
    <updated>2018-03-15T13:14:48.828Z</updated>
    
    <content type="html"><![CDATA[<p>话不多说，先上代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class CpuMax &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        for(int i =0 ; i &lt; 10 ; i ++)&#123;</div><div class="line">            new Thread(() -&gt; &#123;</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(1000L);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Thread t = new Thread(() -&gt; &#123;</div><div class="line">            int i = 0;</div><div class="line">            while (true)&#123;</div><div class="line">                i = (i++) /100;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        t.setName(&quot;Business Thread&quot;);</div><div class="line">        t.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有11个线程，其中10个线程啥也不做，1个线程执行死循环操作。那么如何定位消耗CPU最多的这个线程呢？且看以下解决思路：</p>
<h4 id="1-运行程序"><a href="#1-运行程序" class="headerlink" title="1. 运行程序"></a>1. 运行程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 编译</div><div class="line">javac CpuMax.java</div><div class="line"></div><div class="line"># 运行</div><div class="line">java CpuMax</div></pre></td></tr></table></figure>
<h4 id="2-获取进程PID"><a href="#2-获取进程PID" class="headerlink" title="2. 获取进程PID"></a>2. 获取进程PID</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep &quot;CpuMax&quot;</div></pre></td></tr></table></figure>
<p>得到进程PID: 5055</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-15/8443081.jpg" alt=""></p>
<h4 id="3-获取进程中各线程所占CPU的占比"><a href="#3-获取进程中各线程所占CPU的占比" class="headerlink" title="3. 获取进程中各线程所占CPU的占比"></a>3. 获取进程中各线程所占CPU的占比</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">top -Hp 5505</div></pre></td></tr></table></figure>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-15/33928406.jpg" alt=""></p>
<p>根据图片信息，我们可以得到：CPU占比99.9%的线程PID为5084。线程PID转为16进制为：ox13dc</p>
<h4 id="4-打印进程中各个线程栈信息"><a href="#4-打印进程中各个线程栈信息" class="headerlink" title="4. 打印进程中各个线程栈信息"></a>4. 打印进程中各个线程栈信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstack 5055</div></pre></td></tr></table></figure>
<p>得到以下信息:</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-15/57356621.jpg" alt=""></p>
<p>步骤3中，我们得到CPU最大的线程的PID，16进制为：0x13dc，在线程栈中，我们可以根据16进制的PID得到一些关键信息。<strong>得到线程名为「Business Thread」为CPU占比最高的线程</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话不多说，先上代码。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div 
    
    </summary>
    
      <category term="Java进阶" scheme="http://jianwl.com/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java进阶" scheme="http://jianwl.com/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码学习计划</title>
    <link href="http://jianwl.com/2018/03/14/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://jianwl.com/2018/03/14/JDK源码学习计划/</id>
    <published>2018-03-14T03:45:33.000Z</published>
    <updated>2018-04-18T13:46:39.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学习源码是非常重要的，列出几个感触比较深的地方：</p>
<ol>
<li>学习Java多年，如果连平时最常用的API的实现原理都不知道，说明这个人没什么好奇心，基础不扎实。</li>
<li>1年的经验，重复使用多年，自身的经验并没有随着年限而增长，个人成长处于停滞状态。</li>
<li>只有接触多了优秀的源码，才知道进步的方向，只是埋头苦干，很容易迷失自我。</li>
<li>沉淀的重要性，切记样样通，样样半桶水的状态。知道怎么做，问你原理半天憋不出的糗样。探究精神尤其重要；</li>
</ol>
<h3 id="1-JDK1期-学习计划"><a href="#1-JDK1期-学习计划" class="headerlink" title="1. JDK1期 学习计划"></a>1. JDK1期 学习计划</h3><h4 id="1）集合类"><a href="#1）集合类" class="headerlink" title="1）集合类"></a>1）集合类</h4><ul>
<li><a href="http://jianwl.com/2018/03/15/ArrayList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">ArrayList</a> [√]</li>
<li><a href="http://jianwl.com/2018/03/17/LinkedList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">LinkedList</a> [√]</li>
<li><a href="http://jianwl.com/2018/03/22/HashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">HashMap</a>「√」</li>
<li><a href="http://jianwl.com/2018/03/27/HashSet%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">HashSet</a>「√」</li>
<li><a href="http://jianwl.com/2018/03/29/Hashtable%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Hashtable</a>「√」</li>
</ul>
<h4 id="2）String相关"><a href="#2）String相关" class="headerlink" title="2）String相关"></a>2）String相关</h4><ul>
<li><a href="http://jianwl.com/2018/04/01/String%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">String</a>「√」</li>
<li><a href="http://jianwl.com/2018/04/02/StringBuilder%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">StringBuilder</a>「√」</li>
<li><a href="http://jianwl.com/2018/04/02/StringBuilder%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">StringBuffer</a>「√」</li>
</ul>
<h4 id="3-多线程-amp-线程池"><a href="#3-多线程-amp-线程池" class="headerlink" title="3) 多线程 &amp; 线程池"></a>3) 多线程 &amp; 线程池</h4><ul>
<li>Thread</li>
<li>ThreadLocal</li>
<li>ConcurrentHashMap</li>
<li><a href="http://jianwl.com/2018/04/18/ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/#more">ThreadPoolExecutor</a>「√」</li>
</ul>
<h4 id="4-原子操作"><a href="#4-原子操作" class="headerlink" title="4) 原子操作"></a>4) 原子操作</h4><ul>
<li>AtomicInteger</li>
<li>AtomicBoolean</li>
<li>AtomicLong</li>
<li>AtomicReference</li>
</ul>
<h4 id="5-锁"><a href="#5-锁" class="headerlink" title="5) 锁"></a>5) 锁</h4><ul>
<li>ReentrantLock</li>
<li>ReentrantReadWriteLock</li>
</ul>
<h4 id="6）队列"><a href="#6）队列" class="headerlink" title="6）队列"></a>6）队列</h4><ul>
<li>ArrayBlockingQueue</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;学习源码是非常重要的，列出几个感触比较深的地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学习Java多年，如果连平时最常用的API的实现原理都不知道，说
    
    </summary>
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/categories/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JDK源码学习专题" scheme="http://jianwl.com/tags/JDK%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载的那些事</title>
    <link href="http://jianwl.com/2018/03/04/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://jianwl.com/2018/03/04/JVM类加载的那些事/</id>
    <published>2018-03-04T13:56:36.000Z</published>
    <updated>2018-03-07T14:01:18.489Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java源代码被编译成class字节码，最终需要加载到虚拟机中才能运行。整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-5/76059548.jpg" alt=""></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol>
<li>通过一个类的全限定名获取描述此类的二进制字节流</li>
<li>通过这个字节流锁代表的静态存储结构保存为方法区的运行时数据结构；</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为范文方法区的入口；</li>
</ol>
<p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，实现这个动作的代码称为“类加载器”，JVM提供了3种类加载器：</p>
<ol>
<li>启动类加载器（Bootstrap ClassLoader）： 负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。</li>
<li>扩展类加载器（Extension ClassLoader）: 负责加载JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</li>
<li>应用程序类加载器（Application ClassLoader）:负责加载用户路径(classpath)上的类库。</li>
</ol>
<p>JVM基于上述类加载器，通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-6/33598419.jpg" alt=""></p>
<p>双亲委派模型工作过程：当一个类加载器收到类加载任务,优先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。</p>
<p>双亲委派模型有什么好处？</p>
<p>比如位于rt.jar包中的类java.lang.Object,无论哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，确保了Object类在各种加载器环境中都是同一个类。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>为了确保Class文件符合当前虚拟机要求，需要对其字节流数据进行验证，主要包括格式验证、元数据验证、字节码验证和符号引用验证。</p>
<h4 id="1、格式校验"><a href="#1、格式校验" class="headerlink" title="1、格式校验"></a>1、格式校验</h4><p>验证字节流是否符合class文件格式的规范，并且能被当前虚拟机处理，如：是否以魔数0xCAFEBABE开头、主次版本号是否在当前虚拟机处理范围内、常量池是否有不支持的常量类型等。只有经过格式验证的字节流，才会存储到方法区的数据结构，剩余3个验证都基于方法区的数据进行。</p>
<h4 id="2、元数据验证"><a href="#2、元数据验证" class="headerlink" title="2、元数据验证"></a>2、元数据验证</h4><p>对字节码描述的数据进行语义分析，以保证符合Java语言规范，如是否继承了final修饰的类、是否实现了父类的抽象方法、是否覆盖了父类的final方法或final字段等。</p>
<h4 id="3、字节码验证"><a href="#3、字节码验证" class="headerlink" title="3、字节码验证"></a>3、字节码验证</h4><p>对类的方法体进行分析，确保在方法运行时不会有危害虚拟机的事件发生，如保证操作数栈的数据类型和指令代码序列的匹配、保证跳转指令的正确性、保证类型转换的有效性等。</p>
<h4 id="4、符号引用验证"><a href="#4、符号引用验证" class="headerlink" title="4、符号引用验证"></a>4、符号引用验证</h4><p>为了确保后续的解析动作能够正常执行，对符号引用进行验证，如通过字符串描述的全限定名是能找到对应的类、在指定类中是否存在符合方法的字段描述等。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在准备阶段，为类变量(static修饰)在方法区中分配内存并设置初始值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static int var = 100;</div></pre></td></tr></table></figure>
<p>准备阶段完成后，var值为0，而不是100。在初始化阶段，才会把100赋值给val，但是有个特殊情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static final int VAL = 100;</div></pre></td></tr></table></figure>
<p>在编译阶段会为VAL生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将VAL赋值为100。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是将常量池中的符号引用替换为直接引用的过程，符号引用和直接引用有什么不同？</p>
<ol>
<li>符号引用使用一组符号来描述所引用的目标，可以是任何形式的字面常量，定义在Class文件格式中。</li>
<li>直接引用可以是直接指向目标的指针，相对偏移量或者能间接定位目标的句柄。</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是执行类构造器<clinit>方法的过程，<clinit>方法由类变量的赋值动作和静态语句块按照在源文件出现的顺序合并而成，该合并操作由编译器完成。</clinit></clinit></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private static int value = 100;</div><div class="line">static int a = 100;</div><div class="line">static int b = 100;</div><div class="line">static int c;</div><div class="line"></div><div class="line">static &#123;</div><div class="line">	c = a + b;</div><div class="line">	System.out.println(&quot;it only run once&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><clinit>方法对于类和接口不是必须的，如果一个类中没有静态代码块，也没有静态变量的赋值操作，那么编译器不会生成<clinit>；</clinit></clinit></li>
<li><clinit>方法与实例构造器不同，不需要显式的调用父类的<clinit>方法，虚拟机会保证父类的<clinit>优先执行。</clinit></clinit></clinit></li>
<li>为了防止多次执行<clinit>,虚拟机会确保<clinit>方法在多线程环境下被正确的加锁同步执行，如果有多个线程同时初始化一个类，那么只有一个线程能够执行<clinit>方法，其他线程进行阻塞等待，直到<clinit>执行完成。</clinit></clinit></clinit></clinit></li>
<li>注意：执行接口的<clinit>方法不需要先执行父接口的<clinit>，只有使用父接口中定义的变量时，才会执行。</clinit></clinit></li>
</ol>
<h3 id="类初始化场景"><a href="#类初始化场景" class="headerlink" title="类初始化场景"></a>类初始化场景</h3><p>虚拟机中严格规定了有且只有5种情况必须对类初始化。</p>
<ul>
<li>执行new、getstatic、putstatic和invokestatic指令；</li>
<li>使用reflect对类进行反射调用；</li>
<li>初始化一个类的时候，父类还没有初始化，会事先初始化父类；</li>
<li>启动虚拟机时，需要初始化包含main方法的类；</li>
<li>在JDK1.7中，如果java.lang.invoke.MethodHandler实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化；</li>
</ul>
<p>一下几种情况，不会触发类初始化：</p>
<p>1、通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Parent&#123;</div><div class="line">	static int a = 100;</div><div class="line">	static&#123;</div><div class="line">		System.out.println(&quot;parent int !&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Child extends Parent&#123;</div><div class="line">	static &#123;</div><div class="line">	 	System.out.println(&quot;child init!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Init&#123;</div><div class="line">	public static void main(String args[]) &#123;</div><div class="line">		System.out.println(Child.a);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果为：<br>parent init !<br>100</p>
<p>2、定义对象数组，不会触发该类的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Init&#123;</div><div class="line">	public static void main(String args[]) &#123;</div><div class="line">		Parent[] parents = new Parent[10];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无输出，说明没有触发类Parent的初始化，但是这段代码做了什么？先看看生成的字节码指令；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-7/40936913.jpg" alt=""></p>
<p>anewarray指令为新数组分配空间，并触发Parent类的初始化，这个类由虚拟机自动生成。</p>
<p>3、常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Const&#123;</div><div class="line">	static final int A = 100;</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;Const init&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Init&#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		System.out.println(Const.A);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：100</p>
<p>说明没有触发类Const的初始化，在编译阶段，Const类中常量A的值100存储到Init类的常量池中，这两个类在编译成class文件之后就没有联系了。</p>
<p>4、通过类名获取Class对象，不会触发类的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">	public static void main(String args[]) &#123;</div><div class="line">		Class cDog = Dog.class;</div><div class="line">		Class clazz = Class.forName(&quot;zzzzzzz.Cat&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Class Cat &#123;</div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	static&#123;</div><div class="line">		System.out.println(&quot;Cat is load&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Dog&#123;</div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	static&#123;</div><div class="line">		System.out.println(&quot;Dog is load&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：Cat is load, 所以通过Dog.class并不会触发Dog类的初始化动作。</p>
<p>5、通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否亚欧对类进行初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Test&#123;</div><div class="line">	public static void main(String args[]) &#123;</div><div class="line">		Class clazz = Class.forName(&quot;zzzzzz.Cat&quot;,false,Cat.class.getClassLoader());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Cat&#123;</div><div class="line">	private String name;</div><div class="line">	private int age;</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;Cat is load&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>6、通过ClassLoader默认的loadClass方法，也不会触发初始化动作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ClassLoader()&#123;&#125;.loadClass(&quot;zzzzzz.Cat&quot;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Java源代码被编译成class字节码，最终需要加载到虚拟机中才能运行。整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段
    
    </summary>
    
      <category term="JVM专题" scheme="http://jianwl.com/categories/JVM%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JVM专题" scheme="http://jianwl.com/tags/JVM%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存的那些事</title>
    <link href="http://jianwl.com/2018/03/04/JVM%E5%86%85%E5%AD%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://jianwl.com/2018/03/04/JVM内存的那些事/</id>
    <published>2018-03-04T08:46:45.000Z</published>
    <updated>2018-04-01T03:33:47.409Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于C语言开发的程序员来说，在内存管理方面，必须负责每一个对象的生命周期，从有到无。对于Java程序员来说，在虚拟机内存管理的帮助下，不需要为每个new对象都匹配free操作，内存泄露和内存溢出等问题也不太容易出现，不过也正是把内存管理交给了虚拟机，一旦运行中的程序出现了内存泄露问题，给排查过程造成很大困难。所以只有理解了Java虚拟机的运行机制，才能够运筹帷幄于各种代码。本文以HotSpot为例说说虚拟机的那些事。</p>
<p>Java虚拟机把管理的内存划分为几个不同的数据区。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-4/82705423.jpg" alt=""></p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，Java虚拟机规范中有这样一段描述：所有的对象实例和数据都要在堆上进行分配。为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，通常有两种方法实现：</p>
<h4 id="1、指针碰撞法"><a href="#1、指针碰撞法" class="headerlink" title="1、指针碰撞法"></a>1、指针碰撞法</h4><p>假设Java堆中内存是完整的，已分配的内存和空闲内存分别在不同的一侧，通过一个指针作为分界点，需要分配内存时，仅仅需要把指针往空闲的一端移动与对象大小相等的距离。</p>
<h4 id="2、空闲列表法"><a href="#2、空闲列表法" class="headerlink" title="2、空闲列表法"></a>2、空闲列表法</h4><p>事实上，Java堆的内存并不是完整的，已分配的内存和空闲内存相互交错，JVM通过维护一个列表，记录可用的内存块信息，当分配操作发生时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录。</p>
<p>对象创建时一个非常频繁的行为，进行堆内存分配时还需要考虑多线程并发问题，可能出现正在给对象A分配内存，指针或记录还未更新，对象B又同时分配到原来的内存，解决这个问题有两种方案：</p>
<p>1、采用CAS保证数据更新操作的原子性；</p>
<p>2、把内存分配的行为按照线程进行划分，在不同的空间中进行，每个线程在Java堆中预先分配一个内存块，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB);</p>
<h4 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h4><p>堆内存由年轻代和老年代组成，而年轻代又被分为三部分：Eden空间、From Survivor空间、To Survivor空间，默认情况下年轻代安装8：1：1的比例来分配；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-1/86769879.jpg" alt=""></p>
<h3 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h3><p>Java栈是线程私有的，每个线程对应一个Java栈，每个线程在执行一个方法时会创建一个对应的栈帧(Stack Frame)，栈帧负责存储局部变量表、操作数栈、动态链接和方法返回地址等信息。每个方法的调用过程，相当于栈帧在Java栈的入栈和出栈的过程。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-4/89188723.jpg" alt=""></p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>用于存放方法参数和方法内部定义的局部变量，其大小在代码编译期间已经确定，在方法运行期间不会改变。局部变量表以变量槽(Slot)为最小存储单位，每个Slot能够存放一个boolean、byte、char、short、int、float、reference和return address类型的32位数据，对于64位的数据类型long和double，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。</p>
<p>在方法执行时，如果是实例方法，即非static方法，局部变量表中第0位Slot默认存放对象实例的引用，在方法中可以通过关键字this进行访问，方法参数按照参数列表顺序，从第1位Slot开始分配，方法内部变量则按照定义顺序进行分配其余的Slot。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区和Java堆一样，是所有线程共享的内存区域，用于存放已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据。运行时常量池是方法区的一部分，用于存放编译期间产生的各种字面常量和符号引用。</p>
<h3 id="指令计数器"><a href="#指令计数器" class="headerlink" title="指令计数器"></a>指令计数器</h3><p>指令计数器是线程私有的，每个线程都有独立的指令计数器，计数器记录着虚拟机正在执行的字节码指令的地址，分支、循环、跳转、异常处理和线程恢复等操作都依赖这个计数器完成。如果线程执行的是native方法，这个计数器则为空。</p>
<h3 id="通过参数控制各区域的大小"><a href="#通过参数控制各区域的大小" class="headerlink" title="通过参数控制各区域的大小"></a>通过参数控制各区域的大小</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-4-1/7809771.jpg" alt=""></p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在内存中布局可以分成三块区域：对象头、实例数据和对齐填充。</p>
<h5 id="1、对象头"><a href="#1、对象头" class="headerlink" title="1、对象头"></a>1、对象头</h5><p>对象头包括两部分信息：运行时数据和类型指针，如果对象是一个数组，还需要一块用于记录数组长度的数据。</p>
<p>1.1、运行时数据包括哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向锁和偏向时间戳等，这部分数据在32位和64位虚拟机中的长度分别为32bit和64bit，官方称为“Mark Word”。Mark Word被设计成非固定的数据结构，以实现在有限空间内保存尽可能多的数据。</p>
<p>32为虚拟机中，对象未被锁定的状态下，Mark Word的32bit中25bit存储对象的HashCode、4bit存储对象分代年龄、2bit存储锁标志位、1bit固定为0，具体如下：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/18-3-4/80147108.jpg" alt=""></p>
<p>其他状态(轻量级锁定、重量级锁定、GC锁、可偏向锁)下Mark Word的存储内容如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">存储内容</th>
<th style="text-align:center">标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">轻量级锁定</td>
<td style="text-align:center">指向锁记录的指针</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">重量级锁定</td>
<td style="text-align:center">指向重量级的指针</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">GC标志</td>
<td style="text-align:center">空</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">可偏向</td>
<td style="text-align:center">偏向线程ID、时间戳、分代年龄</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">未锁定</td>
<td style="text-align:center">对象哈希码、分代年龄</td>
<td style="text-align:center">01</td>
</tr>
</tbody>
</table>
<p>1.2 、对象头的类型指针指向该对象的类元数据、虚拟机通过这个指针可以确定该对象是哪个类的实例。</p>
<h5 id="2、实例数据"><a href="#2、实例数据" class="headerlink" title="2、实例数据"></a>2、实例数据</h5><p>实例数据就是在程序代码中所定义的各种类型的字段，包括从父类继承的，这部分的存储顺序会受到虚拟机分配策略和字段在源码中定义顺序的影响。</p>
<h5 id="3、对齐填充"><a href="#3、对齐填充" class="headerlink" title="3、对齐填充"></a>3、对齐填充</h5><p>由于HotSpot的自动内存管理要求对象的起始地址必须是8字节的整数倍，即对象的大小必须是8字节的整数倍，对象头的数据正好是8的整数倍，所以当实例数据不够8字节整数倍时，需要通过对齐填充进行补全。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>深入理解Java虚拟机</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;对于C语言开发的程序员来说，在内存管理方面，必须负责每一个对象的生命周期，从有到无。对于Java程序员来说，在虚拟机内存管理的帮助下，不需要
    
    </summary>
    
      <category term="JVM专题" scheme="http://jianwl.com/categories/JVM%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="JVM专题" scheme="http://jianwl.com/tags/JVM%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>用ELK搭建自己的日志分析系统</title>
    <link href="http://jianwl.com/2017/11/05/%E7%94%A8ELK%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://jianwl.com/2017/11/05/用ELK搭建自己的日志分析系统/</id>
    <published>2017-11-05T00:25:09.000Z</published>
    <updated>2017-11-05T03:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p>不管用于记录、监控，日志对于任何系统来说都是一个极其重要的部分，但一般的日志的数据量会比较大，并且分散在各个地方，当管理的服务器比较少，我们还可以逐一登录到各个服务器去查看、分析。但如果服务器比较多，这种方法就显得力不从心了。基于这种场景，一些集中式的日志系统也就产生了。比较成熟<a href="https://www.splunk.com/zh-hans_cn" target="_blank" rel="external">Splunk</a>、Facebook的Scribe、Apache的Chukwa、Cloudera的Fluentd和ELK等。</p>
<h3 id="2-概述"><a href="#2-概述" class="headerlink" title="2 概述"></a>2 概述</h3><p>ELK不是一款软件，是三个软件产品的首字母缩写：ElasticSearc、Logstash和Kibana，这三款都是开源的，目前归于<code>Elastic.co</code>公司。三者之间的关系如图所示：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-5/58949300.jpg" alt=""></p>
<h4 id="1）Elasticsearch"><a href="#1）Elasticsearch" class="headerlink" title="1）Elasticsearch"></a>1）Elasticsearch</h4><p>Elasticsearch是一个实时的分布式搜索和分析引擎，它可以用于全文搜索、结构化搜索以及分析，它是基于Apache Lucence基础上开发搜索引擎，使用Java语言编写。作为ELK协议栈的核心，它用于集中存储数据。</p>
<p>特点：</p>
<ul>
<li>实时</li>
<li>分布式</li>
<li>面向文档</li>
<li>高可用性、易扩展、支持集群、分片、复制</li>
<li>接口友好，RestFUL接口风格；</li>
</ul>
<h4 id="2）Logstash"><a href="#2）Logstash" class="headerlink" title="2）Logstash"></a>2）Logstash</h4><p>Logstash是一个具有实时渠道能力的数据收集引擎，是用JRuby语言编写，其作者是世界上著名的运维工程师乔丹西塞。</p>
<p>特点：</p>
<ul>
<li>几乎可以访问任何数据</li>
<li>可以和多种外部应用结合</li>
<li>支持弹性扩展</li>
</ul>
<p>组成部分</p>
<ul>
<li>INPUTS，从各个服务器获取数据</li>
<li>FILTERS，过滤处理获取到的数据</li>
<li>OUTPUTS，将处理完的数据输出到指定地方</li>
</ul>
<h4 id="3）Kibana"><a href="#3）Kibana" class="headerlink" title="3）Kibana"></a>3）Kibana</h4><p>Kibana是一款基于Apache开源协议，使用Javascript语言编写，为Elasticsearch提供分析和可视化的Web平台。它可以在Elasticsearch的搜索中查找、交互数据，并生成各种维度的表图。</p>
<h3 id="3-ELK平台搭建-MacOS"><a href="#3-ELK平台搭建-MacOS" class="headerlink" title="3 ELK平台搭建(MacOS)"></a>3 ELK平台搭建(MacOS)</h3><h4 id="1-Elasticsearch搭建"><a href="#1-Elasticsearch搭建" class="headerlink" title="1) Elasticsearch搭建"></a>1) Elasticsearch搭建</h4><p>1 下载Elasticsearch &amp; 解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.3.zip</div><div class="line">unzip elasticsearch-5.6.3.zip</div></pre></td></tr></table></figure>
<p>2 启动Elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./$&#123;ES_HOME&#125;/bin/elasticsearch</div></pre></td></tr></table></figure>
<p>3 检查是否启动成功</p>
<p>健康值绿色: 所有主、复制分片都是正常的；</p>
<p>健康值黄色: 所有主分片正常，部分或全部复制分片数有问题；</p>
<p>健康值红色: 部分或全部主分片有问题 </p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-5/55815051.jpg" alt=""></p>
<p>4 安装elastic-head</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git clone git://github.com/mobz/elasticsearch-head.git</div><div class="line">cd elasticsearch-head</div><div class="line">npm install</div><div class="line">npm run start</div></pre></td></tr></table></figure>
<p>通过elastic-head查看elasticsearch的数据：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-5/4570828.jpg" alt=""></p>
<h4 id="2）Logstash搭建"><a href="#2）Logstash搭建" class="headerlink" title="2）Logstash搭建"></a>2）Logstash搭建</h4><p>1 下载Logstash &amp; 解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-5.6.3.zip</div><div class="line">unzip logstash-5.6.3.zip</div></pre></td></tr></table></figure>
<p>2 Logstash管道测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd logstash-5.6.3</div><div class="line">bin/logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&apos;</div></pre></td></tr></table></figure>
<p><code>-e</code>表示能够在命令行中配置logstash的配置(一次性的),通过上述命令启动logstash，当你看到<code>Pipeline main started</code>，在命令行中输入<code>hello world</code>，会得到一个输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello world!</div><div class="line">2017-11-05T01:53:55.571Z jianweilindeMacBook-Pro.local hello world!</div></pre></td></tr></table></figure>
<p>3 配置Filebeat发送日志到Logstash</p>
<p>1) 下载Filebeat &amp; 解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-5.6.3-darwin-x86_64.tar.gz</div><div class="line">tar zxvf filebeat-5.6.3-darwin-x86_64.tar.gz</div></pre></td></tr></table></figure>
<p>2) 配置filebeat.yml</p>
<ul>
<li><p>下载<a href="http://oc5a5l0a0.bkt.clouddn.com/logstash-tutorial.log" target="_blank" rel="external">logstash-tutorial.log</a></p>
</li>
<li><p>配置filebeat.yml</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">filebeat.prospectors:</div><div class="line">- input_type: log</div><div class="line">  paths:</div><div class="line">    - /Users/jianweilin/Downloads/logstash-tutorial.log</div><div class="line">    - /var/log/*.log</div><div class="line">output.logstash:</div><div class="line">  hosts: [&quot;localhost:5043&quot;]</div></pre></td></tr></table></figure>
<p>特别注意：logstash-tutorial.log的路径是刚刚下载的文件，在你本地的路径。</p>
<p>3）配置Logstash配置文件</p>
<p>在${LOGSTASH_HOME}目录下创建一个配置文件<code>first-pipeline.conf</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">    beats &#123;</div><div class="line">        port =&gt; &quot;5043&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output &#123;</div><div class="line">    elasticsearch &#123;</div><div class="line">        hosts =&gt; [ &quot;localhost:9200&quot; ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述配置的意思是：从filebeat中接收数据，之后发送到elasticsearch中</p>
<p>4) 启动logstash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/logstash -f first-pipeline.conf --config.reload.automatic</div></pre></td></tr></table></figure>
<p><code>--config.reload.automatic</code>表示之后如果first-pipeline.conf配置文件更新规则，会自动更新生效，不需要重启logstash；</p>
<p>5) 启动filebeat将日志发送到logstash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./filebeat -e -c filebeat.yml -d &quot;publish&quot;</div></pre></td></tr></table></figure>
<p>6) 在elastic-head中查看数据</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-5/18364515.jpg" alt=""></p>
<p>elasticsearch健康值为黄色，是因为只有一个主分片，没有复制分片；</p>
<h4 id="3-Kibana搭建"><a href="#3-Kibana搭建" class="headerlink" title="3) Kibana搭建"></a>3) Kibana搭建</h4><p>1 Kibana下载 &amp; 解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-5.6.3-darwin-x86_64.tar.gz</div><div class="line">tar zxvf kibana-5.6.3-darwin-x86_64.tar.gz</div></pre></td></tr></table></figure>
<p>2 启动Kibana</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$&#123;KIBANA_HOME&#125;/bin/kibana</div></pre></td></tr></table></figure>
<p>3 使用Kibana连接Elasticsearch</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-5/96019826.jpg" alt=""></p>
<ul>
<li>访问<code>localhost:5601</code>进入Kibana的UI界面</li>
<li>在Kibana中配置Elasticsearch中索引的配置规则，符合配置规则的索引才会在Kibana中搜索到</li>
<li>在Kibana中配置，数据以什么维度进行展示，通常来说设置为时间维度；</li>
<li>在Kibana中点击create按钮创建索引匹配规则；</li>
</ul>
<p>4 在Kibana中搜索日志</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-5/5428734.jpg" alt=""></p>
<p>至此ELK平台搭建完毕。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs.html" target="_blank" rel="external">Elasticsearch官方文档</a></li>
<li><a href="https://www.elastic.co/guide/en/logstash/5.6/index.html" target="_blank" rel="external">Logstash官方文档</a></li>
<li><a href="https://www.elastic.co/guide/en/kibana/5.6/install.html" target="_blank" rel="external">Kibana官方文档</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1 前言&quot;&gt;&lt;/a&gt;1 前言&lt;/h3&gt;&lt;p&gt;不管用于记录、监控，日志对于任何系统来说都是一个极其重要的部分，但一般的日志的数据量会比较大，并且分散在各个地方，当管理的服
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://jianwl.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://jianwl.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite源码分析---作业配置</title>
    <link href="http://jianwl.com/2017/11/01/Elastic-Job-Lite%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BD%9C%E4%B8%9A%E9%85%8D%E7%BD%AE/"/>
    <id>http://jianwl.com/2017/11/01/Elastic-Job-Lite源码分析-作业配置/</id>
    <published>2017-11-01T08:30:37.000Z</published>
    <updated>2017-11-02T09:43:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p>涉及到主要类的类图如下：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-1/79872342.jpg" alt=""></p>
<h3 id="2-作业配置"><a href="#2-作业配置" class="headerlink" title="2 作业配置"></a>2 作业配置</h3><p>一个作业(ElasticJob)的调度，需要配置独有的一个作业调度器(JobScheduler),两者是1:1的关系，这点大家要注意下，当然下文看代码也会看到。</p>
<p>作业调度器的创建可以配置四个参数：</p>
<ol>
<li>注册中心(CoordinatorRegistryCenter): 用于协调分布式服务，必填；</li>
<li>Lite作业配置(LiteJobConfiguration): 必填</li>
<li>作业事件总线(JobEventBus): 对作业事件异步监听。选填</li>
<li>作业监听器(ElasticJobListener): 对作业执行前，执行后进行同步监听。选填</li>
</ol>
<h3 id="2-1-注册中心配置"><a href="#2-1-注册中心配置" class="headerlink" title="2.1 注册中心配置"></a>2.1 注册中心配置</h3><p>Elastic-Job抽象了注册中心接口(RegistryCenter),并提供了基于Zookeeper的注册中心实现(ZookeeperRegistryCenter)。</p>
<p>ZookeeperRegistryCenter对应配置类为ZookeeperConfiguration，该类注释很完整，这里我们重点说下<code>namespace</code>属性。如果你有多个不同Elastic-Job集群时，使用相同Zookeeper，可以配置不同的<code>namespace</code>进行隔离。</p>
<p>注册中心的初始化，我们会在后文<code>Elastic-Job-Lite源码解析---注册中心</code>详细分享。</p>
<h3 id="2-2-Lite作业配置"><a href="#2-2-Lite作业配置" class="headerlink" title="2.2 Lite作业配置"></a>2.2 Lite作业配置</h3><p><code>LiteJobConfiguration</code>继承自接口<code>JobRootConfiguration</code>，作为<code>Elastic-Job-Lite</code>里的作业(LiteJob)配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public final class LiteJobConfiguration implements JobRootConfiguration &#123;</div><div class="line">    private final JobTypeConfiguration typeConfig;</div><div class="line">    private final boolean monitorExecution;</div><div class="line">    private final int maxTimeDiffSeconds;</div><div class="line">    private final int monitorPort;</div><div class="line">    private final String jobShardingStrategyClass;</div><div class="line">    private final int reconcileIntervalMinutes;</div><div class="line">    private final boolean disabled;</div><div class="line">    private final boolean overwrite;</div><div class="line">    </div><div class="line">    // ... 省略部分get方法</div><div class="line">    public static class Builder &#123;</div><div class="line">	    // ... 省略部分属性</div><div class="line">	    public final LiteJobConfiguration build() &#123;</div><div class="line">	            return new LiteJobConfiguration(jobConfig, monitorExecution, maxTimeDiffSeconds, monitorPort, jobShardingStrategyClass, reconcileIntervalMinutes, disabled, overwrite);</div><div class="line">	        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>typeConfig</code>:作业类型配置，必填</li>
<li><code>monitorExecution</code>: 监控作业运行时状态，默认为<code>false</code>，选填。</li>
</ul>
<blockquote>
<p>每次作业执行时间和间隔时间均非常短的情况, 建议不监控作业运行时状态以提升效率, 因为是瞬时状态, 所以无必要监控. 请用户自行增加数据堆积监控. 并且不能保证数据重复选取, 应在作业中实现幂等性. 也无法实现作业失效转移.</p>
<p> 每次作业执行时间和间隔时间均较长短的情况, 建议监控作业运行时状态, 可保证数据不会重复选取.每次作业执行时间和间隔均较长的情况，建议监控作业运行时状态，可保证数据不会重复选取。</p>
</blockquote>
<ul>
<li><code>maxTimeDiffSeconds</code>: 设置最大容忍的本机与注册中心的时间误差秒数。默认为-1，不检查时间误差。选填</li>
<li><code>monitorPort</code>: 作业监控端口，默认为-1，不开启作业监控端口。选填</li>
<li><code>jobShardingStrategyClass</code>：作业分片策略实现类全路径，默认为使用分配侧路。</li>
<li><code>reconcileIntervalMinutes</code>：修复作业服务器不一致状态服务调度间隔时间，配置为小于1的任意值，默认为10.</li>
<li><code>disabled</code>: 作业是否禁用执行。默认为false，选填。</li>
<li><code>overwrite</code>: 设置使用本地配置覆盖注册中心的作业配置。默认为false，选填。建议使用运维平台console配置作业配置，统一管理。</li>
<li>Builder类：使用该类配置LiteJobConfiguration属性，调用<code>#build()</code>方法最终生成作业配置。</li>
</ul>
<h3 id="2-2-1-作业类型配置"><a href="#2-2-1-作业类型配置" class="headerlink" title="2.2.1 作业类型配置"></a>2.2.1 作业类型配置</h3><p>作业类型配置接口(JobTypeConfiguration)有三种配置实现，针对三种作业类型：</p>
<table>
<thead>
<tr>
<th>配置实现</th>
<th>作业</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SimpleJobConfiguration</td>
<td>SimpleJob</td>
<td>简单作业。例如：订单过期作业</td>
</tr>
<tr>
<td>DataflowJobConfiguration</td>
<td>DataflowJob</td>
<td>数据流作业。TODO:暂未了解流式处理数据</td>
</tr>
<tr>
<td>ScriptJobConfiguration</td>
<td>ScriptJob</td>
<td>脚本作业。例如：调用shell脚本备份数据库作业</td>
</tr>
</tbody>
</table>
<p>三种配置类属性对比如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">SimpleJob</th>
<th style="text-align:center">DataflowJob</th>
<th style="text-align:center">ScriptJob</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">coreConfig</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">作业核心配置</td>
</tr>
<tr>
<td style="text-align:center">jobType</td>
<td style="text-align:center">JobType.SIMPLE</td>
<td style="text-align:center">JobType.DATAFLOW</td>
<td style="text-align:center">JobType.SCRIPT</td>
<td style="text-align:center">作业类型</td>
</tr>
<tr>
<td style="text-align:center">jobClass</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️(默认：ScriptJob.class)</td>
<td style="text-align:center">作业实现类全路径</td>
</tr>
<tr>
<td style="text-align:center">streamingProcess</td>
<td style="text-align:center"></td>
<td style="text-align:center">✔️</td>
<td style="text-align:center"></td>
<td style="text-align:center">是否流式处理数据</td>
</tr>
<tr>
<td style="text-align:center">scriptCommandLine</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">脚本型作业执行命令行</td>
</tr>
</tbody>
</table>
<h3 id="2-2-2-作业核心配置"><a href="#2-2-2-作业核心配置" class="headerlink" title="2.2.2 作业核心配置"></a>2.2.2 作业核心配置</h3><p>作业核心配置(JobCoreConfiguration),我们可以看到在每种作业类型配置都有该属性(<code>coreConfig</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public final class JobCoreConfiguration &#123;</div><div class="line">    private final String jobName;</div><div class="line">    private final String cron;</div><div class="line">    private final int shardingTotalCount;</div><div class="line">    private final String shardingItemParameters;</div><div class="line">    private final String jobParameter;</div><div class="line">    private final boolean failover;</div><div class="line">    private final boolean misfire;</div><div class="line">    private final String description;</div><div class="line">    private final JobProperties jobProperties;</div><div class="line">    </div><div class="line">    // ... 省略Getter方法</div><div class="line">    public static class Builder &#123;</div><div class="line">    </div><div class="line">	    // ... 省略部分属性</div><div class="line">	    public final JobCoreConfiguration build() &#123;</div><div class="line">	            Preconditions.checkArgument(!Strings.isNullOrEmpty(jobName), &quot;jobName can not be empty.&quot;);</div><div class="line">	            Preconditions.checkArgument(!Strings.isNullOrEmpty(cron), &quot;cron can not be empty.&quot;);</div><div class="line">	            Preconditions.checkArgument(shardingTotalCount &gt; 0, &quot;shardingTotalCount should larger than zero.&quot;);</div><div class="line">	            return new JobCoreConfiguration(jobName, cron, shardingTotalCount, shardingItemParameters, jobParameter, failover, misfire, description, jobProperties);</div><div class="line">	        &#125;</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>jobName</code>: 作业名称。必填</li>
<li><code>cron</code>: cron表达式，用于控制作业触发时间。必填</li>
<li><code>shardingTotalCount</code>: 作业分片总数，如果一个作业启动超过作业分片总数的节点，只有<code>shardingTotalCount</code>会执行作业。必填</li>
<li><code>shardingItemParameters</code>: 分片序列号和参数</li>
</ul>
<blockquote>
<p>分片序列号和参数用等号分隔，多个键值对用逗号分隔<br>分片序列号从0开始，不可大于或等于分片总数<br>如: 0=a,1=b,2=c</p>
</blockquote>
<ul>
<li><code>jobParameter</code>: 作业自定义参数，选填</li>
</ul>
<blockquote>
<p>作业自定义参数，可通过传递该参数为作业调度的业务方法传参，用于实现带参数的作业</p>
<p>例: 每次获取的数据量、作业实例从数据库读取的主键</p>
</blockquote>
<ul>
<li><code>failover</code>: 是否开启作业执行失效转移，开启表示如果作业在一次作业执行中途宕机，允许将该次未完成的作业在另一作业节点上补偿执行。默认为false。选填</li>
<li><code>misfire</code>: 是否开启错误作业重新执行，默认为true.选填</li>
<li><code>description</code>: 作业描述，选填。</li>
<li><code>jobProperties</code>: 作业属性配置，选填。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public final class JobProperties &#123;</div><div class="line">    </div><div class="line">    private EnumMap&lt;JobPropertiesEnum, String&gt; map = new EnumMap&lt;&gt;(JobPropertiesEnum.class);</div><div class="line"></div><div class="line">	public enum JobPropertiesEnum &#123;</div><div class="line">	        </div><div class="line">	        /**</div><div class="line">	         * 作业异常处理器.</div><div class="line">	         */</div><div class="line">	        JOB_EXCEPTION_HANDLER(&quot;job_exception_handler&quot;, JobExceptionHandler.class, DefaultJobExceptionHandler.class.getCanonicalName()),</div><div class="line">	        </div><div class="line">	        /**</div><div class="line">	         * 线程池服务处理器.</div><div class="line">	         */</div><div class="line">	        EXECUTOR_SERVICE_HANDLER(&quot;executor_service_handler&quot;, ExecutorServiceHandler.class, DefaultExecutorServiceHandler.class.getCanonicalName());</div><div class="line">	        </div><div class="line">	        private final String key;</div><div class="line">	    </div><div class="line">	        private final Class&lt;?&gt; classType;</div><div class="line">	        </div><div class="line">	        private final String defaultValue;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>JOB_EXCEPTION_HANDLER</code>: 用于扩展异常处理类</li>
<li><code>EXECUTOR_SERVICE_HANDLER</code>: 用于扩展作业处理线程池类</li>
<li>通过这个属性，我们可以自定义每个作业的异常处理和线程池服务</li>
</ul>
<h3 id="2-3-作业事件配置"><a href="#2-3-作业事件配置" class="headerlink" title="2.3 作业事件配置"></a>2.3 作业事件配置</h3><p>通过作业事件配置（<code>JobEventConfiguration</code>）,实现对作业事件的异步监听、处理。在<code>Elastic-Job-Lite源码解析 --- 作业事件追踪</code> 详细分享</p>
<h3 id="2-4-作业监听器"><a href="#2-4-作业监听器" class="headerlink" title="2.4 作业监听器"></a>2.4 作业监听器</h3><p>通过配置作业监听器（<code>ElasticJobListener</code>）,实现对作业执行的同步监听、处理。<code>Elastic-Job-Lite源码解析 --- 作业监听器</code>详细分享</p>
<h3 id="3-作业配置服务"><a href="#3-作业配置服务" class="headerlink" title="3 作业配置服务"></a>3 作业配置服务</h3><p>多个Elastic-Job-Lite使用相同注册中心和相同<code>namespace</code>组成集群，实现高可用。集群中，使用作业配置服务（<code>ConfigurationService</code>）共享作业配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final class ConfigurationService &#123;</div><div class="line">    </div><div class="line">    private final TimeService timeService;</div><div class="line">    </div><div class="line">    private final JobNodeStorage jobNodeStorage;</div><div class="line">    </div><div class="line">    public ConfigurationService(final CoordinatorRegistryCenter regCenter, final String jobName) &#123;</div><div class="line">        jobNodeStorage = new JobNodeStorage(regCenter, jobName);</div><div class="line">        timeService = new TimeService();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>timeService</code>: 时间服务，提供当前时间查询</li>
<li><code>jobNodeStorage</code>: 封装注册中心，提供存储服务。<code>Elastic-Job-Lite源码解析 --- 作业数据存储</code>详细分享</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final class TimeService &#123;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 获取当前时间的毫秒数.</div><div class="line">     * </div><div class="line">     * @return 当前时间的毫秒数</div><div class="line">     */</div><div class="line">    public long getCurrentMillis() &#123;</div><div class="line">        return System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-1-读取作业配置"><a href="#3-1-读取作业配置" class="headerlink" title="3.1 读取作业配置"></a>3.1 读取作业配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * 读取作业配置.</div><div class="line">    * </div><div class="line">    * @param fromCache 是否从缓存中读取</div><div class="line">    * @return 作业配置</div><div class="line">    */</div><div class="line">   public LiteJobConfiguration load(final boolean fromCache) &#123;</div><div class="line">       String result;</div><div class="line">       if (fromCache) &#123;</div><div class="line">           result = jobNodeStorage.getJobNodeData(ConfigurationNode.ROOT);</div><div class="line">           if (null == result) &#123;</div><div class="line">               result = jobNodeStorage.getJobNodeDataDirectly(ConfigurationNode.ROOT);</div><div class="line">           &#125;</div><div class="line">       &#125; else &#123;</div><div class="line">           result = jobNodeStorage.getJobNodeDataDirectly(ConfigurationNode.ROOT);</div><div class="line">       &#125;</div><div class="line">       return LiteJobConfigurationGsonFactory.fromJson(result);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-持久化作业配置"><a href="#3-2-持久化作业配置" class="headerlink" title="3.2 持久化作业配置"></a>3.2 持久化作业配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">  * 持久化分布式作业配置信息.</div><div class="line">  * </div><div class="line">  * @param liteJobConfig 作业配置</div><div class="line">  */</div><div class="line"> public void persist(final LiteJobConfiguration liteJobConfig) &#123;</div><div class="line">     checkConflictJob(liteJobConfig);</div><div class="line">     if (!jobNodeStorage.isJobNodeExisted(ConfigurationNode.ROOT) || liteJobConfig.isOverwrite()) &#123;</div><div class="line">         jobNodeStorage.replaceJobNode(ConfigurationNode.ROOT, LiteJobConfigurationGsonFactory.toJson(liteJobConfig));</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#checkConflictJob(...)</code>方法校验注册中心存储的作业配置的作业实现类全路径（<code>jobClass</code>）和当前的是否相同，如果不同，则认为是冲突，不允许存储：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private void checkConflictJob(final LiteJobConfiguration liteJobConfig) &#123;</div><div class="line">        Optional&lt;LiteJobConfiguration&gt; liteJobConfigFromZk = find();</div><div class="line">        if (liteJobConfigFromZk.isPresent() &amp;&amp; !liteJobConfigFromZk.get().getTypeConfig().getJobClass().equals(liteJobConfig.getTypeConfig().getJobClass())) &#123;</div><div class="line">            throw new JobConfigurationException(&quot;Job conflict with register center. The job &apos;%s&apos; in register center&apos;s class is &apos;%s&apos;, your job class is &apos;%s&apos;&quot;, </div><div class="line">                    liteJobConfig.getJobName(), liteJobConfigFromZk.get().getTypeConfig().getJobClass(), liteJobConfig.getTypeConfig().getJobClass());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>当注册中心未存储该作业配置或者当前作业配置允许替换注册中心配置(<code>overwrite = true</code>)时，持久化作业配置。</li>
</ul>
<h3 id="3-3-校验本机时间是否合法"><a href="#3-3-校验本机时间是否合法" class="headerlink" title="3.3 校验本机时间是否合法"></a>3.3 校验本机时间是否合法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 检查本机与注册中心的时间误差秒数是否在允许范围.</div><div class="line">     * </div><div class="line">     * @throws JobExecutionEnvironmentException 本机与注册中心的时间误差秒数不在允许范围所抛出的异常</div><div class="line">     */</div><div class="line">    public void checkMaxTimeDiffSecondsTolerable() throws JobExecutionEnvironmentException &#123;</div><div class="line">        int maxTimeDiffSeconds =  load(true).getMaxTimeDiffSeconds();</div><div class="line">        if (-1  == maxTimeDiffSeconds) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        long timeDiff = Math.abs(timeService.getCurrentMillis() - jobNodeStorage.getRegistryCenterTime());</div><div class="line">        if (timeDiff &gt; maxTimeDiffSeconds * 1000L) &#123;</div><div class="line">            throw new JobExecutionEnvironmentException(</div><div class="line">                    &quot;Time different between job server and register center exceed &apos;%s&apos; seconds, max time different is &apos;%s&apos; seconds.&quot;, timeDiff / 1000, maxTimeDiffSeconds);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>Elastic-Job-Lite</code>作业触发时依赖本机时间，相同集群使用注册中心为基准，校验本机与注册中心的时间误差是否在允许范围内<code>LiteJobConfiguration.maxTimeDiffSeconds</code></li>
</ul>
<h3 id="4-结语"><a href="#4-结语" class="headerlink" title="4 结语"></a>4 结语</h3><p>这篇文章写作思路是参考别人的，通过这篇文章我提炼出，阅读源码几点技巧：</p>
<ul>
<li>从一个点切入，找到这个点的入口；</li>
<li>按照作者编码的思路去思考，抓住主线，一个个类去梳理</li>
<li>擅加利用IDEA的查看接口实现类的功能；如下展示：</li>
</ul>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-2/35421199.jpg" alt=""></p>
<ul>
<li>从官方文档上，了解到项目有哪些功能，带着问题去看源码；列出你想要了解的功能，一个个去学习；</li>
<li>以类图来梳理整个功能的逻辑，了解每个类，每个属性的含义，而又不会深入到每个方法的具体实现细节。</li>
<li>一次只讨论一个点，每次学习都有一个重心；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h3&gt;&lt;p&gt;涉及到主要类的类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.clouddn.com
    
    </summary>
    
      <category term="ElasticJob" scheme="http://jianwl.com/categories/ElasticJob/"/>
    
    
      <category term="ElasticJob" scheme="http://jianwl.com/tags/ElasticJob/"/>
    
  </entry>
  
  <entry>
    <title>Elastic-Job源码分析---为什么阅读Elastic-Job源码</title>
    <link href="http://jianwl.com/2017/11/01/Elastic-Job%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%85%E8%AF%BBElastic-Job%E6%BA%90%E7%A0%81/"/>
    <id>http://jianwl.com/2017/11/01/Elastic-Job源码分析-为什么阅读Elastic-Job源码/</id>
    <published>2017-11-01T07:25:05.000Z</published>
    <updated>2017-11-01T08:07:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么阅读源码Elastic-Job源码"><a href="#为什么阅读源码Elastic-Job源码" class="headerlink" title="为什么阅读源码Elastic-Job源码"></a>为什么阅读源码Elastic-Job源码</h3><ol>
<li>Quartz多节点通过数据库锁实现任务抢占，Elastic-Job基于什么策略实现任务调度与分配</li>
<li>任务分片如何实现</li>
<li><code>Elastic-Job-Cloud</code>如何实现任务动态扩容和缩容</li>
<li>任务超时如何处理？任务假死怎么判断？</li>
</ol>
<h3 id="步骤-功能"><a href="#步骤-功能" class="headerlink" title="步骤/功能"></a>步骤/功能</h3><ul>
<li>【】分布式调度协调</li>
<li>【】弹性扩容缩容</li>
<li>【】失效转移</li>
<li>【】错过执行作业重触发</li>
<li>【】作业分片策略</li>
<li>【】作业唯一节点执行</li>
<li>【】自诊断并修复分布式不稳定造成的问题</li>
<li>【】支持并行调度</li>
<li>【】支持作业生命周期操作</li>
<li>【】丰富的作业类型</li>
<li>【】Spring整合以及命名空间提供</li>
<li>【】运维平台</li>
<li>【】事件追踪</li>
<li>【】DUMP作业运行信息</li>
<li>【】作业监听器</li>
<li>【】基于Docker的进程隔离（TBD）</li>
<li>【】高可用</li>
</ul>
<h3 id="XXL-JOB"><a href="#XXL-JOB" class="headerlink" title="XXL-JOB"></a>XXL-JOB</h3><p>基于V1.8，会逐步和Elastic-Job功能做对比</p>
<ul>
<li>【】简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手</li>
<li>【】动态：支持动态修改任务状态、暂停/恢复任务、以及终止运行中任务，即时生效；</li>
<li>【】调度中心HA（中心式）：调度采用中心式设计，调度中心基于集群Quartz实现可保证调度中心HA</li>
<li>【】执行器HA（分布式）：任务分布式执行，任务执行器支持集群部署，可保证任务执行HA</li>
<li>【】任务Failover:执行器集群部署时，任务路由策略选择故障转移情况下，调度失败时将会平滑切换执行器进行Failover；</li>
<li>【】一致性：调度中心通过DB锁保证集群分布式调度的一致性，一次任务调度只会触发一次执行；</li>
<li>【】自定义任务参数：支持在线配置调度任务入参，即时生效；</li>
<li>【】调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被阻塞；</li>
<li>【】弹性扩容缩容：一旦有新执行器机器上线或下线，下次调度时将会重新分配任务</li>
<li>【】邮件报警：任务失败时支持邮件报警，支持配置多邮件群发报警邮件</li>
<li>【】状态监控：支持实时监控任务进度</li>
<li>【】Rolling执行日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志</li>
<li>【】GLUE：提供Web IDE,支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程，支持30个版本的历史版本回溯</li>
<li>【】数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性</li>
<li>【】任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会触发一次子任务的执行，多个子任务用逗号分隔；</li>
<li>【】推送maven中央库：将会把最新稳定版本推送到maven中央库，方便用户接入和使用；</li>
<li>【】任务注册：执行器会周期性自动注册任务，调度中心将会自动发现注册的任务并触发执行，同时也支持手动录入执行器地址；</li>
<li>【】路由策略：执行器集群部署时提供丰富的路由策略，包括第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近未使用、故障转移、忙碌转移等；</li>
<li>【】运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器次数等、以及调度报表，如调度日期分布图、调度成功分布图等；</li>
<li>【】脚本任务：支持以GLUE模式开发和运行脚本任务，包括shell、python等类型脚本；</li>
<li>【】阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度、</li>
<li>【】处理失败策略：调度失败时的处理策略，策略包括：失败告警（默认）、失败重试</li>
<li>【】分片广播任务：执行器集群部署时，任务路由策略选择分片广播情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务、同时传递分片参数、可根据分片参数分片开发任务；</li>
<li>【】动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理，在进行大数量业务操作是，可显著提升任务处理能力和速度。</li>
<li>【】事件触发：除了Cron方法和任务依赖方式触发任务执行之外，支持基于事件的触发任务方式，调度中心提供触发任务单次执行的API服务，可根据业务事件灵活触发。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么阅读源码Elastic-Job源码&quot;&gt;&lt;a href=&quot;#为什么阅读源码Elastic-Job源码&quot; class=&quot;headerlink&quot; title=&quot;为什么阅读源码Elastic-Job源码&quot;&gt;&lt;/a&gt;为什么阅读源码Elastic-Job源码&lt;/h3&gt;&lt;
    
    </summary>
    
      <category term="ElasticJob" scheme="http://jianwl.com/categories/ElasticJob/"/>
    
    
      <category term="ElasticJob" scheme="http://jianwl.com/tags/ElasticJob/"/>
    
  </entry>
  
  <entry>
    <title>ElasticJob入门实战</title>
    <link href="http://jianwl.com/2017/11/01/ElasticJob%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/"/>
    <id>http://jianwl.com/2017/11/01/ElasticJob入门实战/</id>
    <published>2017-11-01T03:31:58.000Z</published>
    <updated>2017-11-01T04:42:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h3><p><code>ElasticJob</code>是一个分布式调度解决方案，由两个互相独立的子项目<code>Elastic-Job-Lite</code>和<code>Elastic-Job-Cloud</code>组成。<code>Elastic-Job-Lite</code>定位为轻量级无中心化解决方案，使用jar包形式提供分布式的协调服务。这一节我们将会介绍SpringBoot整合ElasticJob。</p>
<h3 id="2、SpringBoot整合ElasticJob"><a href="#2、SpringBoot整合ElasticJob" class="headerlink" title="2、SpringBoot整合ElasticJob"></a>2、SpringBoot整合ElasticJob</h3><h4 id="1）依赖pom-xml"><a href="#1）依赖pom-xml" class="headerlink" title="1）依赖pom.xml"></a>1）依赖pom.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">	&lt;groupId&gt;com.frank&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;chapter6-4&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class="line">	&lt;packaging&gt;jar&lt;/packaging&gt;</div><div class="line"></div><div class="line">	&lt;name&gt;chapter6-4&lt;/name&gt;</div><div class="line">	&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</div><div class="line"></div><div class="line">	&lt;parent&gt;</div><div class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class="line">		&lt;version&gt;1.4.2.RELEASE&lt;/version&gt;</div><div class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class="line">	&lt;/parent&gt;</div><div class="line"></div><div class="line">	&lt;properties&gt;</div><div class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class="line">		&lt;java.version&gt;1.8&lt;/java.version&gt;</div><div class="line">		&lt;elastic.job.version&gt;2.1.5&lt;/elastic.job.version&gt;</div><div class="line">		&lt;mysql.version&gt;5.1.43&lt;/mysql.version&gt;</div><div class="line">	&lt;/properties&gt;</div><div class="line"></div><div class="line">	&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;com.dangdang&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;elastic-job-lite-core&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;$&#123;elastic.job.version&#125;&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;com.dangdang&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;elastic-job-lite-spring&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;$&#123;elastic.job.version&#125;&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;curator-test&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;4.0.0&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;com.h2database&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;h2&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;1.4.184&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</div><div class="line">			&lt;optional&gt;true&lt;/optional&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;test&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div><div class="line"></div><div class="line">	&lt;build&gt;</div><div class="line">		&lt;plugins&gt;</div><div class="line">			&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class="line">			&lt;/plugin&gt;</div><div class="line">		&lt;/plugins&gt;</div><div class="line">	&lt;/build&gt;</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<h4 id="2）注册中心配置"><a href="#2）注册中心配置" class="headerlink" title="2）注册中心配置"></a>2）注册中心配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">@ConditionalOnExpression(&quot;&apos;$&#123;regCenter.serverList&#125;&apos;.length()&gt;0&quot;)</div><div class="line">public class ZookeeperRegistryCenterConfig &#123;</div><div class="line">    @Bean(initMethod = &quot;init&quot;)</div><div class="line">    public ZookeeperRegistryCenter regCenter(@Value(&quot;$&#123;regCenter.serverList&#125;&quot;) final String serverList,</div><div class="line">                                             @Value(&quot;$&#123;regCenter.namespace&#125;&quot;) final String namespace)&#123;</div><div class="line">        return new ZookeeperRegistryCenter(new ZookeeperConfiguration(serverList,namespace));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-作业事件配置"><a href="#3-作业事件配置" class="headerlink" title="3) 作业事件配置"></a>3) 作业事件配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class JobEventConfig &#123;</div><div class="line"></div><div class="line">    @Resource</div><div class="line">    private DataSource dataSource;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public JobEventConfiguration jobEventConfiguration() &#123;</div><div class="line">        return new JobEventRdbConfiguration(dataSource);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-内嵌Zookeeper配置"><a href="#4-内嵌Zookeeper配置" class="headerlink" title="4) 内嵌Zookeeper配置"></a>4) 内嵌Zookeeper配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class EmbedZookeeperServer &#123;</div><div class="line">    private static TestingServer testingServer;</div><div class="line"></div><div class="line">    public static void start(final int port)&#123;</div><div class="line">        try&#123;</div><div class="line">            testingServer = new TestingServer(port,new File(String.format(&quot;target/test_zk_data/%s/&quot;,System.nanoTime())));</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;finally &#123;</div><div class="line">            Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123;</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(1000L);</div><div class="line">                    testingServer.close();</div><div class="line">                &#125; catch (InterruptedException | IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-基于时间驱动的任务"><a href="#5-基于时间驱动的任务" class="headerlink" title="5) 基于时间驱动的任务"></a>5) 基于时间驱动的任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class SpringSimpleJob implements SimpleJob&#123;</div><div class="line"></div><div class="line">    @Resource</div><div class="line">    private FooRepository fooRepository;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void execute(ShardingContext shardingContext) &#123;</div><div class="line">        System.out.println(String.format(&quot;Item: %s | Time: %s | Thread: %s | %s&quot;,</div><div class="line">                shardingContext.getShardingItem(), new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()), Thread.currentThread().getId(), &quot;SIMPLE&quot;));</div><div class="line">        List&lt;Foo&gt; data = fooRepository.findTodoData(shardingContext.getShardingParameter(), 10);</div><div class="line">        for (Foo each : data) &#123;</div><div class="line">            fooRepository.setCompleted(each.getId());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>模型类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class Foo implements Serializable&#123;</div><div class="line">    private final long id;</div><div class="line">    private final String location;</div><div class="line">    private Status status;</div><div class="line"></div><div class="line">    public Foo(long id, String location, Status status) &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.location = location;</div><div class="line">        this.status = status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public long getId() &#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getLocation() &#123;</div><div class="line">        return location;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Status getStatus() &#123;</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setStatus(Status status) &#123;</div><div class="line">        this.status = status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;Foo&#123;&quot; +</div><div class="line">                &quot;id=&quot; + id +</div><div class="line">                &quot;, location=&apos;&quot; + location + &apos;\&apos;&apos; +</div><div class="line">                &quot;, status=&quot; + status +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public enum Status&#123;</div><div class="line">        TODO,</div><div class="line">        COMPLETED</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Repository</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@Repository</div><div class="line">public class FooRepository &#123;</div><div class="line">    private Map&lt;Long,Foo&gt; data = new ConcurrentHashMap&lt;&gt;(300,1);</div><div class="line"></div><div class="line">    public FooRepository()&#123;init();&#125;</div><div class="line"></div><div class="line">    private void init()&#123;</div><div class="line">        addData(0L, 100L, &quot;Beijing&quot;);</div><div class="line">        addData(100L, 200L, &quot;Shanghai&quot;);</div><div class="line">        addData(200L, 300L, &quot;Guangzhou&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void addData(final Long idFrom,final Long idTo,final String location)&#123;</div><div class="line">        for(long i=idFrom; i &lt; idTo; i++) &#123;</div><div class="line">            data.put(i,new Foo(i,location,Foo.Status.TODO));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public List&lt;Foo&gt; findTodoData(final String location, final int limit) &#123;</div><div class="line">        List&lt;Foo&gt; result = new ArrayList&lt;&gt;(limit);</div><div class="line">        int count = 0;</div><div class="line">        for (Map.Entry&lt;Long, Foo&gt; each : data.entrySet()) &#123;</div><div class="line">            Foo foo = each.getValue();</div><div class="line">            if (foo.getLocation().equals(location) &amp;&amp; foo.getStatus() == Foo.Status.TODO) &#123;</div><div class="line">                result.add(foo);</div><div class="line">                count++;</div><div class="line">                if (count == limit) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCompleted(final long id) &#123;</div><div class="line">        data.get(id).setStatus(Foo.Status.COMPLETED);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-任务注册"><a href="#6-任务注册" class="headerlink" title="6) 任务注册"></a>6) 任务注册</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class SimpleJobConfig &#123;</div><div class="line"></div><div class="line">    @Resource</div><div class="line">    private ZookeeperRegistryCenter regCenter;</div><div class="line"></div><div class="line">    @Resource</div><div class="line">    private JobEventConfiguration jobEventConfiguration;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public SimpleJob simpleJob()&#123;</div><div class="line">        return new SpringSimpleJob();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean(initMethod = &quot;init&quot;)</div><div class="line">    public JobScheduler simpleJobScheduler(final SimpleJob simpleJob, @Value(&quot;$&#123;simpleJob.cron&#125;&quot;) final String cron,</div><div class="line">                                           @Value(&quot;$&#123;simpleJob.shardingTotalCount&#125;&quot;) final int shardingTotalCount,</div><div class="line">                                           @Value(&quot;$&#123;simpleJob.shardingItemParameters&#125;&quot;) final String shardingItemParameters)&#123;</div><div class="line">        return new SpringJobScheduler(simpleJob, regCenter, getLiteJobConfiguration(simpleJob.getClass(), cron, shardingTotalCount, shardingItemParameters), jobEventConfiguration);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private LiteJobConfiguration getLiteJobConfiguration(final Class&lt;? extends SimpleJob&gt; jobClass, final String cron, final int shardingTotalCount, final String shardingItemParameters) &#123;</div><div class="line">        return LiteJobConfiguration.newBuilder(new SimpleJobConfiguration(JobCoreConfiguration.newBuilder(</div><div class="line">                jobClass.getName(), cron, shardingTotalCount).shardingItemParameters(shardingItemParameters).build(), jobClass.getCanonicalName())).overwrite(true).build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-入口类"><a href="#7-入口类" class="headerlink" title="7) 入口类"></a>7) 入口类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">public class Chapter64Application &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		EmbedZookeeperServer.start(6181); // 启动内嵌zookeeper</div><div class="line">		SpringApplication.run(Chapter64Application.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="8-参数配置application-properties"><a href="#8-参数配置application-properties" class="headerlink" title="8) 参数配置application.properties"></a>8) 参数配置application.properties</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">regCenter.serverList=localhost:6181</div><div class="line">regCenter.namespace=elastic-job-lite-springboot</div><div class="line"></div><div class="line">simpleJob.cron=0/30 * * * * ?</div><div class="line">simpleJob.shardingTotalCount=3</div><div class="line">simpleJob.shardingItemParameters=0=Beijing,1=Shanghai,2=Guangzhou</div><div class="line"></div><div class="line">spring.datasource.url=jdbc:h2:mem:job_event_storage</div><div class="line">spring.datasource.driver-class-name=org.h2.Driver</div><div class="line">spring.datasource.username=sa</div><div class="line">spring.datasource.password=</div></pre></td></tr></table></figure>
<h4 id="9-项目源码请移步：SpringBoot整合ElasticJob"><a href="#9-项目源码请移步：SpringBoot整合ElasticJob" class="headerlink" title="9) 项目源码请移步：SpringBoot整合ElasticJob"></a>9) 项目源码请移步：<a href="https://github.com/frank-jian/SpringBootDemo/tree/master/chapter6-4" target="_blank" rel="external">SpringBoot整合ElasticJob</a></h4><h3 id="3、elastic-job-lite-console界面中配置注册中心"><a href="#3、elastic-job-lite-console界面中配置注册中心" class="headerlink" title="3、elastic-job-lite-console界面中配置注册中心"></a>3、<a href="https://github.com/elasticjob/elastic-job/blob/master/elastic-job-lite/elastic-job-lite-console/src/main/java/com/dangdang/ddframe/job/lite/console/ConsoleBootstrap.java" target="_blank" rel="external">elastic-job-lite-console</a>界面中配置注册中心</h3><p>1、启动<a href="https://github.com/elasticjob/elastic-job/blob/master/elastic-job-lite/elastic-job-lite-console/src/main/java/com/dangdang/ddframe/job/lite/console/ConsoleBootstrap.java" target="_blank" rel="external">ConsoleBootstrap.java</a>类，输入账号：root，密码：root</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-1/62773298.jpg" alt=""></p>
<p>2、启动步骤2中SpringBoot整合的ElasticJob项目，在<code>elastic-job-lite-console</code>界面中配置注册中心地址；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-1/48589935.jpg" alt=""></p>
<p>3、连接注册中心</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-1/20731156.jpg" alt=""></p>
<p>4、获取注册中心的任务(另外一个任务文章没有提及注册流程，具体可以看<a href="https://github.com/frank-jian/SpringBootDemo/tree/master/chapter6-4" target="_blank" rel="external">项目源码</a>)</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-1/54676368.jpg" alt=""></p>
<p>5、触发任务</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-11-1/11175796.jpg" alt=""></p>
<h3 id="4、结语"><a href="#4、结语" class="headerlink" title="4、结语"></a>4、结语</h3><p>至此，已经简单介绍了ElasticJob的用法，后续会深入ElasticJob源码学习，深入理解其各个特性实现的思想；</p>
<h3 id="5、参考资料"><a href="#5、参考资料" class="headerlink" title="5、参考资料"></a>5、参考资料</h3><ol>
<li><a href="http://elasticjob.io/index_zh.html" target="_blank" rel="external">Elastic-Job官方文档</a></li>
<li><a href="https://github.com/elasticjob/elastic-job" target="_blank" rel="external">Elastic-Job源码</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、引言&quot;&gt;&lt;a href=&quot;#1、引言&quot; class=&quot;headerlink&quot; title=&quot;1、引言&quot;&gt;&lt;/a&gt;1、引言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ElasticJob&lt;/code&gt;是一个分布式调度解决方案，由两个互相独立的子项目&lt;code&gt;Elastic-J
    
    </summary>
    
      <category term="ElasticJob" scheme="http://jianwl.com/categories/ElasticJob/"/>
    
    
      <category term="ElasticJob" scheme="http://jianwl.com/tags/ElasticJob/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB极简实战入门</title>
    <link href="http://jianwl.com/2017/10/28/MongoDB%E6%9E%81%E7%AE%80%E5%AE%9E%E6%88%98%E5%85%A5%E9%97%A8/"/>
    <id>http://jianwl.com/2017/10/28/MongoDB极简实战入门/</id>
    <published>2017-10-28T01:37:38.000Z</published>
    <updated>2017-10-28T06:12:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、为什么用MongoDB"><a href="#1、为什么用MongoDB" class="headerlink" title="1、为什么用MongoDB?"></a>1、为什么用MongoDB?</h3><p>传统的计算机应用大多数使用关系型数据库来存储数据，比如MySQL,它的特点是数据以表格的形式存储起来，数据库由一张张排列整齐的表格构成，就好像有一个Excel表格一样，每个表格都会有若干列，比如一个学生信息表，可能包含学号、姓名、性别、入学年份、高考成绩、籍贯等。而表格的每一排，则是一个个学生的具体信息。在企业级应用和前互联网时代，关系型数据库几乎是不二选择。关系型数据库的特点是有整齐划一的组织，很方便对数据进行描述、插入、搜索。</p>
<p>想象有一个传统的网上服务商店，它主要的数据可能是存储在一张叫products的表单里，表单可能包含这些列：商品编号id、名称name、商家brank、主目录cate、子目录sub-cat、零售价price、是否促销promotion等，如果有一个用户想要查找所有价格低于300元的正在促销的鞋子的编号和名称，则可以执行类似以下的SQL语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT id, name FROM products WHERE cate=&apos;shoes&apos; AND price &lt; 300 AND promotion = true;</div></pre></td></tr></table></figure></p>
<p>SQL具备了强大的深度查询能力，能满足各式各样的查询要求，而如果要对数据进行添加和删除，成本也是非常低的，这些是SQL的优势之一，随着互联网的兴起以及数据形式的多样化，四平八稳的SQL表单在一些领域渐渐显现出它的劣势，让我们通过一个例子来说明。考虑一个后台系统，如果我们用关系型数据库为每篇博客article创建一个表单的话，这个表单大概会包括以下这些列：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">title</th>
<th style="text-align:center">description</th>
<th style="text-align:center">author</th>
<th style="text-align:center">content</th>
<th style="text-align:center">likes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a_1</td>
<td style="text-align:center">title1</td>
<td style="text-align:center">description1</td>
<td style="text-align:center">author1</td>
<td style="text-align:center">content1</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">a_2</td>
<td style="text-align:center">title2</td>
<td style="text-align:center">description2</td>
<td style="text-align:center">author2</td>
<td style="text-align:center">content1</td>
<td style="text-align:center">13</td>
</tr>
</tbody>
</table>
<p>这个时候用SQL数据库来存储是非常方便的，但假如我们要给每篇文章添加评论功能，会发现每篇文章可能要多篇评论，而且这些数目是动态变化的，而且每篇评论还包括好几项内容：评论人、评论时间、以及评论内容。这时候要将这些内容都塞进上述的表，就显得很困难。通常的做法是为评论comment单独建一个表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">author</th>
<th style="text-align:center">time</th>
<th style="text-align:center">content</th>
<th style="text-align:center">article</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c_1</td>
<td style="text-align:center">anna</td>
<td style="text-align:center">2017-10-26 08:23</td>
<td style="text-align:center">content1</td>
<td style="text-align:center">a_1</td>
</tr>
<tr>
<td style="text-align:center">c_2</td>
<td style="text-align:center">david</td>
<td style="text-align:center">2017-10-26 08:23</td>
<td style="text-align:center">content2</td>
<td style="text-align:center">a_2</td>
</tr>
</tbody>
</table>
<p>类似地，每篇文章可能会有若干标签tags，标签本身又是一个表单：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">category</th>
<th style="text-align:center">tags</th>
<th style="text-align:center">content</th>
<th style="text-align:center">article</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">t_1</td>
<td style="text-align:center">anna</td>
<td style="text-align:center">java</td>
<td style="text-align:center">content1</td>
<td style="text-align:center">a_1</td>
</tr>
<tr>
<td style="text-align:center">t_2</td>
<td style="text-align:center">david</td>
<td style="text-align:center">python</td>
<td style="text-align:center">content2</td>
<td style="text-align:center">a_2</td>
</tr>
</tbody>
</table>
<p>而博客的表格则要通过foreign key跟这些相关联的表格联系起来，这样一来当我们做查询的时候，比如说：找出评论数不少于3的标签为java的作者为author1文章，就会涉及到复杂的跨表查询，需要大量使用join语句。这种跨表查询不仅降低了查询速度，而这些语句写起来也不简单。</p>
<p>那么，如果用MongoDB数据库来实现，可以如何涉及数据模型呢？很简单，想下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">_id: POST_ID</div><div class="line">  title: TITLE_OF_POST, </div><div class="line">  description: POST_DESCRIPTION,</div><div class="line">  author: POST_BY,</div><div class="line">  tags: [TAG1, TAG2, TAG3],</div><div class="line">  likes: TOTAL_LIKES, </div><div class="line">  comments: [	</div><div class="line">     &#123;</div><div class="line">        user:&apos;COMMENT_BY&apos;,</div><div class="line">        message: TEXT,</div><div class="line">        dateCreated: DATE_TIME,</div><div class="line">     &#125;,</div><div class="line">     &#123;</div><div class="line">        user:&apos;COMMENT_BY&apos;,</div><div class="line">        message: TEXT,</div><div class="line">        dateCreated: DATE_TIME,</div><div class="line">     &#125;</div><div class="line">  ]</div></pre></td></tr></table></figure>
<p>在MongoDB里，每篇博客文章以一个文档documen的形式保存起来，而文档内部包含了很多项目，比如title、tags等，每个项目都是key-value形式，重要的是一个key，可以有多个values，它们用[]括起来。</p>
<p>这种宽松的数据存储形式非常灵活，MongoDB不限制每个key对应的values的数目。比如有的文章没有评论，则它的值就是一个空集，完全没有问题；有的文章评论很多，也可以无限制地插入。更灵活的是，MongoDB不要求同一个集合(collection，相当于SQL的table)里面的不同document有相同的key，比如除了上述这种文档组织，有的文档所代表的文章可能没有likes这个项目，在比如有的文章可能有更多的项目。这些不同的文档都可以灵活地存储在同一个集合下，而且查询起来也异常简单，因为都在一个文档里，不用进行各种跨文档查询。而这种MongoDB式的存储也方便了数据的维护，对于每一篇博客文章来说，所有的相关数据都在这个document里面，不用去考虑一个数据库操作需要涉及到多少了表格。</p>
<p>当然，除了上述的优点，MongoDB还有不少别的优势，比如MongoDB的数据是用JSON(Javascript Object Notation)存储的，而几乎所有的web应用都是基于Javascript的。因此，存储数据和应用的数据的格式是高度一致的，不需经过转换，更多关于MongoDB的优点可以看<a href="https://www.tutorialspoint.com/mongodb/mongodb_advantages.htm" target="_blank" rel="external">这篇文章</a></p>
<h3 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h3><h4 id="Mac平台"><a href="#Mac平台" class="headerlink" title="Mac平台"></a>Mac平台</h4><p>1、更新Homebrew的package数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew update</div></pre></td></tr></table></figure>
<p>2、安装MongoDB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew intall mongodb</div></pre></td></tr></table></figure>
<p>3、连接到mongo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongo</div></pre></td></tr></table></figure>
<p>4、推荐安装<a href="https://robomongo.org/" target="_blank" rel="external">MongoDB客户端</a></p>
<h3 id="3、MongoDB实战-以下命令在mongdb客户端执行"><a href="#3、MongoDB实战-以下命令在mongdb客户端执行" class="headerlink" title="3、MongoDB实战(以下命令在mongdb客户端执行)"></a>3、MongoDB实战(以下命令在mongdb客户端执行)</h3><h4 id="1、数据库操作"><a href="#1、数据库操作" class="headerlink" title="1、数据库操作"></a>1、数据库操作</h4><h5 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1) 创建数据库"></a>1) 创建数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">use bd_use</div></pre></td></tr></table></figure>
<p>这样就新建一个叫<code>bd_use</code>的数据库，执行以下指令显示当前的数据库</p>
<h5 id="2-显示当前数据库"><a href="#2-显示当前数据库" class="headerlink" title="2) 显示当前数据库"></a>2) 显示当前数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show databases</div></pre></td></tr></table></figure>
<p>不过由于我们的新数据库是空的，所以会显示类似这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">admin  0.000GB</div><div class="line">local  0.000GB</div></pre></td></tr></table></figure>
<h4 id="2、集合操作"><a href="#2、集合操作" class="headerlink" title="2、集合操作"></a>2、集合操作</h4><h5 id="1-创建集合"><a href="#1-创建集合" class="headerlink" title="1) 创建集合"></a>1) 创建集合</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.createCollection(&apos;users&apos;)</div></pre></td></tr></table></figure>
<p>顺利的话会显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;ok&quot; : 1.0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2）查看当前数据库"><a href="#2）查看当前数据库" class="headerlink" title="2）查看当前数据库"></a>2）查看当前数据库</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/35436214.jpg" alt=""></p>
<h5 id="3）查看数据库集合列表"><a href="#3）查看数据库集合列表" class="headerlink" title="3）查看数据库集合列表"></a>3）查看数据库集合列表</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/99042015.jpg" alt=""></p>
<h5 id="4）移除集合"><a href="#4）移除集合" class="headerlink" title="4）移除集合"></a>4）移除集合</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.users.drop()</div></pre></td></tr></table></figure>
<h4 id="3、新增"><a href="#3、新增" class="headerlink" title="3、新增"></a>3、新增</h4><p>无需先创建集合再新增数据，直接对相应集合新增数据即可；</p>
<h5 id="1）新增1条数据"><a href="#1）新增1条数据" class="headerlink" title="1）新增1条数据:"></a>1）新增1条数据:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">db.bd_charge_info.insert(&#123;</div><div class="line">    id: 1,</div><div class="line">    name: &apos;张三&apos;,</div><div class="line">    city_id: 1,</div><div class="line">    mail: &apos;zhangsan@gmail.com&apos;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>查看数据</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/14240895.jpg" alt=""></p>
<h5 id="2）新增多条数据"><a href="#2）新增多条数据" class="headerlink" title="2）新增多条数据"></a>2）新增多条数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">db.bd_charge_info.insert([</div><div class="line">&#123;</div><div class="line">    id: 2,</div><div class="line">    name: &apos;赵六二&apos;,</div><div class="line">    city_id: 2,</div><div class="line">    mail: &apos;zhaoliuer@gmail.com&apos;,</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">    id: 3,</div><div class="line">    name: &apos;刘二麻子&apos;,</div><div class="line">    city_id: 3,</div><div class="line">    mail: &apos;liuermazi@gmail.com&apos;,</div><div class="line">    register_time: &apos;2017-10-27&apos;</div><div class="line">&#125;</div><div class="line">])</div></pre></td></tr></table></figure>
<p>查看数据</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/95636913.jpg" alt=""></p>
<h4 id="4-查询"><a href="#4-查询" class="headerlink" title="4 查询"></a>4 查询</h4><h5 id="1-单条件查询"><a href="#1-单条件查询" class="headerlink" title="1) 单条件查询"></a>1) 单条件查询</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/28617087.jpg" alt=""></p>
<h5 id="2-多条件查询"><a href="#2-多条件查询" class="headerlink" title="2) 多条件查询"></a>2) 多条件查询</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/1559324.jpg" alt=""></p>
<h5 id="3-查询或条件"><a href="#3-查询或条件" class="headerlink" title="3) 查询或条件"></a>3) 查询或条件</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/22233869.jpg" alt=""></p>
<h5 id="4-区间查询"><a href="#4-区间查询" class="headerlink" title="4) 区间查询"></a>4) 区间查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">大于：$gt</div><div class="line">小于：$lt</div><div class="line">大于或等于:$gte</div><div class="line">小于或等于:$lte</div></pre></td></tr></table></figure>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/93826405.jpg" alt=""></p>
<h5 id="5-分页查询"><a href="#5-分页查询" class="headerlink" title="5) 分页查询"></a>5) 分页查询</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/54991109.jpg" alt=""></p>
<h5 id="6-查询只返回需要的字段"><a href="#6-查询只返回需要的字段" class="headerlink" title="6) 查询只返回需要的字段"></a>6) 查询只返回需要的字段</h5><p>第一个{}为查询条件，第二个{}为返回字段，1表示显示，0表示不显示</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/90600021.jpg" alt=""></p>
<h4 id="5-更新"><a href="#5-更新" class="headerlink" title="5 更新"></a>5 更新</h4><h5 id="1-更新字段"><a href="#1-更新字段" class="headerlink" title="1) 更新字段"></a>1) 更新字段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.bd_charge_info.update(&#123;id: 2&#125;,&#123;$set: &#123;name:&apos;赵六二666&apos;,mai: &apos;zhaoliuer666@gmail.com&apos;&#125;&#125;)</div></pre></td></tr></table></figure>
<p>查看数据</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/38746145.jpg" alt=""></p>
<h4 id="2-增量更新数据"><a href="#2-增量更新数据" class="headerlink" title="2) 增量更新数据"></a>2) 增量更新数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.bd_charge_info.update(&#123;id: 2&#125;,&#123;$inc: &#123;city_id: 2&#125;&#125;)</div></pre></td></tr></table></figure>
<p>查看数据</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/82981085.jpg" alt=""></p>
<h4 id="6、删除"><a href="#6、删除" class="headerlink" title="6、删除"></a>6、删除</h4><h5 id="1）-删除一条记录"><a href="#1）-删除一条记录" class="headerlink" title="1） 删除一条记录"></a>1） 删除一条记录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.bd_charge_info.remove(&#123;id:2&#125;)</div></pre></td></tr></table></figure>
<p>查看数据</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/30082639.jpg" alt=""></p>
<h4 id="7、索引"><a href="#7、索引" class="headerlink" title="7、索引"></a>7、索引</h4><h5 id="1）获取文档的所有索引"><a href="#1）获取文档的所有索引" class="headerlink" title="1）获取文档的所有索引"></a>1）获取文档的所有索引</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/58287318.jpg" alt=""></p>
<h5 id="2）创建索引"><a href="#2）创建索引" class="headerlink" title="2）创建索引"></a>2）创建索引</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/80609873.jpg" alt=""></p>
<p>查看索引</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/24726879.jpg" alt=""></p>
<h5 id="3-移除索引"><a href="#3-移除索引" class="headerlink" title="3) 移除索引"></a>3) 移除索引</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/40728147.jpg" alt=""></p>
<p>查看索引</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/5130353.jpg" alt=""></p>
<h4 id="8、聚合操作"><a href="#8、聚合操作" class="headerlink" title="8、聚合操作"></a>8、聚合操作</h4><h5 id="1）按城市聚合"><a href="#1）按城市聚合" class="headerlink" title="1）按城市聚合"></a>1）按城市聚合</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/49303018.jpg" alt=""></p>
<h5 id="2-城市聚合，并id求和"><a href="#2-城市聚合，并id求和" class="headerlink" title="2) 城市聚合，并id求和"></a>2) 城市聚合，并id求和</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/669500.jpg" alt=""></p>
<h5 id="3-城市聚合，并算出相同城市的个数"><a href="#3-城市聚合，并算出相同城市的个数" class="headerlink" title="3) 城市聚合，并算出相同城市的个数"></a>3) 城市聚合，并算出相同城市的个数</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-10-28/94872900.jpg" alt=""></p>
<h3 id="4、参考资料"><a href="#4、参考资料" class="headerlink" title="4、参考资料"></a>4、参考资料</h3><p>1、<a href="https://github.com/StevenSLXie/Tutorials-for-Web-Developers/blob/master/MongoDB%20%E6%9E%81%E7%AE%80%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8.md" target="_blank" rel="external">MongoDB 极简实践入门</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、为什么用MongoDB&quot;&gt;&lt;a href=&quot;#1、为什么用MongoDB&quot; class=&quot;headerlink&quot; title=&quot;1、为什么用MongoDB?&quot;&gt;&lt;/a&gt;1、为什么用MongoDB?&lt;/h3&gt;&lt;p&gt;传统的计算机应用大多数使用关系型数据库来存储数据
    
    </summary>
    
      <category term="MongoDB" scheme="http://jianwl.com/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://jianwl.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>书单整理</title>
    <link href="http://jianwl.com/2017/10/26/%E4%B9%A6%E5%8D%95%E6%95%B4%E7%90%86/"/>
    <id>http://jianwl.com/2017/10/26/书单整理/</id>
    <published>2017-10-26T03:30:36.000Z</published>
    <updated>2017-10-26T09:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>书单能在你想要打怪升级的路上给予些许帮助，建议先收藏本书单，认真啃完一本再买下一本，扎实走完每一步，部分书单关联博客和微信公众号，书单没有进行分类，大体顺序，编程开发 =&gt; 数据库 =&gt; 架构运维 =&gt; 算法。</p>
<h3 id="书籍列表"><a href="#书籍列表" class="headerlink" title="书籍列表"></a>书籍列表</h3><h4 id="1、《Effective-Java中文版》"><a href="#1、《Effective-Java中文版》" class="headerlink" title="1、《Effective Java中文版》"></a>1、<a href="https://item.jd.com/10058902.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=9db5551f46de481d8cff65b99ad40260" target="_blank" rel="external">《Effective Java中文版》</a></h4><ul>
<li>豆瓣评分：9.1 【1235人评价】</li>
<li>推荐理由：本书介绍了在Java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。</li>
<li>友情提示：同推荐《重构：改善既有代码的设计》、《代码整洁之道》、《代码大全》有一定内容重叠</li>
</ul>
<h4 id="2、《Java性能权威指南》"><a href="#2、《Java性能权威指南》" class="headerlink" title="2、《Java性能权威指南》"></a>2、<a href="https://item.jd.com/11896988.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=4649d7ebe7284a478595eb4cbe89b399" target="_blank" rel="external">《Java性能权威指南》</a></h4><ul>
<li>豆瓣评分：8.2【44人评价】</li>
<li>推荐理由：市面上介绍Java的书有很多，但专注于Java性能的并不多，能游刃有余地展示Java性能优化难点的更是凤毛麟角，本书即是其中之一。通过使用JVM和Java平台，以及Java语言和应用程序接口，本书详尽讲解了Java性能调优的相关知识，帮助读者深入理解Java平台性能的各个方面，最终使程序如虎添翼。</li>
</ul>
<h4 id="3、《Spring揭密》"><a href="#3、《Spring揭密》" class="headerlink" title="3、《Spring揭密》"></a>3、<a href="https://item.jd.com/10063640.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=e5ebdb789c364f23862fdf953f0e0f63" target="_blank" rel="external">《Spring揭密》</a></h4><ul>
<li>豆瓣评分：9.0【162人评价】</li>
<li>推荐理由：Spring使用者不得不读</li>
<li>推荐博客：<a href="http://spring4all.com/" target="_blank" rel="external">Spring4All社区</a></li>
<li>推荐公众号：<a href="http://open.weixin.qq.com/qr/code/?username=spring4all" target="_blank" rel="external">Spring4All社区</a></li>
</ul>
<h4 id="4、《SpringBoot解密》"><a href="#4、《SpringBoot解密》" class="headerlink" title="4、《SpringBoot解密》"></a>4、<a href="https://item.jd.com/11940558.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=66023fea833e4c8f8a5bcac1f5e27017" target="_blank" rel="external">《SpringBoot解密》</a></h4><ul>
<li>豆瓣评分：6.8【44人评价】</li>
<li>推荐理由：《Spring揭密》相同作者，SpringBoot入门书籍</li>
<li>作者博客：<a href="https://afoo.me/" target="_blank" rel="external">扶墙老师说一个架构士的思考与沉淀</a></li>
<li>作者公众号：<a href="https://afoo.me/images/qrcode_for_gh_4fe672b2e860_430.jpg" target="_blank" rel="external">扶墙老师说</a></li>
<li>付费教程：<a href="https://segmentfault.com/ls/1650000011063780" target="_blank" rel="external">《Java 微服务实践 - Spring Boot 系列》</a></li>
</ul>
<h4 id="5、《MyBatis技术内幕》"><a href="#5、《MyBatis技术内幕》" class="headerlink" title="5、《MyBatis技术内幕》"></a>5、<a href="https://item.jd.com/12125531.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=c9571326f34f4ad4b779d7ca40161779" target="_blank" rel="external">《MyBatis技术内幕》</a></h4><ul>
<li>豆瓣评分：暂无</li>
<li>推荐理由：以MyBatis 3.4为基础，针对MyBatis的架构设计和实现细节进行了详细分析，其中穿插介绍了MyBatis源码中涉及的基础知识、设计模式以及笔者自己在实践中的思考。</li>
<li>作者博客：<a href="https://my.oschina.net/zudajun/blog" target="_blank" rel="external">祖大俊的博客</a></li>
</ul>
<h4 id="6、有效的单元测试"><a href="#6、有效的单元测试" class="headerlink" title="6、有效的单元测试"></a>6、<a href="https://item.jd.com/11582394.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=6a9d70686b5246e19559509e551d2118" target="_blank" rel="external">有效的单元测试</a></h4><ul>
<li>豆瓣评分：7.4 【18 人评价】</li>
<li>推荐理由：Java 单元测试入门。</li>
</ul>
<h4 id="7、《Java并发编程实战》"><a href="#7、《Java并发编程实战》" class="headerlink" title="7、《Java并发编程实战》"></a>7、<a href="https://item.jd.com/10922250.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=f4a1f467b1014d7f9c97af819b0fb814" target="_blank" rel="external">《Java并发编程实战》</a></h4><ul>
<li>豆瓣评分：9.0 【651 人评价】</li>
<li>推荐理由：本书深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。</li>
<li>推荐博客：<a href="http://ifeve.com/" target="_blank" rel="external">并发编程网</a></li>
<li>推荐公众号：<a href="http://open.weixin.qq.com/qr/code/?username=ifeves" target="_blank" rel="external">并发编程网</a></li>
</ul>
<h4 id="8、《Netty实战》"><a href="#8、《Netty实战》" class="headerlink" title="8、《Netty实战》"></a>8、<a href="https://item.jd.com/12070975.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=a1ad25055c664e598bda5f663f1d4157" target="_blank" rel="external">《Netty实战》</a></h4><ul>
<li>豆瓣评分：7.5【24 人评价】</li>
<li>豆瓣评分：8.1【83 人评价】 《Netty in Action》英文版</li>
<li>推荐理由：Netty之父Trustin Lee作序推荐。</li>
<li>推荐公众号：<a href="http://open.weixin.qq.com/qr/code/?username=NettyZone" target="_blank" rel="external">Netty之家</a></li>
</ul>
<h4 id="9、《深入剖析Tomcat》"><a href="#9、《深入剖析Tomcat》" class="headerlink" title="9、《深入剖析Tomcat》"></a>9、<a href="https://item.jd.com/10913619.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=33bd504b09414f71b76770638001db97" target="_blank" rel="external">《深入剖析Tomcat》</a></h4><ul>
<li>豆瓣评分：8.3【118 人评价】</li>
<li>豆瓣评分：8.9【73 人评价】 《How Tomcat Works》英文版</li>
<li>推荐理由：本书深入剖析Tomcat 4和Tomcat 5中的每个组件，并揭示其内部工作原理。通过学习本书，你将可以自行开发Tomcat组件，或者扩展已有的组件。</li>
</ul>
<h4 id="10、《深入理解Nginx》"><a href="#10、《深入理解Nginx》" class="headerlink" title="10、《深入理解Nginx》"></a>10、<a href="https://item.jd.com/11217076.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=92163cd0388d41fb8b5872ec1c8c48d9" target="_blank" rel="external">《深入理解Nginx》</a></h4><ul>
<li>豆瓣评分：8.5【138 人评价】</li>
<li>推荐理由：书中首先通过介绍官方Nginx的基本用法和配置规则，帮助读者了解一般Nginx模块的用法，然后重点介绍了如何开发HTTP模块(含HTTP过滤模块)来得到定制化的Nginx，其中包括开发—个功能复杂的模块所需要了解的各种知识，并对内存池的实现细节及TCP协议进行了详细介绍；接着，综合Nginx框架代码分析了Nginx架构的设计理念和技巧，此外，还新增了如何在模块中支持HTTP变量，以及与slab共享内存等相关的内容，相信通过完善，可进一步帮助读者更好地开发出功能丰富、性能—流的Nginx模块。</li>
<li>友情提示：相对适用于 Nginx 开发者。Nginx 使用者可以了解。</li>
</ul>
<h4 id="11、《深入理解Java虚拟机：JVM高级特性与最佳实践》"><a href="#11、《深入理解Java虚拟机：JVM高级特性与最佳实践》" class="headerlink" title="11、《深入理解Java虚拟机：JVM高级特性与最佳实践》"></a>11、<a href="https://item.jd.com/11252778.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=eda3fc1cffd846e0a6cc4865c83047f4" target="_blank" rel="external">《深入理解Java虚拟机：JVM高级特性与最佳实践》</a></h4><ul>
<li>豆瓣评分：8.9 【657 人评价】</li>
<li>推荐理由：不去了解 JVM 的工程师，和咸鱼有什么区别？</li>
<li>推荐公众号：<a href="http://open.weixin.qq.com/qr/code/?username=lovestblog" target="_blank" rel="external">你假笨</a></li>
<li>推荐博客：<a href="http://lovestblog.cn/" target="_blank" rel="external">你假笨@JVM</a></li>
</ul>
<h4 id="12、《Java核心技术系列：Java虚拟机规范（Java-SE-8版）》"><a href="#12、《Java核心技术系列：Java虚拟机规范（Java-SE-8版）》" class="headerlink" title="12、《Java核心技术系列：Java虚拟机规范（Java SE 8版）》"></a>12、<a href="https://item.jd.com/11703581.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=82ba243013084915ad130178cb063f91" target="_blank" rel="external">《Java核心技术系列：Java虚拟机规范（Java SE 8版）》</a></h4><ul>
<li>豆瓣评分：暂无评价</li>
<li>豆瓣评分：8.3 【27 人评价】《Java虚拟机规范(Java SE 7版)》</li>
<li>推荐理由：基于Java SE 8,Oracle官方发布，Java虚拟机技术创建人撰写，国内Java技术专家翻译，是深度了解Java虚拟机和Java语言实现细节的必读之作</li>
<li>推荐博客：<a href="http://www.jianshu.com/u/90ab66c248e6" target="_blank" rel="external">占小狼的简书</a></li>
<li>推荐公众号：<a href="http://upload-images.jianshu.io/upload_images/2184951-2079ac376dbc9c0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external">占小狼的博客</a></li>
</ul>
<h4 id="13、《Go语言编程》"><a href="#13、《Go语言编程》" class="headerlink" title="13、《Go语言编程》"></a>13、<a href="https://item.jd.com/11067810.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=b58705ad1a4a438cb108d604a94cc4f6" target="_blank" rel="external">《Go语言编程》</a></h4><ul>
<li>豆瓣评分：7.1 【444 人评价】</li>
<li>推荐理由：这本书从整体的写作风格来说，会以介绍 Go 语言特性为主，示例则尽量采用作者平常的实践，而不是一个没有太大实际意义的语法示范样例。</li>
<li>友情提示：本书作者背景极强，许式伟为原金山WPS首席架构师、曾是盛大创新院研究员，目前是国内Go语言实践圈子公认的Go语言专家。</li>
</ul>
<h4 id="14、《-Go语言学习笔记》"><a href="#14、《-Go语言学习笔记》" class="headerlink" title="14、《 Go语言学习笔记》"></a>14、<a href="https://item.jd.com/11944267.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=acd310e55c2f49baa6fee671228c00b0" target="_blank" rel="external">《 Go语言学习笔记》</a></h4><ul>
<li>豆瓣评分：8.4 【57 人评价】</li>
<li>推荐理由：基于Go1.6， 解析语言规范，深入剖析Go运行时源码</li>
<li>友情提示：雨痕大大，教科书级人物</li>
</ul>
<h4 id="15、《MySQL技术内幕——InnoDB存储引擎》"><a href="#15、《MySQL技术内幕——InnoDB存储引擎》" class="headerlink" title="15、《MySQL技术内幕——InnoDB存储引擎》"></a>15、<a href="https://item.jd.com/11252326.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=ad40d5df95cd49a2b70cb7fa9de78428" target="_blank" rel="external">《MySQL技术内幕——InnoDB存储引擎》</a></h4><ul>
<li>豆瓣评分：8.6 【104 人评价】</li>
<li>推荐理由：从源代码的角度深度解析了InnoDB的体系结构、实现原理、工作机制，并给出了大量最佳实践，能帮助你系统而深入地掌握InnoDB，更重要的是，它能为你设计管理高性能、高可用的数据库系统提供绝佳的指导。</li>
<li>推荐公众号：<a href="http://open.weixin.qq.com/qr/code/?username=dbaplus" target="_blank" rel="external">DBAplus社群</a></li>
</ul>
<h4 id="16、《高性能MySQL》"><a href="#16、《高性能MySQL》" class="headerlink" title="16、《高性能MySQL》"></a>16、<a href="https://item.jd.com/11220393.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=5e2d58c91b80419a8c600f96d4a8d4b1" target="_blank" rel="external">《高性能MySQL》</a></h4><ul>
<li>豆瓣评分：9.3 【245 人评价】</li>
<li>推荐理由：对于想要了解MySQL性能提升的人来说，这是一本不可多得的书。书中没有各种提升性能的秘籍，而是深入问题的核心，详细的解释了每种提升性能的原理，从而可以使你四两拨千斤。授之于鱼不如授之于渔，这本书做到了。</li>
<li>推荐公众号：<a href="http://open.weixin.qq.com/qr/code/?username=iMYSQL_WX" target="_blank" rel="external">老叶茶馆</a></li>
</ul>
<h4 id="17、《高可用MySQL》"><a href="#17、《高可用MySQL》" class="headerlink" title="17、《高可用MySQL》"></a>17、<a href="https://wqitem.jd.com/item/view?sku=11774353&amp;PTAG=17047.12.1&amp;cu=true&amp;utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=7da2a03f065048e3a87e0ab0b34532eb&amp;abt=3" target="_blank" rel="external">《高可用MySQL》</a></h4><ul>
<li>豆瓣评分：8.0 【87 人评价】</li>
<li>推荐理由：《高性能MySQL》的姊妹篇。</li>
</ul>
<h4 id="18、《MongoDB权威指南》"><a href="#18、《MongoDB权威指南》" class="headerlink" title="18、《MongoDB权威指南》"></a>18、<a href="https://item.jd.com/11384782.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=282adc6929f24a07aa7195c117353076" target="_blank" rel="external">《MongoDB权威指南》</a></h4><ul>
<li>豆瓣评分：8.0 【69 人评价】</li>
<li>推荐理由：算是普通的参考书了，没有特别有深度的讲解。其实就是一本正常的介绍mongoDB是怎么用的，也可以作为nosql学习的入门。作为指南书，还是很合格的符合期望。</li>
<li>推荐博客：<a href="http://mongoing.com/" target="_blank" rel="external">MongoDB 中文社区</a></li>
<li>推荐公众号：<a href="http://open.weixin.qq.com/qr/code/?username=mongoing-com" target="_blank" rel="external">MongoDB 中文社区</a></li>
</ul>
<h4 id="19、《Redis开发与运维》"><a href="#19、《Redis开发与运维》" class="headerlink" title="19、《Redis开发与运维》"></a>19、<a href="https://item.jd.com/12121730.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=0a34adc050b946d283d5afa84e93f9ae" target="_blank" rel="external">《Redis开发与运维》</a></h4><ul>
<li>豆瓣评分：8.8 【41 人评价】</li>
<li>推荐理由：从开发、运维两个角度总结了Redis实战经验，深入浅出地剖析底层实现，包含大规模集群开发与运维的实际案例、应用技巧。全面覆盖Redis 基本功能及应用，图示丰富，讲解细腻。</li>
<li>推荐博客：<a href="http://redis.cn/" target="_blank" rel="external">Redis 中国用户组</a></li>
<li>推荐公众号：<a href="http://open.weixin.qq.com/qr/code/?username=rediscn" target="_blank" rel="external">CRUG</a></li>
</ul>
<h4 id="20、《Redis设计与实现》"><a href="#20、《Redis设计与实现》" class="headerlink" title="20、《Redis设计与实现》"></a>20、<a href="https://item.jd.com/11486101.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=57f3b67147d142e5b76aa501d0e6c4e3" target="_blank" rel="external">《Redis设计与实现》</a></h4><ul>
<li>豆瓣评分：8.5 【427 人评价】</li>
<li>推荐理由：系统而全面地描述了 Redis 内部运行机制。图示丰富，描述清晰，并给出大量参考信息，是NoSQL数据库开发人员案头必备。</li>
</ul>
<h4 id="21、《NoSQL精粹》"><a href="#21、《NoSQL精粹》" class="headerlink" title="21、《NoSQL精粹》"></a>21、<a href="https://item.jd.com/11297782.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=3a24cb49ab394d38bd24edbcb17fae79" target="_blank" rel="external">《NoSQL精粹》</a></h4><ul>
<li>豆瓣评分：8.2 【226 人评价】</li>
<li>推荐理由：书中全方位比较了关系型数据库与NoSQL数据库的异同；分别以Riak、MongoDB、Cassandra和Neo4J为代表，详细讲解了键值数据库、文档数据库、列族数据库和图数据库这4大类NoSQL数据库的优劣势、用法和适用场合；深入探讨了实现NoSQL数据库系统的各种细节，以及与关系型数据库的混用。</li>
</ul>
<h4 id="21、《Elasticsearch权威指南》中文版"><a href="#21、《Elasticsearch权威指南》中文版" class="headerlink" title="21、《Elasticsearch权威指南》中文版"></a>21、<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_who_should_read_this_book.html" target="_blank" rel="external">《Elasticsearch权威指南》中文版</a></h4><ul>
<li>推荐博客：<a href="https://elasticsearch.cn/" target="_blank" rel="external">Elastic 中文社区</a></li>
</ul>
<h4 id="22、-《ELK-Stack权威指南》"><a href="#22、-《ELK-Stack权威指南》" class="headerlink" title="22、 《ELK Stack权威指南》"></a>22、 <a href="https://item.jd.com/12073937.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=cf070e1e547047189a262416e312d14b" target="_blank" rel="external">《ELK Stack权威指南》</a></h4><ul>
<li>豆瓣评分：7.0 【10 人评价】</li>
<li>推荐理由：ELK stack是以Elasticsearch、Logstash、Kibana三个开源软件为主的数据处理工具链，是目前开源界最流行的实时数据分析解决方案，成为实时日志处理领域开源界的第一选择。</li>
</ul>
<h4 id="23、《ZooKeeper：分布式过程协同技术详解》"><a href="#23、《ZooKeeper：分布式过程协同技术详解》" class="headerlink" title="23、《ZooKeeper：分布式过程协同技术详解》"></a>23、<a href="https://item.jd.com/11880788.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=7825abc7598f4c799bc3663a803a7b51" target="_blank" rel="external">《ZooKeeper：分布式过程协同技术详解》</a></h4><ul>
<li>豆瓣评分：7.6 【49 人评价】</li>
<li>推荐理由：Zookeeper 入门</li>
<li>友情提示：翻译可能略显尴尬。</li>
</ul>
<h4 id="24、《从Paxos到Zookeeper分布式一致性原理与实践》"><a href="#24、《从Paxos到Zookeeper分布式一致性原理与实践》" class="headerlink" title="24、《从Paxos到Zookeeper分布式一致性原理与实践》"></a>24、<a href="https://item.jd.com/11622772.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=0c4d1fdbbc104d3bab65e19bdc3d0068" target="_blank" rel="external">《从Paxos到Zookeeper分布式一致性原理与实践》</a></h4><ul>
<li>豆瓣评分：8.1 【187 人评价】</li>
<li>推荐理由：从分布式一致性的理论出发，向读者简要介绍几种典型的分布式一致性协议，以及解决分布式一致性问题的思路，其中重点讲解了Paxos和ZAB协议。同时，本书深入介绍了分布式一致性问题的工业解决方案——ZooKeeper，并着重向读者展示这一分布式协调框架的使用方法、内部实现及运维技巧，旨在帮助读者全面了解ZooKeeper，并更好地使用和运维ZooKeeper。</li>
</ul>
<h4 id="25、《RabbitMQ实战：高效部署分布式消息队列》"><a href="#25、《RabbitMQ实战：高效部署分布式消息队列》" class="headerlink" title="25、《RabbitMQ实战：高效部署分布式消息队列》"></a>25、<a href="https://item.jd.com/11790530.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=70d94d35b9b84e169b999019b56098f8" target="_blank" rel="external">《RabbitMQ实战：高效部署分布式消息队列》</a></h4><ul>
<li>豆瓣评分：6.9 【47 人评价】</li>
<li>推荐理由：本书对RabbitMQ做了全面、翔实的讲解，体现了两位专家的真知灼见。本书首先介绍了有关MQ的历史，然后从基本的消息通信原理讲起，带领读者一路探索RabbitMQ的消息通信世界。</li>
<li>友情提示：本书 RabbitMQ 版本较旧。消息队列中间件 RabbitMQ、ActiveMQ、RocketMQ、Kafka 可以选择了解一下。</li>
</ul>
<h4 id="26、《Apache-Kafka源码剖析》"><a href="#26、《Apache-Kafka源码剖析》" class="headerlink" title="26、《Apache Kafka源码剖析》"></a>26、<a href="https://item.jd.com/12190152.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=755c2bdf8e794669a2e16d5725666ad8" target="_blank" rel="external">《Apache Kafka源码剖析》</a></h4><ul>
<li>豆瓣评分：7.8 【30 人评价】</li>
<li>推荐理由：以Kafka 0.10.0版本源码为基础，针对Kafka的架构设计到实现细节进行详细阐述。</li>
</ul>
<h4 id="27、《作业调度系统-Quartz-中文文档》"><a href="#27、《作业调度系统-Quartz-中文文档》" class="headerlink" title="27、《作业调度系统 Quartz 中文文档》"></a>27、<a href="https://xuzongbao.gitbooks.io/quartz/content/" target="_blank" rel="external">《作业调度系统 Quartz 中文文档》</a></h4><ul>
<li>豆瓣评分：暂无</li>
<li>推荐理由：暂时未找到大家评价不错的 Quartz 实战相关书籍，先推荐看中文翻译的官方文档。如果你有合适的推荐，烦请告诉我。</li>
<li>友情提示：国内开源项目 Elastic-Job，XXL-Job 都可以选择了解。</li>
</ul>
<h4 id="28、《微服务设计》"><a href="#28、《微服务设计》" class="headerlink" title="28、《微服务设计》"></a>28、<a href="https://item.jd.com/11917800.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=96dec37b8bef4983b1d7f730fd092931" target="_blank" rel="external">《微服务设计》</a></h4><ul>
<li>豆瓣评分：8.1 【273 人评价】</li>
<li>推荐理由：通过Netflix等多个业界案例，从微服务架构演进到原理剖析，全面讲解建模集成部署等微服务所涉及的各种主题，微服务架构与实践指南。</li>
</ul>
<h4 id="29、《Spring-Cloud微服务实战》"><a href="#29、《Spring-Cloud微服务实战》" class="headerlink" title="29、《Spring Cloud微服务实战》"></a>29、<a href="https://item.jd.com/12172344.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=02ed7b41b3d24b0f8f4671c44c49f3a9" target="_blank" rel="external">《Spring Cloud微服务实战》</a></h4><ul>
<li>豆瓣评分：7.9【20 人评价】</li>
<li>推荐理由：从时下流行的微服务架构概念出发，详细介绍了Spring Cloud针对微服务架构中几大核心要素的解决方案和基础组件。对于各个组件的介绍，主要以示例与源码结合的方式来帮助读者更好地理解这些组件的使用方法以及运行原理。同时，在介绍的过程中，还包含了作者在实践中所遇到的一些问题和解决思路，可供读者在实践中作为参考。</li>
<li>作者博客：<a href="http://blog.didispace.com/" target="_blank" rel="external">http://blog.didispace.com/</a></li>
<li>作者公众号：<a href="http://blog.didispace.com/css/images/weixin.jpg" target="_blank" rel="external">didispace</a></li>
</ul>
<h4 id="30、《亿级流量网站架构核心技术》"><a href="#30、《亿级流量网站架构核心技术》" class="headerlink" title="30、《亿级流量网站架构核心技术》"></a>30、<a href="https://item.jd.com/12153914.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=5834a1458c2c4f00952e3ce5ef631676" target="_blank" rel="external">《亿级流量网站架构核心技术》</a></h4><ul>
<li>豆瓣评分：7.6【57 人评价】</li>
<li>推荐理由：总结并梳理了亿级流量网站高可用和高并发原则，通过实例详细介绍了如何落地这些原则。本书分为四部分：概述、高可用原则、高并发原则、案例实战。</li>
<li>作者博客：<a href="http://jinnianshilongnian.iteye.com/" target="_blank" rel="external">开涛的博客</a></li>
<li>作者公众号：<a href="http://open.weixin.qq.com/qr/code/?username=kaitao-1234567" target="_blank" rel="external">开涛的博客</a></li>
</ul>
<h4 id="31、《架构即未来：现代企业可扩展的Web架构、流程和组织》"><a href="#31、《架构即未来：现代企业可扩展的Web架构、流程和组织》" class="headerlink" title="31、《架构即未来：现代企业可扩展的Web架构、流程和组织》"></a>31、<a href="https://item.jd.com/11905648.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=1dcd186310304ff9bb7f1ff3a6e9c487" target="_blank" rel="external">《架构即未来：现代企业可扩展的Web架构、流程和组织》</a></h4><ul>
<li>豆瓣评分：8.7【77 人评价】</li>
<li>推荐理由：任何一个持续成长的公司最终都需要解决系统、组织和流程的扩展性问题。本书汇聚了作者从eBay、VISA、Salesforce.com到Apple超过30年的丰富经验， 全面阐释了经过验证的信息技术扩展方法，对所需要掌握的产品和服务的平滑扩展做了详尽的论述，并在第1版的基础上更新了扩展的策略、技术和案例。</li>
</ul>
<h4 id="32、《Zabbix企业级分布式监控系统》"><a href="#32、《Zabbix企业级分布式监控系统》" class="headerlink" title="32、《Zabbix企业级分布式监控系统》"></a>32、<a href="https://item.jd.com/11522142.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=3bcf74726eb949658ae9bc3d82dc02b1" target="_blank" rel="external">《Zabbix企业级分布式监控系统》</a></h4><ul>
<li>豆瓣评分：7.6 【39 人评价】</li>
<li>推荐理由：本书从运维（OPS）角度对Zabbix的各项功能进行了详细介绍，以自动化运维视角为出发点，对Zabbix的安装和配置、自动化功能、监控告警、性能调优、Zabbix API、Zabbix协议、RPM安装包定制，结合SaltStack实现自动化配置管理等内容进行了全方位的深入剖析。</li>
</ul>
<h4 id="33、《第一本Docker书》"><a href="#33、《第一本Docker书》" class="headerlink" title="33、《第一本Docker书》"></a>33、<a href="https://item.jd.com/11909234.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=233f169f48ee4f84a23cabf57e72485a" target="_blank" rel="external">《第一本Docker书》</a></h4><ul>
<li>豆瓣评分：8.8 【63 人评价】</li>
<li>推荐理由：本书由Docker公司前服务与支持副总裁James Turnbull编写，是Docker开发指南。本书专注于Docker 1.9及以上版本，指导读者完成Docker的安装、部署、管理和扩展，带领读者经历从测试到生产的整个开发生命周期，让读者了解Docker适用于什么场景。</li>
<li>推荐博客：<a href="http://dockone.io/" target="_blank" rel="external">DockerOne</a></li>
<li>推荐公众号：<a href="http://open.weixin.qq.com/qr/code/?username=dockerone" target="_blank" rel="external">DockerOne</a></li>
</ul>
<h4 id="34、《Docker——容器与容器云》"><a href="#34、《Docker——容器与容器云》" class="headerlink" title="34、《Docker——容器与容器云》"></a>34、<a href="https://item.jd.com/12052716.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=f3215fb76db24ec4bf140c895fc0944d" target="_blank" rel="external">《Docker——容器与容器云》</a></h4><ul>
<li>豆瓣评分：8.5 【99 人评价】</li>
<li>推荐理由：本书根据Docker 1.10版和Kubernetes 1.2版对第1版进行了全面更新，从实践者的角度出发，以Docker和Kubernetes为重点，沿着“基本用法介绍”到“核心原理解读”到“高级实践技巧”的思路，一本书讲透当前主流的容器和容器云技术，有助于读者在实际场景中利用Docker容器和容器云解决问题并启发新的思考。</li>
</ul>
<h4 id="35、《Kubernetes权威指南》"><a href="#35、《Kubernetes权威指南》" class="headerlink" title="35、《Kubernetes权威指南》"></a>35、<a href="https://item.jd.com/11980349.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=2935d4803df24414b35d41ab0b7f5626" target="_blank" rel="external">《Kubernetes权威指南》</a></h4><p>豆瓣评分：7.7【15 人评价】<br>推荐理由：Kubernetes重磅开山之作，针对Kubernetes v1.6和本书第2版进行大篇幅内容更新，全方位完美覆盖，可借鉴性极强。<br>推荐博客：<a href="https://www.kubernetes.org.cn/" target="_blank" rel="external">Kubernetes 中文社区</a><br>推荐公众号：<a href="http://open.weixin.qq.com/qr/code/?username=kubernetescn" target="_blank" rel="external">K8S 技术社区</a></p>
<h4 id="36、《用Mesos框架构建分布式应用》"><a href="#36、《用Mesos框架构建分布式应用》" class="headerlink" title="36、《用Mesos框架构建分布式应用》"></a>36、<a href="https://item.jd.com/12043093.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=31a6a0687d704012a93019c79b845a89" target="_blank" rel="external">《用Mesos框架构建分布式应用》</a></h4><ul>
<li>豆瓣评分：暂无评分</li>
<li>推荐理由：超级薄的一本书，看完之后，你会对 Mesos 会非常了解，并且极大可能性学会如何基于 Mesos 框架构建分布式应用。</li>
</ul>
<h4 id="37、《数据结构与算法分析：Java语言描述》"><a href="#37、《数据结构与算法分析：Java语言描述》" class="headerlink" title="37、《数据结构与算法分析：Java语言描述》"></a>37、<a href="https://item.jd.com/11886254.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=acc1fd554cdf4b2d9872a745174b005f" target="_blank" rel="external">《数据结构与算法分析：Java语言描述》</a></h4><ul>
<li>豆瓣评分：8.3【183 人评价】</li>
<li>推荐理由：本书是国外数据结构与算法分析方面的经典教材，使用卓越的Java编程语言作为实现工具讨论了数据结构（组织大量数据的方法）和算法分析（对算法运行时间的估计）。</li>
<li>友情提示：算法方法还有其他很好的书籍，例如《算法导论》、《算法（第四版）》，也可以选择阅读。重要的是，保持耐心，享受这个痛并快乐的过程。</li>
</ul>
<h4 id="38、《Head-First-设计模式》"><a href="#38、《Head-First-设计模式》" class="headerlink" title="38、《Head First 设计模式》"></a>38、<a href="https://item.jd.com/10100236.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=6a61dd328ecd43bc906a209498de467d" target="_blank" rel="external">《Head First 设计模式》</a></h4><ul>
<li>豆瓣评分：9.2【2394 人评价】</li>
<li>推荐理由：《Head First设计模式》(中文版)共有14章，每章都介绍了几个设计模式，完整地涵盖了四人组版本全部23个设计模式。</li>
</ul>
<h4 id="39、《HTTP权威指南》"><a href="#39、《HTTP权威指南》" class="headerlink" title="39、《HTTP权威指南》"></a>39、<a href="https://item.jd.com/11056556.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=415194b6c8a64a2abb9a51b055efb1a2" target="_blank" rel="external">《HTTP权威指南》</a></h4><ul>
<li>豆瓣评分：8.7 【1126 人评价】</li>
<li>推荐理由：本书尝试着将HTTP中一些互相关联且常被误解的规则梳理清楚，并编写了一系列基于各种主题的章节，对HTTP各方面的特性进行了介绍。纵观全书，对HTTP“为什么”这样做进行了详细的解释，而不仅仅停留在它是“怎么做”的。</li>
</ul>
<h4 id="40、《TCP-IP详解-系列》"><a href="#40、《TCP-IP详解-系列》" class="headerlink" title="40、《TCP/IP详解 系列》"></a>40、<a href="https://item.jd.com/10057317.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=21aa132de02443148ea06c4c255147e2" target="_blank" rel="external">《TCP/IP详解 系列》</a></h4><ul>
<li>豆瓣评分：9.3 【1883 人评价】</li>
<li>推荐理由：完整而详细的TCP/IP协议指南。针对任何希望理解TCP/IP协议是如何实现的读者设计。</li>
</ul>
<h4 id="41、《Linux内核设计与实现》"><a href="#41、《Linux内核设计与实现》" class="headerlink" title="41、《Linux内核设计与实现》"></a>41、<a href="https://item.jd.com/10664953.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=904940b94eff4b6bb6a19c155dda0fff" target="_blank" rel="external">《Linux内核设计与实现》</a></h4><ul>
<li>豆瓣评分：8.7【286 人评价】</li>
<li>详细描述了Linux内核的主要子系统和特点，包括Linux内核的设计、实现和接口。从理论到实践涵盖了Linux内核的方方面面，可以满足读者的各种兴趣和需求。</li>
<li>友情提示：Linux内核方面不乏好书。本书篇幅方面较为合适。</li>
</ul>
<h4 id="42-《剑指Offer：名企面试官精讲典型编程题》"><a href="#42-《剑指Offer：名企面试官精讲典型编程题》" class="headerlink" title="42 《剑指Offer：名企面试官精讲典型编程题》"></a>42 <a href="https://item.jd.com/12163054.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=050d308787134c908c3ade06a205766f" target="_blank" rel="external">《剑指Offer：名企面试官精讲典型编程题》</a></h4><ul>
<li>豆瓣评分：8.5【508 人评价】</li>
<li>推荐理由：剖析了80个典型的编程面试题，系统整理基础知识、代码质量、解题思路、优化效率和综合能力这5个面试要点。</li>
<li>推荐网站：<a href="https://www.nowcoder.com/" target="_blank" rel="external">牛客网-专业IT笔试面试备考平台</a></li>
</ul>
<h4 id="43-《程序员代码面试指南：IT名企算法与数据结构题目最优解》"><a href="#43-《程序员代码面试指南：IT名企算法与数据结构题目最优解》" class="headerlink" title="43 《程序员代码面试指南：IT名企算法与数据结构题目最优解》"></a>43 <a href="https://item.jd.com/11770838.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=456c96ef91064b0bb1f107dd0bea036c" target="_blank" rel="external">《程序员代码面试指南：IT名企算法与数据结构题目最优解》</a></h4><ul>
<li>豆瓣评分：8.4【32 人评价】</li>
<li>推荐理由：程序员刷题宝典！编程能力提升秘笈！精选IT名企真实代码面试题，全面覆盖算法与数据结构题型！</li>
</ul>
<h4 id="44-《领域驱动设计》"><a href="#44-《领域驱动设计》" class="headerlink" title="44 《领域驱动设计》"></a>44 <a href="https://item.jd.com/11961038.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=e263bb9daa91485295956fe59455107c" target="_blank" rel="external">《领域驱动设计》</a></h4><ul>
<li>豆瓣评分：9.0【115 人评价】</li>
<li>推荐理由：是领域驱动设计方面的经典之作。全书围绕着设计和开发实践，结合若干真实的项目案例，向读者阐述如何在真实的软件开发中应用领域驱动设计。</li>
<li>友情提示：理论的书籍往往较为枯燥，勤修内功是必须走的路。</li>
</ul>
<h4 id="45、《火球-UML大战需求分析》"><a href="#45、《火球-UML大战需求分析》" class="headerlink" title="45、《火球:UML大战需求分析》"></a>45、<a href="https://item.jd.com/10932134.html?utm_source=other_x_short&amp;utm_medium=tuiguang&amp;utm_campaign=t_1000388308_&amp;utm_term=da62a9177e3145c79bcbc36abbdc86c6" target="_blank" rel="external">《火球:UML大战需求分析》</a></h4><ul>
<li>豆瓣评分：7.9【115 人评价】</li>
<li>推荐理由：融合UML、非UML、需求分析及需求管理等各方面的知识，帮助读者解决UML业界问题、需求分析及需求管理问题。</li>
<li>友情提示：可能不是最好的 UML 书籍，但从是否能够阅读理解完的角度来说，本书可能是相对合适的。有兴趣的同学也可以看看《UML和模式应用》、《大象：Thinking in UML》。</li>
</ul>
<h3 id="ToDO-List"><a href="#ToDO-List" class="headerlink" title="ToDO List"></a>ToDO List</h3><h4 id="待推荐书籍"><a href="#待推荐书籍" class="headerlink" title="待推荐书籍"></a>待推荐书籍</h4><ul>
<li>TODO 《大数据日知录 架构与算法》</li>
<li>TODO 《大型网站系统与Java中间件实践》</li>
<li>TODO 《HotSpot实战》</li>
<li>TODO 《垃圾回收的算法与实现》</li>
<li>TODO 《彩色UML建模》</li>
<li>TODO 《七周七并发模型》</li>
</ul>
<h4 id="技术领域归纳"><a href="#技术领域归纳" class="headerlink" title="技术领域归纳"></a>技术领域归纳</h4><ul>
<li>[] Go</li>
<li>[] Node</li>
<li>[] Linux内核</li>
<li>[] UML</li>
<li>[] Tomcat</li>
<li>[x] SpringCloud</li>
<li>[x] Java基础</li>
<li>[] Netty</li>
<li>[x] Mybatis</li>
<li>[x] 数据库</li>
<li>[] MongoDB</li>
<li>[x] Maven</li>
<li>[] DevOps</li>
<li>[] 运维</li>
<li>[] 面试</li>
<li>[] 消息队列</li>
<li>[x] 设计模式</li>
<li>[] 算法与数据结构</li>
<li>[] Zookeeper</li>
<li>[x] SpringBoot</li>
<li>[] Nginx</li>
<li>[] 定时任务</li>
<li>[] 搜索引擎</li>
<li>[x] 协议</li>
<li>[x] 单元测试</li>
<li>[x] 重构</li>
<li>[] 日志</li>
<li>[] Docker</li>
<li>[] 监控</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://www.iocoder.cn/Architecture/books-recommended/" target="_blank" rel="external">书单整理</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;书单能在你想要打怪升级的路上给予些许帮助，建议先收藏本书单，认真啃完一本再买下一本，扎实走完每一步，部分书单关联博客和微信公众号，书单没有进
    
    </summary>
    
      <category term="书单" scheme="http://jianwl.com/categories/%E4%B9%A6%E5%8D%95/"/>
    
    
      <category term="书单" scheme="http://jianwl.com/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Elasticsearch</title>
    <link href="http://jianwl.com/2017/10/25/SpringBoot%E6%95%B4%E5%90%88Elasticsearch/"/>
    <id>http://jianwl.com/2017/10/25/SpringBoot整合Elasticsearch/</id>
    <published>2017-10-25T04:40:07.000Z</published>
    <updated>2017-10-25T10:49:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一年以前曾接触过ES，但后续因为没有相关的业务需求，荒废了这一块的进修；近期因朋友问到相关问题，故重新拾起。之前学的基本忘的差不多了，索性从头学起；这一节，主要来学习如何通过SpringBoot来整合ES，从环境的搭建、到源码的实战来学习ES；</p>
<h3 id="1、本地ES搭建"><a href="#1、本地ES搭建" class="headerlink" title="1、本地ES搭建"></a>1、本地ES搭建</h3><p>1）<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-2-4-4" target="_blank" rel="external">官方ES 2.4.4 版本</a></p>
<p>为什么不用最新版版本呢？因为Spring Data Elasticsearch的版本目前只支持5.00以下的版本，详情可以看这<a href="https://github.com/spring-projects/spring-data-elasticsearch/wiki/Spring-Data-Elasticsearch---Spring-Boot---version-matrix" target="_blank" rel="external">版本对应关系</a>。</p>
<p>2）解压 具体可以看<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/_installation.html" target="_blank" rel="external">ES安装官方文档</a>。</p>
<p>3）修改 ${ES_HOME}/config/elasticsearch.yml文件,设置cluster.name;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cluster.name: frank_cluster</div></pre></td></tr></table></figure>
<p>4) 启动ES服务</p>
<h3 id="2、SpringBoot整合ES实战"><a href="#2、SpringBoot整合ES实战" class="headerlink" title="2、SpringBoot整合ES实战"></a>2、SpringBoot整合ES实战</h3><h4 id="1-pom-xml-添加依赖"><a href="#1-pom-xml-添加依赖" class="headerlink" title="1) pom.xml 添加依赖"></a>1) pom.xml 添加依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;1.2.39&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line"></div><div class="line">		&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class="line">			&lt;scope&gt;test&lt;/scope&gt;</div><div class="line">		&lt;/dependency&gt;</div><div class="line">	&lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<h4 id="2）创建数据模型User"><a href="#2）创建数据模型User" class="headerlink" title="2）创建数据模型User"></a>2）创建数据模型User</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">@Document(indexName = &quot;frank&quot;, type = &quot;user&quot;)</div><div class="line">public class User &#123;</div><div class="line">    @Id</div><div class="line">    private Long id;</div><div class="line"></div><div class="line">    private String userName;</div><div class="line"></div><div class="line">    private String userPhone;</div><div class="line"></div><div class="line">    public User() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public User(Long id, String userName, String userPhone) &#123;</div><div class="line">        this.id = id;</div><div class="line">        this.userName = userName;</div><div class="line">        this.userPhone = userPhone;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Long getId() &#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setId(Long id) &#123;</div><div class="line">        this.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getUserName() &#123;</div><div class="line">        return userName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setUserName(String userName) &#123;</div><div class="line">        this.userName = userName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getUserPhone() &#123;</div><div class="line">        return userPhone;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setUserPhone(String userPhone) &#123;</div><div class="line">        this.userPhone = userPhone;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;User&#123;&quot; +</div><div class="line">                &quot;id=&quot; + id +</div><div class="line">                &quot;, userName=&apos;&quot; + userName + &apos;\&apos;&apos; +</div><div class="line">                &quot;, userPhone=&apos;&quot; + userPhone + &apos;\&apos;&apos; +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-Dao层"><a href="#3-Dao层" class="headerlink" title="3) Dao层"></a>3) Dao层</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface UserRepository extends ElasticsearchRepository&lt;User,Long&gt; &#123;</div><div class="line">    /**</div><div class="line">     * 根据用户名，获取用户分页列表</div><div class="line">     * @param userName 用户名</div><div class="line">     * @param pageable 分页模型</div><div class="line">     * @return 分页用户列表</div><div class="line">     */</div><div class="line">    Page&lt;User&gt; findByUserName(String userName, Pageable pageable);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据用户手机号，获取用户列表</div><div class="line">     * @param userPhone 用户手机</div><div class="line">     * @return  用户列表</div><div class="line">     */</div><div class="line">    List&lt;User&gt; findByUserPhone(String userPhone);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-Service层-接口"><a href="#4-Service层-接口" class="headerlink" title="4) Service层 - 接口"></a>4) Service层 - 接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface UserService &#123;</div><div class="line">    User save(User user);</div><div class="line"></div><div class="line">    void deleteByUserId(Long userId);</div><div class="line"></div><div class="line">    User findByUserId(Long userId);</div><div class="line"></div><div class="line">    Iterable&lt;User&gt; findAll();</div><div class="line"></div><div class="line">    Page&lt;User&gt; findByUserName(String userName, PageRequest pageRequest);</div><div class="line"></div><div class="line">    List&lt;User&gt; findByUserPhone(String userPhone);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5）Service层-实现类"><a href="#5）Service层-实现类" class="headerlink" title="5）Service层 - 实现类"></a>5）Service层 - 实现类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@Service</div><div class="line">public class UserServiceImpl implements UserService &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private UserRepository userRepository;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public User save(User user) &#123;</div><div class="line">        return userRepository.save(user);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void deleteByUserId(Long userId) &#123;</div><div class="line">        userRepository.delete(userId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public User findByUserId(Long userId) &#123;</div><div class="line">        return userRepository.findOne(userId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Iterable&lt;User&gt; findAll() &#123;</div><div class="line">        return userRepository.findAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Page&lt;User&gt; findByUserName(String userName, PageRequest pageRequest) &#123;</div><div class="line">        return userRepository.findByUserName(userName,pageRequest);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public List&lt;User&gt; findByUserPhone(String userPhone) &#123;</div><div class="line">        return userRepository.findByUserPhone(userPhone);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-入口"><a href="#6-入口" class="headerlink" title="6) 入口"></a>6) 入口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">public class Chapter411Application implements CommandLineRunner &#123;</div><div class="line">	@Autowired</div><div class="line">	private UserService userService;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run(String... args) throws Exception &#123;</div><div class="line">		System.out.println(&quot;&lt;&lt;&lt;&lt;&lt;&lt; Elasticsearch 初始化数据开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);</div><div class="line">		userService.save(new User(1L,&quot;张三&quot;,&quot;18817394122&quot;));</div><div class="line">		userService.save(new User(2L,&quot;李四&quot;,&quot;18817394132&quot;));</div><div class="line">		userService.save(new User(3L,&quot;王二麻子&quot;,&quot;18817394142&quot;));</div><div class="line">		userService.save(new User(4L,&quot;赵六子&quot;,&quot;18817394152&quot;));</div><div class="line">		System.out.println(&quot;&lt;&lt;&lt;&lt;&lt;&lt; Elasticsearch 初始化数据结束 &gt;&gt;&gt;&gt;&gt;&gt;&gt;\n\n&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		SpringApplication.run(Chapter411Application.class, args);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-修改配置文件application-properties"><a href="#7-修改配置文件application-properties" class="headerlink" title="7) 修改配置文件application.properties"></a>7) 修改配置文件application.properties</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">spring.data.elasticsearch.cluster-name=frank_cluster</div><div class="line">spring.data.elasticsearch.cluster-nodes=localhost:9300</div></pre></td></tr></table></figure>
<h4 id="8-测试类"><a href="#8-测试类" class="headerlink" title="8) 测试类"></a>8) 测试类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@RunWith(SpringRunner.class)</div><div class="line">@SpringBootTest</div><div class="line">public class Chapter410ApplicationTests &#123;</div><div class="line"></div><div class="line">	@Autowired</div><div class="line">	private UserService userService;</div><div class="line"></div><div class="line">	@Test</div><div class="line">	public void test_001()&#123;</div><div class="line">		List&lt;User&gt; userList = new ArrayList&lt;&gt;();</div><div class="line">		Iterator&lt;User&gt; iterator = userService.findAll().iterator();</div><div class="line">		while (iterator.hasNext())&#123;</div><div class="line">			userList.add(iterator.next());</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;userList =&gt; &quot; + JSON.toJSONString(userList));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Test</div><div class="line">	public void test_002()&#123;</div><div class="line">		Page&lt;User&gt; userPage = userService.findByUserName(&quot;张三&quot;,new PageRequest(0,10));</div><div class="line">		System.out.println(&quot;element nums =&gt; &quot; + userPage.getTotalElements());</div><div class="line">		System.out.println(&quot;user page =&gt; &quot; + JSON.toJSONString(userPage.getContent()));</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	@Test</div><div class="line">	public void test_003()&#123;</div><div class="line">		System.out.println(JSON.toJSONString(userService.findByUserId(1L)));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Test</div><div class="line">	public void test_004()&#123;</div><div class="line">		System.out.println(JSON.toJSONString(userService.findByUserPhone(&quot;18817394122&quot;)));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Test</div><div class="line">	public void test_005()&#123;</div><div class="line">		userService.deleteByUserId(1L);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、遇到的坑"><a href="#3、遇到的坑" class="headerlink" title="3、遇到的坑"></a>3、遇到的坑</h3><p>1、 由于SpringDataElasticsearch只支持5.0以下的版本，而本地装了ES5.6版本，导致报错；具体错误如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Caused by: org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available: [&#123;#transport#-1&#125;&#123;localhost&#125;&#123;127.0.0.1:9300&#125;]</div></pre></td></tr></table></figure>
<p>解决办法：将本地ES由5.6版本降到2.46版本即可；</p>
<p>2、单机启动时，当往ES存入数据时，因为不存在备份分片，导致系统健康值为黄色；</p>
<p>解决办法：再次启动ES服务即可；</p>
<h3 id="4、本项目源码"><a href="#4、本项目源码" class="headerlink" title="4、本项目源码"></a>4、本项目源码</h3><p><a href="https://github.com/frank-jian/SpringBootDemo/tree/master/chapter4-11" target="_blank" rel="external">SpringBoot整合ES源码</a></p>
<h3 id="5、参考资料"><a href="#5、参考资料" class="headerlink" title="5、参考资料"></a>5、参考资料</h3><p>1、<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-data-elasticsearch" target="_blank" rel="external">spring-boot-sample-data-elasticsearch</a></p>
<p>2、<a href="http://www.mkyong.com/spring-boot/spring-boot-spring-data-elasticsearch-example/" target="_blank" rel="external">Spring Boot + Spring Data + Elasticsearch example</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一年以前曾接触过ES，但后续因为没有相关的业务需求，荒废了这一块的进修；近期因朋友问到相关问题，故重新拾起。之前学的基本忘的差不多了，索性从
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://jianwl.com/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="http://jianwl.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>ShadowsocksX在配置文件设置server列表</title>
    <link href="http://jianwl.com/2017/10/21/ShadowsocksX%E5%9C%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AEserver%E5%88%97%E8%A1%A8/"/>
    <id>http://jianwl.com/2017/10/21/ShadowsocksX在配置文件设置server列表/</id>
    <published>2017-10-21T08:44:56.000Z</published>
    <updated>2017-10-21T09:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Mac上使用ShadowsocksX客户端，之前都是一台一台服务器手动添加的，但是服务器太多就想能不能通过配置文件来设置。接下来我们来演示下，在Mac下如何通过配置文件来设置服务列表。</p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><h4 id="1、-Shadowsocks客户端在Mac下的配置文件的位置"><a href="#1、-Shadowsocks客户端在Mac下的配置文件的位置" class="headerlink" title="1、 Shadowsocks客户端在Mac下的配置文件的位置"></a>1、 Shadowsocks客户端在Mac下的配置文件的位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/Library/Preferences/clowwindy.ShadowsocksX.plist</div></pre></td></tr></table></figure>
<h4 id="2、plist文件是什么"><a href="#2、plist文件是什么" class="headerlink" title="2、plist文件是什么?"></a>2、plist文件是什么?</h4><blockquote>
<p>在OS X的Cocoa，NeXTSTEP和GNUstep编程框架中，属性列表（Property List）文件是一种用来存储序列化后的对象的文件。属性列表文件的文件扩展名为.plist，因此通常被称为plist文件。Plist文件通常用于储存用户设置，也可以用于存储捆绑的信息。——Wikipedia</p>
</blockquote>
<h4 id="3、将plist转成可读的xml"><a href="#3、将plist转成可读的xml" class="headerlink" title="3、将plist转成可读的xml"></a>3、将plist转成可读的xml</h4><p><strong>注意：</strong> 在修改plist <strong>前请务必备份</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plutil -convert xml1 ~/Library/Preferences/clowwindy.ShadowsocksX.plist -o xxx.xml</div></pre></td></tr></table></figure>
<p>在<key>config</key>字段下的<data>字段就是保存了现有服务器信息的字段，整个复制出来，base63解码(OSX的base64工具在从stdin读入数据的时候有长度限制，建议先保存到文件再读入)</data></p>
<h4 id="4、base64解码服务列表信息"><a href="#4、base64解码服务列表信息" class="headerlink" title="4、base64解码服务列表信息"></a>4、base64解码服务列表信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">base64 -D -i /path/to/file -o -</div></pre></td></tr></table></figure>
<p>-D 表示解码，-i 表示读入的文件路径，-o – 表示输出解码结果到 stdout，也可以保存到新文件方便编辑。</p>
<p>修改后base64编码填回xml(不加-D选项即是编码)</p>
<h4 id="5、将xml转回plist"><a href="#5、将xml转回plist" class="headerlink" title="5、将xml转回plist"></a>5、将xml转回plist</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plutil -convert binary1 xxx.xml -o yyy.plist</div></pre></td></tr></table></figure>
<h4 id="6、重新载入plist"><a href="#6、重新载入plist" class="headerlink" title="6、重新载入plist"></a>6、重新载入plist</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults import clowwindy.ShadowsocksX /path/to/yyy.plist</div></pre></td></tr></table></figure>
<h4 id="7、重启shadowsocksX客户端，即可看到新配置已经载入"><a href="#7、重启shadowsocksX客户端，即可看到新配置已经载入" class="headerlink" title="7、重启shadowsocksX客户端，即可看到新配置已经载入"></a>7、重启shadowsocksX客户端，即可看到新配置已经载入</h4><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1、<a href="https://www.starduster.me/2016/04/02/mac-shadowsocksx-config-file-to-os-x-user-default-plist/" target="_blank" rel="external">从 ShadowsocksX 客户端配置文件说到 OS X user default plist</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在Mac上使用ShadowsocksX客户端，之前都是一台一台服务器手动添加的，但是服务器太多就想能不能通过配置文件来设置。接下来我们来演示
    
    </summary>
    
      <category term="Mac" scheme="http://jianwl.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://jianwl.com/tags/Mac/"/>
    
  </entry>
  
</feed>
