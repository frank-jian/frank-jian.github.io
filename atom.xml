<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录点滴成长</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianwl.com/"/>
  <updated>2017-08-27T15:29:35.000Z</updated>
  <id>http://jianwl.com/</id>
  
  <author>
    <name>流云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础-异常</title>
    <link href="http://jianwl.com/2017/08/27/java%E5%9F%BA%E7%A1%80-%E5%BC%82%E5%B8%B8/"/>
    <id>http://jianwl.com/2017/08/27/java基础-异常/</id>
    <published>2017-08-27T14:12:18.000Z</published>
    <updated>2017-08-27T15:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-异常类图"><a href="#1-异常类图" class="headerlink" title="1. 异常类图"></a>1. 异常类图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/72172724.jpg" alt=""></p>
<h3 id="2-受检异常-VS-非受检异常"><a href="#2-受检异常-VS-非受检异常" class="headerlink" title="2. 受检异常 VS 非受检异常"></a>2. 受检异常 VS 非受检异常</h3><blockquote>
<p>受检异常：继承Exception的子类，需要明确去处理异常；</p>
<p>非受检异常：继承RuntimeException的子类，不需要明确去处理异常；</p>
</blockquote>
<p>非受检异常：继承RuntimeException的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class UncheckedException extends RuntimeException &#123;</div><div class="line">    public UncheckedException() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public UncheckedException(String message) &#123;</div><div class="line">        super(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public UncheckedException(String message, Throwable cause) &#123;</div><div class="line">        super(message, cause);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>受检异常：继承Exception的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class CheckedException extends Exception&#123;</div><div class="line">    public CheckedException() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CheckedException(String message) &#123;</div><div class="line">        super(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CheckedException(String message, Throwable cause) &#123;</div><div class="line">        super(message, cause);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举个例子：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/70188955.jpg" alt=""></p>
<p>如图可知，受检异常必须要处理，否则会报错；非受检异常，可以不处理；</p>
<h3 id="3-StackOverFlowError-VS-OutOfMemoryError"><a href="#3-StackOverFlowError-VS-OutOfMemoryError" class="headerlink" title="3. StackOverFlowError VS OutOfMemoryError"></a>3. StackOverFlowError VS OutOfMemoryError</h3><blockquote>
<p>stackOverFlowError: 与栈相关，所有本地变量和方法调用都存于栈，每次方法的调用都会创建栈空间，一旦方法执行完毕栈空间将回收；</p>
<p>outOfMemoryError:与堆相关，创建的对象引用存于堆中，当JVM尝试给新对象分配内存时，没有足够的堆内存，将抛出OOM。</p>
</blockquote>
<p>stackOverFlowError举例：无限递归方法</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/23183251.jpg" alt=""></p>
<p>outOfMemoryError举例：创建超大对象</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/80401561.jpg" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://stackoverflow.com/questions/11435613/whats-the-difference-between-stackoverflowerror-and-outofmemoryerror" target="_blank" rel="external">What’s the difference between StackOverflowError and OutOfMemoryError</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-异常类图&quot;&gt;&lt;a href=&quot;#1-异常类图&quot; class=&quot;headerlink&quot; title=&quot;1. 异常类图&quot;&gt;&lt;/a&gt;1. 异常类图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.clouddn.com/17-8-27/7
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>java基础-集合梳理</title>
    <link href="http://jianwl.com/2017/08/27/java%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%E6%A2%B3%E7%90%86/"/>
    <id>http://jianwl.com/2017/08/27/java基础-集合梳理/</id>
    <published>2017-08-27T06:58:37.000Z</published>
    <updated>2017-08-27T08:53:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Map类图-不包含java-util-concurrent包的类"><a href="#1-Map类图-不包含java-util-concurrent包的类" class="headerlink" title="1. Map类图(不包含java.util.concurrent包的类)"></a>1. Map类图(不包含java.util.concurrent包的类)</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/64952891.jpg" alt=""></p>
<h3 id="2-List类图-整理部分常用"><a href="#2-List类图-整理部分常用" class="headerlink" title="2. List类图(整理部分常用)"></a>2. List类图(整理部分常用)</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/83565321.jpg" alt=""></p>
<h3 id="3-Set类图整理-不包含java-util-concurrent包的类"><a href="#3-Set类图整理-不包含java-util-concurrent包的类" class="headerlink" title="3. Set类图整理(不包含java.util.concurrent包的类)"></a>3. Set类图整理(不包含java.util.concurrent包的类)</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/89594162.jpg" alt=""></p>
<h3 id="4-集合类图整理"><a href="#4-集合类图整理" class="headerlink" title="4. 集合类图整理"></a>4. 集合类图整理</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-8-27/57993384.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Map类图-不包含java-util-concurrent包的类&quot;&gt;&lt;a href=&quot;#1-Map类图-不包含java-util-concurrent包的类&quot; class=&quot;headerlink&quot; title=&quot;1. Map类图(不包含java.util.co
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>泛型中extends和super的区别?</title>
    <link href="http://jianwl.com/2017/08/27/%E6%B3%9B%E5%9E%8B%E4%B8%ADextends%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://jianwl.com/2017/08/27/泛型中extends和super的区别/</id>
    <published>2017-08-27T05:10:19.000Z</published>
    <updated>2017-08-27T05:11:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://itimetraveler.github.io/2016/12/27/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B%E4%B8%AD%20extends%20%E5%92%8C%20super%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/" target="_blank" rel="external">【Java】泛型中 extends 和 super 的区别？</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://itimetraveler.github.io/2016/12/27/%E3%
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>高效实用Python字典的清单</title>
    <link href="http://jianwl.com/2017/08/22/%E9%AB%98%E6%95%88%E5%AE%9E%E7%94%A8Python%E5%AD%97%E5%85%B8%E7%9A%84%E6%B8%85%E5%8D%95/"/>
    <id>http://jianwl.com/2017/08/22/高效实用Python字典的清单/</id>
    <published>2017-08-22T14:22:12.000Z</published>
    <updated>2017-08-22T15:07:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>字典(dict)对象是Python最常用的数据结构，这里整理了几个关于高效实用字典的清单，希望Python开发者可以在日常应用开发中合理利用，让代码更加Pythonic。</p>
<h3 id="1、用in关键字检查key是否存在"><a href="#1、用in关键字检查key是否存在" class="headerlink" title="1、用in关键字检查key是否存在"></a>1、用in关键字检查key是否存在</h3><p>Python之禅中有一句开发哲学是:</p>
<blockquote>
<p>There should be one – and perferably only one –obvious way to do it.</p>
</blockquote>
<p>尽量找一种，最好是唯一一种显而易见的解决方案。Python2中判断某个key是否存在字典中可使用<code>has_key</code>方法，另外一种方式是使用<code>in</code>关键字。但强烈推荐后者，因为in的处理速度更快，另外一个原因是<code>has_key</code>这个方法在Python3被移除了。</p>
<p>bad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">info = dict(name=&apos;zhangsan&apos;,age=23)</div><div class="line">if info.has_key(&apos;name&apos;):</div><div class="line">   pass</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">info = dict(name=&apos;zhangsan&apos;,age=23)</div><div class="line">if &apos;name&apos; in info:</div><div class="line">   pass</div></pre></td></tr></table></figure>
<h3 id="2、用get获取字典中的值"><a href="#2、用get获取字典中的值" class="headerlink" title="2、用get获取字典中的值"></a>2、用get获取字典中的值</h3><p>关于获取字典的值，一种简单的方式就是用d[x]访问元素，但是这种情况在key不存在的情况下会报KeyError错误，当然你可以先用in操作检查key是否在字典中在获取，不过这种方式不符合Python之禅中说的：</p>
<blockquote>
<p>Simple is better then complex<br>Flat is better than nested.</p>
</blockquote>
<p>好的代码应该是简单易懂的，扁平的代码结构更加可读。所以我们可以使用get方法来替代if … else.</p>
<p>bad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">d = dict(name=&apos;python&apos;)</div><div class="line">if &apos;name&apos; in d:</div><div class="line">    print d[&apos;hello&apos;]</div><div class="line">else:</div><div class="line">	 print &apos;default&apos;</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print d.get(&apos;name&apos;,&apos;default&apos;)</div></pre></td></tr></table></figure>
<h3 id="3、用setdefault为字典中不存在的key设置缺省值"><a href="#3、用setdefault为字典中不存在的key设置缺省值" class="headerlink" title="3、用setdefault为字典中不存在的key设置缺省值"></a>3、用setdefault为字典中不存在的key设置缺省值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data = [(&apos;animal&apos;,&apos;bear&apos;),(&apos;animal,&apos;duck&apos;),(&apos;plant&apos;,&apos;catus&apos;),(&apos;vehicle&apos;,&apos;speed boat&apos;),(&apos;vehicle&apos;,&apos;school bus&apos;)]</div></pre></td></tr></table></figure>
<p>在做分类统计时，希望把同一类型的数据归到字典中的某种类型中，比如上面代码，把相同类型的事物用列表形式重新组装，得到新字典。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data = dict(animal=[&apos;bear&apos;,&apos;duck&apos;],plant=[&apos;cacuts&apos;],vehicle=[&apos;speed boat&apos;,&apos;school bus&apos;])</div></pre></td></tr></table></figure>
<p>普通的方式就是先判断key是否存在，如果不存在则要先用列表对象进行初始化，在执行后续操作。而更好的方式就是使用字典中的setdefault方法。</p>
<p>bad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">groups = &#123;&#125;</div><div class="line">for (key,value) in data:</div><div class="line">    if key in groups:</div><div class="line">       groups[key].append(value)</div><div class="line">    else:</div><div class="line">       groups[key] = [value]</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">groups = &#123;&#125;</div><div class="line">for (key,value) in data:</div><div class="line">    groups.setdefault(key,[]).append(value)</div></pre></td></tr></table></figure>
<p><code>setdefault</code>的作用是：</p>
<ol>
<li>如果key存在与字典中，那么直接返回对应的值，等效于get</li>
<li>如果key不存在字典中，则会用setdefault中的第二个参数作为该key的值，在返回该值。</li>
</ol>
<h3 id="4、用字典实现swith-…-case语句"><a href="#4、用字典实现swith-…-case语句" class="headerlink" title="4、用字典实现swith … case语句"></a>4、用字典实现swith … case语句</h3><p>Python中没有switch…case语句，这个问题Python之父龟叔表示这个语法过去没有，现在没有，以后也不会有。因为Python简洁的语法完全可以用if…elif实现。如果有太多的分支判断，还可以使用字典来代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if arg == 0:</div><div class="line">  return &apos;zero&apos;</div><div class="line">elif arg == 1:</div><div class="line">  return &apos;one&apos;</div><div class="line">elif arg == 2:</div><div class="line">  return &apos;two&apos;</div><div class="line">elif arg == 3:</div><div class="line">  return &apos;three&apos;</div><div class="line">else:</div><div class="line">  return &apos;nothing&apos;</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data = dict(0=&apos;zero&apos;,1=&apos;one&apos;,2=&apos;two&apos;,3=&apos;three&apos;)</div><div class="line">data.get(arg,&quot;nothing&quot;)</div></pre></td></tr></table></figure>
<h3 id="5、使用items迭代字典中的元素"><a href="#5、使用items迭代字典中的元素" class="headerlink" title="5、使用items迭代字典中的元素"></a>5、使用items迭代字典中的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data = dict(0=&apos;zero&apos;,1=&apos;one&apos;,2=&apos;two&apos;,3=&apos;three&apos;)</div><div class="line">for k,v in data.items():</div><div class="line">  print k,v</div></pre></td></tr></table></figure>
<h3 id="6、使用字典推导式"><a href="#6、使用字典推导式" class="headerlink" title="6、使用字典推导式"></a>6、使用字典推导式</h3><p>推导式是个绝妙的东西，列表推导式一出，map、filter等函数黯然失色，至python2.7以后的版本，此特性扩展到了字典和集合身上，构建字典对象无需调用dict方法。</p>
<p>bad</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">numbers = [1,2,3]</div><div class="line">d = dict([(number,number*2) for number in numbers])</div></pre></td></tr></table></figure>
<p>good</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">numbers = [1,2,3]</div><div class="line">d = &#123;number: number * 2 for number in numbers&#125;</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://juejin.im/post/599c03e751882511264e7428" target="_blank" rel="external">高效使用Python字典</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;字典(dict)对象是Python最常用的数据结构，这里整理了几个关于高效实用字典的清单，希望Python开发者可以在日常应用开发中合理利用
    
    </summary>
    
      <category term="Python" scheme="http://jianwl.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jianwl.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>cp -r without hidden files</title>
    <link href="http://jianwl.com/2017/08/16/cp-r-without-hidden-files/"/>
    <id>http://jianwl.com/2017/08/16/cp-r-without-hidden-files/</id>
    <published>2017-08-16T03:56:14.000Z</published>
    <updated>2017-08-16T03:57:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><a href="https://stackoverflow.com/questions/11557114/cp-r-without-hidden-files" target="_blank" rel="external">cp-r-without-hidden-files</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/11557114/cp
    
    </summary>
    
      <category term="Linux" scheme="http://jianwl.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://jianwl.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Webpack入门篇</title>
    <link href="http://jianwl.com/2017/08/15/Webpack%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://jianwl.com/2017/08/15/Webpack入门篇/</id>
    <published>2017-08-15T09:16:19.000Z</published>
    <updated>2017-08-15T09:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li><a href="http://www.jianshu.com/p/42e11515c10f" target="_blank" rel="external">入门Webpack，看这篇就够了</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/42e11515c10f&quot; target=&quot;
    
    </summary>
    
      <category term="Webpack" scheme="http://jianwl.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://jianwl.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Java服务化系统线上应急和技术攻关，你必须掌握的Linux命令</title>
    <link href="http://jianwl.com/2017/07/22/Java%E6%9C%8D%E5%8A%A1%E5%8C%96%E7%B3%BB%E7%BB%9F%E7%BA%BF%E4%B8%8A%E5%BA%94%E6%80%A5%E5%92%8C%E6%8A%80%E6%9C%AF%E6%94%BB%E5%85%B3%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84Linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://jianwl.com/2017/07/22/Java服务化系统线上应急和技术攻关，你必须掌握的Linux命令/</id>
    <published>2017-07-22T12:51:16.000Z</published>
    <updated>2017-07-23T03:32:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文并不是Linux命令的手册，而是侧重于命令在特定场景如何帮助应急人员和攻关人员定位问题并解决问题，因此，对于每个命令的介绍将直切主题，直接介绍命令的具体场景，而不是介绍命令的详细使用格式。</p>
<h3 id="1-必不可少的基础命令和工具"><a href="#1-必不可少的基础命令和工具" class="headerlink" title="1. 必不可少的基础命令和工具"></a>1. 必不可少的基础命令和工具</h3><h4 id="1-1-grep"><a href="#1-1-grep" class="headerlink" title="1.1 grep"></a>1.1 grep</h4><p><code>grep</code>是<code>Linux</code>下通用的文本内容查找命令。</p>
<p>也可以利用它打印匹配的上下几行，线上查找问题的时候，可以使用以下命令,查找关键字，显示关键字出现的后5行，并且给关键字着色。</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">grep -5 &apos;pattern&apos; INPUT_FILE # 打印匹配行的前后5行</div><div class="line"></div><div class="line">grep -C 5 &apos;pattern&apos; INPUT_FILE # 打印匹配行的前后5行</div><div class="line"></div><div class="line">grep -A 5 &apos;pattern&apos; INPUT_FILE # 打印匹配行的后5行</div><div class="line"></div><div class="line">grep -B 5 &apos;pattern&apos; INPUT_FILE # 打印匹配行的前5行</div></pre></td></tr></table></figure>
<h4 id="1-2-find"><a href="#1-2-find" class="headerlink" title="1.2 find"></a>1.2 find</h4><p>通过文件名称查找文件的所在位置，名称查找支持模糊匹配</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name FILE_NAME</div></pre></td></tr></table></figure>
<p>命令输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@10-9-179-71 ~]# find . -name GifApiApplication.java</div><div class="line">./app/Gif-Api/src/main/java/com/budong/GifApiApplication.java</div></pre></td></tr></table></figure>
<h4 id="1-3-uptime"><a href="#1-3-uptime" class="headerlink" title="1.3 uptime"></a>1.3 uptime</h4><p>查看机器的启动时间、登录用户、平均负载等情况，通常用在线上应急或者技术攻关的时候来确定操作系统的重启时间。</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uptime</div></pre></td></tr></table></figure>
<p>命令输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[jianweilin@login10-103-142 ~]$ uptime</div><div class="line"> 10:35:13 up 698 days, 19:30,  3 users,  load average: 0.20, 0.13, 0.04</div></pre></td></tr></table></figure>
<p>从上面输出可以看到如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1、 当前时间：10:35:13</div><div class="line"></div><div class="line">2、 系统已运行的时间：698天19个小时30分钟</div><div class="line"></div><div class="line">3、当前在线用户：3个用户</div><div class="line"></div><div class="line">4. 系统平均负载：0.20 、0.13 、 0.04，最近1分钟、5分钟、15分钟系统的负载情况</div></pre></td></tr></table></figure>
<p>系统平均负载指在特定时间间隔内队列中运行的平均进程数，如果一个进程满足一下条件，它就会位于运行队列中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1、它没有在等待IO操作的结果</div><div class="line"></div><div class="line">2、它没有主动进入等待状态（也就是没有调用wait相关的系统API）</div><div class="line"></div><div class="line">3、没有被停止（例如：等待终止）</div></pre></td></tr></table></figure>
<p>一般来说，每个CPU内核对应活动进程数不大于3，则系统运行良好，换句话说，也就是活动进程数小于CPU核数的3倍。</p>
<p>举例说明，如果你的服务CPU有3个核心，那么只要uptime最后输出的一串字符数值小于9，即表示系统负载正常。但是，如果系统负载超过10，那就表示当前系统负载过重，需要定位系统执行任务负载超标的原因。</p>
<h4 id="1-4-lsof"><a href="#1-4-lsof" class="headerlink" title="1.4 lsof"></a>1.4 lsof</h4><p>列出系统当前打开的文件句柄，在Linux文件系统中，任何资源都是以文件句柄的形式管理的。例如：硬件设备、文件、网络套接字等，系统内部为每一种资源分配一个句柄，应用程序只能用操作系统分配的句柄来引用资源，因此，文件句柄为应用程序与基础操作系统之间的交互提供了通用的操作接口。</p>
<p>应用程序打开文件的描述列表包含大量的关于应用程序本身的运行信息，因此通过lsof工具查看这个文件句柄列表，对系统监控以及应急排错提供重要的帮助。</p>
<p>查看某一个进程打开的文件句柄：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@10-9-179-71 ~]# lsof -p 12988 | less</div><div class="line">COMMAND   PID USER   FD   TYPE             DEVICE SIZE/OFF     NODE NAME</div><div class="line">java    12988 root  cwd    DIR              252,1     4096   917916 /root/app/Gif-Api</div><div class="line">java    12988 root  rtd    DIR              252,1     4096        2 /</div><div class="line">java    12988 root  txt    REG              252,1     7718   400499 /usr/java/jdk1.7.0_80/bin/java</div><div class="line">java    12988 root  mem    REG              252,1 99170352   292284 /usr/lib/locale/locale-archive</div><div class="line">java    12988 root  mem    REG              252,1   111440   786852 /lib64/libresolv-2.12.so</div><div class="line">java    12988 root  mem    REG              252,1    27896   786492 /lib64/libnss_dns-2.12.so</div><div class="line">java    12988 root  mem    REG              252,1    90880   795901 /lib64/libgcc_s-4.4.7-20120601.</div><div class="line">so.1</div><div class="line">java    12988 root  mem    REG              252,1  1025172   663136 /usr/java/jdk1.7.0_80/jre/lib/e</div><div class="line">xt/localedata.jar</div><div class="line">java    12988 root  mem    REG              252,1   196468   663055 /usr/java/jdk1.7.0_80/jre/lib/e</div><div class="line">xt/sunjce_provider.jar</div></pre></td></tr></table></figure>
<h4 id="1-5-ulimit"><a href="#1-5-ulimit" class="headerlink" title="1.5 ulimit"></a>1.5 ulimit</h4><p>Linux系统为每个登录用户，都限制其最大进程数和打开的最大文件句柄数。为提供性能，可以根据硬件资源的具体情况，设置各个用户的最大进程数和打开的最大文件句柄数。</p>
<p>可以用<code>ulimit -a</code>来显示当前的各种系统对用户使用资源的限制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[root@10-9-179-71 ~]# ulimit -a</div><div class="line">core file size          (blocks, -c) unlimited</div><div class="line">data seg size           (kbytes, -d) unlimited</div><div class="line">scheduling priority             (-e) 0</div><div class="line">file size               (blocks, -f) unlimited</div><div class="line">pending signals                 (-i) 15356</div><div class="line">max locked memory       (kbytes, -l) 64</div><div class="line">max memory size         (kbytes, -m) unlimited</div><div class="line">open files                      (-n) 1000000</div><div class="line">pipe size            (512 bytes, -p) 8</div><div class="line">POSIX message queues     (bytes, -q) 819200</div><div class="line">real-time priority              (-r) 0</div><div class="line">stack size              (kbytes, -s) 10240</div><div class="line">cpu time               (seconds, -t) unlimited</div><div class="line">max user processes              (-u) 15356</div><div class="line">virtual memory          (kbytes, -v) unlimited</div><div class="line">file locks                      (-x) unlimited</div></pre></td></tr></table></figure>
<p>设置用户的最大进程数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ulimit -u 10240</div></pre></td></tr></table></figure>
<p>设置用户可以打开的最大文件句柄数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ulimit -n 10240</div></pre></td></tr></table></figure>
<h4 id="1-6-curl"><a href="#1-6-curl" class="headerlink" title="1.6 curl"></a>1.6 curl</h4><p>程序开发后，会使用Junit、Testng以及Jmock、Mockito进行单元测试，单元测试后需要进行集成测试，由于当前的线上服务较多使用Restful风格，那么集成测试的时候就需要进行HTTP调用，查看返回的结果是否符合预期，curl命令是首选测试的方法。</p>
<p>使用方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 打印请求响应头信息</div><div class="line">[root@10-9-179-71 ~]# curl -i https://bdapi.imdada.cn/health/check</div><div class="line">HTTP/1.1 200 OK</div><div class="line">Server: openresty</div><div class="line">Date: Sun, 23 Jul 2017 03:15:09 GMT</div><div class="line">Content-Type: application/json;charset=UTF-8</div><div class="line">Transfer-Encoding: chunked</div><div class="line">Connection: keep-alive</div><div class="line">&#123;&quot;status&quot;:&quot;ok&quot;,&quot;content&quot;:&quot;ok&quot;&#125;</div><div class="line"></div><div class="line"># 打印HTTP响应码</div><div class="line">[root@10-9-179-71 ~]# curl -I https://bdapi.imdada.cn/health/check</div><div class="line">HTTP/1.1 200 OK</div><div class="line">Server: openresty</div><div class="line">Date: Sun, 23 Jul 2017 03:16:45 GMT</div><div class="line">Content-Type: application/json;charset=UTF-8</div><div class="line">Content-Length: 30</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure>
<h4 id="1-7-scp"><a href="#1-7-scp" class="headerlink" title="1.7 scp"></a>1.7 scp</h4><p>scp命令是Linux系统中功能强大的文件传输命令，可以实现从本地到远程以及远程到本地的双向文件传输，用起来非常的方便。常用来在线上定位问题时，将线上的一些文件下载到本地进行查看，或者将本地的修改上传到服务器上。</p>
<p>使用方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">scp jianweilin@192.168.1.1:/home/jianweilin/test.txt</div><div class="line"></div><div class="line">scp ./test.txt jianweilin@192.168.1.1:/home/jianweilin/</div></pre></td></tr></table></figure></p>
<h4 id="1-8-vi-amp-vim"><a href="#1-8-vi-amp-vim" class="headerlink" title="1.8 vi &amp; vim"></a>1.8 vi &amp; vim</h4><p>vi和vim是Linux中最常用的命令行文本编辑工具，vim是vi的升级版本，在某些Linux版本下，vi实际上通过软链接指向vim。</p>
<p>常用vi/vim命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">1、h: 左移一个字符</div><div class="line"></div><div class="line">2、l: 有移一个字符</div><div class="line"></div><div class="line">3、k: 上移一个字符</div><div class="line"></div><div class="line">4、j: 下移一个字符</div><div class="line"></div><div class="line">5、set number: 显示行号</div><div class="line"></div><div class="line">6、shift + g: 移动到最后一行</div><div class="line"></div><div class="line">7、1 + shift + g: 移动到第一行</div><div class="line"></div><div class="line">8、n + shift + g: 移动到第n行</div><div class="line"></div><div class="line">9、0: 移动到行首</div><div class="line"></div><div class="line">10、$: 移动到行尾</div><div class="line"></div><div class="line">11、 /text: 查到text，按n键查找下一个，按N查找前一个</div><div class="line"></div><div class="line">12、 ?text: 查找text，按n键查找下一个，按N查找前一个</div><div class="line"></div><div class="line">13、i: 在当前位置前插入</div><div class="line"></div><div class="line">14、I: 在当前行首插入</div><div class="line"></div><div class="line">15、a: 在当前位置后插入</div><div class="line"></div><div class="line">16、A: 在当前行尾插入</div><div class="line"></div><div class="line">17、o: 在当前行之后插入一行</div><div class="line"></div><div class="line">18、O: 在当前行之前插入一行</div><div class="line"></div><div class="line">19、%s/old/new/g：用old替换new，替换当前行的所有匹配</div><div class="line"></div><div class="line">20、ctrl + f：向下滚动一屏</div><div class="line"></div><div class="line">21、ctrl + b：向上滚动一屏</div><div class="line"></div><div class="line">22、u：撤销</div><div class="line"></div><div class="line">23、U：撤销对整行的操作</div><div class="line"></div><div class="line">24、Ctrl + r：重做，即撤销的撤销</div><div class="line"></div><div class="line">25、x：删除当前字符</div><div class="line"></div><div class="line">26、dd：删除当前行</div><div class="line"></div><div class="line">27、10d：删除当前行开始的10行</div><div class="line"></div><div class="line">28、yy：拷贝当前行</div><div class="line"></div><div class="line">29、p：在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行</div><div class="line">粘贴</div><div class="line"></div><div class="line">30、：wq：保存并退出</div><div class="line"></div><div class="line">31、：q!：强制退出并忽略所有更改</div></pre></td></tr></table></figure>
<p>未完待续…</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.jianshu.com/p/6fc923ceb722" target="_blank" rel="external">Java服务化系统线上应急和技术攻关，你必须掌握的Linux命令</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文并不是Linux命令的手册，而是侧重于命令在特定场景如何帮助应急人员和攻关人员定位问题并解决问题，因此，对于每个命令的介绍将直切主题，直
    
    </summary>
    
      <category term="Linux" scheme="http://jianwl.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://jianwl.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Flask-SQLAlchemy: Can&#39;t reconnect until invalid transaction is rolled back</title>
    <link href="http://jianwl.com/2017/07/20/Flask-SQLAlchemy-Can-t-reconnect-until-invalid-transaction-is-rolled-back/"/>
    <id>http://jianwl.com/2017/07/20/Flask-SQLAlchemy-Can-t-reconnect-until-invalid-transaction-is-rolled-back/</id>
    <published>2017-07-20T13:17:45.000Z</published>
    <updated>2017-07-20T13:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近来在做些Python的重构工作，今日屡次出现这个错误；</p>
<p> <img src="http://oc5a5l0a0.bkt.clouddn.com/17-7-20/81011645.jpg" alt=""></p>
<p>由日志可知，在查询<code>bd_charge_info</code>这张表时，由于存在没有提交的事务，导致了查询失败；于是查了MYSQL数据库的事务状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SHOW ENGINE INNODB STATUS</div></pre></td></tr></table></figure>
<p>查询结果：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-7-20/50146776.jpg" alt=""></p>
<p>至此确认了问题所在。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://imysql.com/2015/03/25/mysql-faq-how-to-fetch-latest-trxid.shtml" target="_blank" rel="external">如何查看当前最新事务ID</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;近来在做些Python的重构工作，今日屡次出现这个错误；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://oc5a5l0a0.bkt.cl
    
    </summary>
    
      <category term="Python" scheme="http://jianwl.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://jianwl.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>2017的小目标</title>
    <link href="http://jianwl.com/2017/07/19/2017%E7%9A%84%E5%B0%8F%E7%9B%AE%E6%A0%87/"/>
    <id>http://jianwl.com/2017/07/19/2017的小目标/</id>
    <published>2017-07-19T14:58:27.000Z</published>
    <updated>2017-07-19T15:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>已经到年中了，给后半年设定一些小目标；</p>
<h3 id="小目标制定"><a href="#小目标制定" class="headerlink" title="小目标制定"></a>小目标制定</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-7-19/17630389.jpg" alt=""></p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-7-19/90166218.jpg" alt=""></p>
<h3 id="7月份小目标"><a href="#7月份小目标" class="headerlink" title="7月份小目标"></a>7月份小目标</h3><p>7月份的学习主要以巩固基础为主，熟悉JVM参数配置 &amp; 泛读JVM官方文档</p>
<p>【10h】泛读<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/" target="_blank" rel="external">The Java Virtual Machine Specification</a></p>
<p>【20h】精读《深入理解JAVA虚拟机》并输出笔记</p>
<h3 id="7月份进展"><a href="#7月份进展" class="headerlink" title="7月份进展"></a>7月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="8月份小目标"><a href="#8月份小目标" class="headerlink" title="8月份小目标"></a>8月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="8月份进展"><a href="#8月份进展" class="headerlink" title="8月份进展"></a>8月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="9月份小目标"><a href="#9月份小目标" class="headerlink" title="9月份小目标"></a>9月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="9月份进展"><a href="#9月份进展" class="headerlink" title="9月份进展"></a>9月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="10月份小目标"><a href="#10月份小目标" class="headerlink" title="10月份小目标"></a>10月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="10月份进展"><a href="#10月份进展" class="headerlink" title="10月份进展"></a>10月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="11月份小目标"><a href="#11月份小目标" class="headerlink" title="11月份小目标"></a>11月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="11月份进展"><a href="#11月份进展" class="headerlink" title="11月份进展"></a>11月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="12月份小目标"><a href="#12月份小目标" class="headerlink" title="12月份小目标"></a>12月份小目标</h3><p>// 还没轮到我呢…</p>
<h3 id="12月份进展"><a href="#12月份进展" class="headerlink" title="12月份进展"></a>12月份进展</h3><p>// 还没轮到我呢…</p>
<h3 id="全年总结"><a href="#全年总结" class="headerlink" title="全年总结"></a>全年总结</h3><p>// 还没轮到我呢…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已经到年中了，给后半年设定一些小目标；&lt;/p&gt;
&lt;h3 id=&quot;小目标制定&quot;&gt;&lt;a href=&quot;#小目标制定&quot; class=&quot;headerlink&quot; title=&quot;小目标制定&quot;&gt;&lt;/a&gt;小目标制定&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.
    
    </summary>
    
      <category term="小目标" scheme="http://jianwl.com/categories/%E5%B0%8F%E7%9B%AE%E6%A0%87/"/>
    
    
      <category term="小目标" scheme="http://jianwl.com/tags/%E5%B0%8F%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>JAVA之生产者-消费者模式</title>
    <link href="http://jianwl.com/2017/06/21/JAVA%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/21/JAVA之生产者-消费者模式/</id>
    <published>2017-06-21T08:50:53.000Z</published>
    <updated>2017-06-21T10:48:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>生产者-消费者模式是一个经典的多线程设计模式，它为多线程的协作提供了良好的解决方案。在生产者与消费者模式中，通常有两类线程，即若干个生产者线程和若干个消费者线程。<strong>生产者线程负责提交用户请求，消费者线程负责具体处理生产者提交的任务</strong>；</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/QQ20170621-170501@2x.png" alt=""></p>
<p>生产者-消费者模式的核心组件是共享内存缓冲区，它作为生产者和消费者间的通信桥梁，避免了生产者和消费者的直接通信，从而将生产者和消费者进行解耦，生产者不需要知道消费者的存在，消费者也不需要知道生产者的存在。</p>
<p>同时，由于内存缓冲区的存在，允许生产者和消费者在执行速度上存在时间差，无论是生产者在某一局部时间内速度高于消费者，或是消费者在局部时间内高于生产者，都可以通过共享内存缓冲区得到缓解，确保系统正常运行。</p>
<h3 id="2-生产者-消费者模式主要角色"><a href="#2-生产者-消费者模式主要角色" class="headerlink" title="2. 生产者-消费者模式主要角色"></a>2. 生产者-消费者模式主要角色</h3><table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>生产者</td>
<td>用于提交用户请求，提取用户任务，并装入内存缓冲区</td>
</tr>
<tr>
<td>消费者</td>
<td>在内存缓冲区中提取并处理任务</td>
</tr>
<tr>
<td>内存缓冲区</td>
<td>缓冲生产者提交的任务或数据，供消费者使用</td>
</tr>
<tr>
<td>任务</td>
<td>生产者向内存缓冲区提交的数据结构</td>
</tr>
<tr>
<td>Main</td>
<td>使用生产者和消费者的客户端</td>
</tr>
</tbody>
</table>
<h3 id="3-类图"><a href="#3-类图" class="headerlink" title="3. 类图"></a>3. 类图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-21/96135924.jpg" alt=""></p>
<h3 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h3><h4 id="1-共享数据模型不可变类PCData"><a href="#1-共享数据模型不可变类PCData" class="headerlink" title="1) 共享数据模型不可变类PCData"></a>1) 共享数据模型不可变类<code>PCData</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public final class PCData &#123;</div><div class="line">    private final int intData;</div><div class="line"></div><div class="line">    public PCData(int d) &#123;</div><div class="line">        intData = d;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public PCData(String d) &#123;</div><div class="line">        intData = Integer.valueOf(d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getIntData() &#123;</div><div class="line">        return intData;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;data:&quot; + intData;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-生产者Producer"><a href="#2-生产者Producer" class="headerlink" title="2) 生产者Producer"></a>2) 生产者<code>Producer</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Producer implements Runnable &#123;</div><div class="line">    private volatile boolean isRunning = true;</div><div class="line">    private BlockingQueue&lt;PCData&gt; queue;</div><div class="line">    private static AtomicInteger count = new AtomicInteger();</div><div class="line"></div><div class="line">    private static final int SLEEP_TIME = 100;</div><div class="line"></div><div class="line">    public Producer(BlockingQueue&lt;PCData&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        PCData data = null;</div><div class="line">        Random r = new Random();</div><div class="line">        System.out.println(&quot;start producer id =&quot; + Thread.currentThread().getId());</div><div class="line"></div><div class="line">        try&#123;</div><div class="line">            while (isRunning) &#123;</div><div class="line">                Thread.sleep(r.nextInt(SLEEP_TIME));</div><div class="line">                // 构造任务数据</div><div class="line">                data = new PCData(count.incrementAndGet());</div><div class="line">                System.out.println(data + &quot; is put into queue&quot;);</div><div class="line">                if (!queue.offer(data,2, TimeUnit.SECONDS)) &#123;</div><div class="line">                    System.err.println(&quot;fail to put data: &quot; + data);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void stop() &#123;</div><div class="line">        isRunning = false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-消费者Consumer"><a href="#3-消费者Consumer" class="headerlink" title="3) 消费者Consumer"></a>3) 消费者<code>Consumer</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Consumer implements Runnable &#123;</div><div class="line">    private BlockingQueue&lt;PCData&gt; queue;</div><div class="line">    private static final int SLEEP_TIME = 100;</div><div class="line"></div><div class="line">    public Consumer(BlockingQueue&lt;PCData&gt; queue) &#123;</div><div class="line">        this.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;start consumer id = &quot; + Thread.currentThread().getId());</div><div class="line">        Random r = new Random();</div><div class="line"></div><div class="line">        try&#123;</div><div class="line">            while (true) &#123;</div><div class="line">                PCData data = queue.take();</div><div class="line">                if( null != data) &#123;</div><div class="line">                    int re = data.getIntData() * data.getIntData();</div><div class="line">                    System.out.println(MessageFormat.format(&quot;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&quot;,data.getIntData(), data.getIntData(),re));</div><div class="line">                &#125;</div><div class="line">                Thread.sleep(r.nextInt(SLEEP_TIME));</div><div class="line">            &#125;</div><div class="line">        &#125;catch (InterruptedException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-入口Run"><a href="#4-入口Run" class="headerlink" title="4) 入口Run"></a>4) 入口<code>Run</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        // 建立缓冲区</div><div class="line">        BlockingQueue&lt;PCData&gt; queue = new LinkedBlockingQueue&lt;&gt;(10);</div><div class="line"></div><div class="line">        // 建立生产者</div><div class="line">        Producer producer1 = new Producer(queue);</div><div class="line">        Producer producer2 = new Producer(queue);</div><div class="line">        Producer producer3 = new Producer(queue);</div><div class="line"></div><div class="line">        // 建立消费者</div><div class="line">        Consumer consumer1 = new Consumer(queue);</div><div class="line">        Consumer consumer2 = new Consumer(queue);</div><div class="line">        Consumer consumer3 = new Consumer(queue);</div><div class="line"></div><div class="line">        // 建立线程池</div><div class="line">        ExecutorService service = Executors.newCachedThreadPool();</div><div class="line"></div><div class="line">        // 运行生产者</div><div class="line">        service.execute(producer1);</div><div class="line">        service.execute(producer2);</div><div class="line">        service.execute(producer3);</div><div class="line"></div><div class="line">        // 运行消费者</div><div class="line">        service.execute(consumer1);</div><div class="line">        service.execute(consumer2);</div><div class="line">        service.execute(consumer3);</div><div class="line">        Thread.sleep(1000);</div><div class="line"></div><div class="line">        // 停止生产者</div><div class="line">        producer1.stop();</div><div class="line">        producer2.stop();</div><div class="line">        producer3.stop();</div><div class="line"></div><div class="line">        Thread.sleep(1000);</div><div class="line">        service.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5 运行结果"></a>5 运行结果</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-21/49301344.jpg" alt=""></p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><ol>
<li>Java程序性能优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;生产者-消费者模式是一个经典的多线程设计模式，它为多线程的协作提供了良好的解决方案。在生产者与消费者模式中，通常有两类线
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA之Future模式</title>
    <link href="http://jianwl.com/2017/06/20/JAVA%E4%B9%8BFuture%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/20/JAVA之Future模式/</id>
    <published>2017-06-20T13:36:05.000Z</published>
    <updated>2017-06-20T15:24:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>Future模式有点类似商品订单，比如在进行网上购物时，当看中某一件商品时，就可以提交订单。当订单处理完毕后，便可在家里等待商品送货上门。卖家根据订单从仓库里取货，并配送到客户手上。在大部分情况下，商家对订单的处理并不那么快，而在这段时间内，客户完全不必傻傻地在家里等待，可以出门处理其他事物。</p>
<h3 id="2-传统串行调用-VS-Future模式"><a href="#2-传统串行调用-VS-Future模式" class="headerlink" title="2. 传统串行调用 VS Future模式"></a>2. 传统串行调用 <code>VS</code> Future模式</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-20/29048455.jpg" alt=""></p>
<p>图1所示，客户端发出call请求，这个请求需要相当长一段时间才能返回。客户端一直等待，直到数据返回，随后，在进行其他任务的处理。</p>
<p>图2显示了一个广义Future模式的实现，从Data_Future对象可以看到，虽然call本身处理仍然需要很长一段时间来处理程序，但是服务程序不等数据处理完成便立即返回客户端一个伪造的数据，实现了Future模式的客户。</p>
<h3 id="3-Future模式的主要参与者"><a href="#3-Future模式的主要参与者" class="headerlink" title="3. Future模式的主要参与者"></a>3. Future模式的主要参与者</h3><table>
<thead>
<tr>
<th>参与者</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Main</td>
<td>系统启动，调用Client发出请求</td>
</tr>
<tr>
<td>Client</td>
<td>返回Data对象，立即返回FutureData，并开启ClientThread线程装配RealData</td>
</tr>
<tr>
<td>Data</td>
<td>返回数据接口</td>
</tr>
<tr>
<td>FutureData</td>
<td>Future数据，构造很快，但是是一个虚拟的数据，需要装配RealData</td>
</tr>
<tr>
<td>RealData</td>
<td>真实数据，其构造是比较慢的</td>
</tr>
</tbody>
</table>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-20/16429145.jpg" alt=""></p>
<h3 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h3><h4 id="1-Data接口"><a href="#1-Data接口" class="headerlink" title="1) Data接口"></a>1) Data接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Data &#123;</div><div class="line">    String getResult();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-真实数据RealData"><a href="#2-真实数据RealData" class="headerlink" title="2) 真实数据RealData"></a>2) 真实数据<code>RealData</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class RealData implements Data &#123;</div><div class="line">    protected final String result;</div><div class="line"></div><div class="line">    public RealData(String para) &#123;</div><div class="line">        StringBuffer sb = new StringBuffer();</div><div class="line">        for(int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            sb.append(para);</div><div class="line">            try&#123;</div><div class="line">                Thread.sleep(100);</div><div class="line">            &#125;catch (InterruptedException e)&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        result = sb.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String getResult() &#123;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3）FutureData"><a href="#3）FutureData" class="headerlink" title="3）FutureData"></a>3）FutureData</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class FutureData implements Data &#123;</div><div class="line">    protected RealData realData = null;</div><div class="line">    protected boolean isReady = false;</div><div class="line">    public synchronized void setRealData(RealData realData) &#123;</div><div class="line">        if (isReady) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        this.realData = realData;</div><div class="line">        isReady = true;</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public synchronized String getResult() &#123;</div><div class="line">        while (!isReady) &#123;</div><div class="line">            try &#123;</div><div class="line">                wait();</div><div class="line">            &#125;catch (InterruptedException e)&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return realData.result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-客户端Client"><a href="#4-客户端Client" class="headerlink" title="4) 客户端Client"></a>4) 客户端<code>Client</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public Data request(final String queryStr) &#123;</div><div class="line">        final FutureData future = new FutureData();</div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            RealData realData = new RealData(queryStr);</div><div class="line">            future.setRealData(realData);</div><div class="line">        &#125;).start();</div><div class="line">        return future;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-入口Run"><a href="#5-入口Run" class="headerlink" title="5) 入口Run"></a>5) 入口<code>Run</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Client client = new Client();</div><div class="line">        Data data = client.request(&quot;name&quot;);</div><div class="line">        System.out.println(&quot;请求完毕!&quot;);</div><div class="line">        try&#123;</div><div class="line">            Thread.sleep(100);</div><div class="line">        &#125;catch (InterruptedException e)&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;数据 =&gt; &quot; + data.getResult());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-运行结果"><a href="#6-运行结果" class="headerlink" title="6) 运行结果"></a>6) 运行结果</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-20/38834317.jpg" alt=""></p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><ol>
<li>Java程序性能优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;Future模式有点类似商品订单，比如在进行网上购物时，当看中某一件商品时，就可以提交订单。当订单处理完毕后，便可在家里
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA观察者模式</title>
    <link href="http://jianwl.com/2017/06/18/JAVA%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/18/JAVA观察者模式/</id>
    <published>2017-06-18T14:27:32.000Z</published>
    <updated>2017-06-18T15:00:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>观察者模式是非常常用的一种设计模式，在软件系统中，当一个对象的行为依赖另一个对象的状态时，观察者模式相当有用。若不使用观察者模式提供的通用结构，而需要实现其类似的功能，则只能在另一个线程中不停监听对象所依赖的状态。在一个复杂系统中，可能会因此开启很多线程来实现这一功能，这将使系统的性能产生额外的负担。</p>
<h3 id="2-观察者模式角色"><a href="#2-观察者模式角色" class="headerlink" title="2. 观察者模式角色"></a>2. 观察者模式角色</h3><table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>主题接口</td>
<td>指被观察的对象，当其状态发生变化或者某事件发生时，它会将这个变化通知观察者。它维护了观察者所需要依赖的状态</td>
</tr>
<tr>
<td>具体主题</td>
<td>具体主题实现了主题接口中的方法，如新增观察者、删除观察者和通知观察者。其内部维护一个观察者列表</td>
</tr>
<tr>
<td>观察者接口</td>
<td>观察者接口定义了观察者的基本方法，当依赖状态发生改变时，主题接口就会调用观察者的update()方法</td>
</tr>
<tr>
<td>具体观察者</td>
<td>实现了观察者接口的update()，具体处理当被观察者状态改变或者某一事件发生时的业务逻辑</td>
</tr>
</tbody>
</table>
<h3 id="3-观察者模式类图"><a href="#3-观察者模式类图" class="headerlink" title="3. 观察者模式类图"></a>3. 观察者模式类图</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-18/26557541.jpg" alt=""></p>
<h3 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h3><h4 id="主题接口ISubject"><a href="#主题接口ISubject" class="headerlink" title="主题接口ISubject"></a>主题接口<code>ISubject</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface ISubject &#123;</div><div class="line">    void attach(IObserver observer); // 添加观察者</div><div class="line">    void detach(IObserver observer); // 删除观察者</div><div class="line">    void inform(String msg); // 通知所有观察者</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="具体主题ConcreteSubject"><a href="#具体主题ConcreteSubject" class="headerlink" title="具体主题ConcreteSubject"></a>具体主题<code>ConcreteSubject</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class ConcreteSubject implements ISubject &#123;</div><div class="line">    Vector&lt;IObserver&gt; observers = new Vector&lt;IObserver&gt;();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void attach(IObserver observer) &#123;</div><div class="line">        observers.addElement(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void detach(IObserver observer) &#123;</div><div class="line">        observers.removeElement(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void inform(String msg) &#123;</div><div class="line">        for(IObserver ob:observers) &#123;</div><div class="line">            ob.update(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="观察者接口"><a href="#观察者接口" class="headerlink" title="观察者接口"></a>观察者接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface IObserver &#123;</div><div class="line">    void update(String msg); // 更新观察者</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="具体观察者"><a href="#具体观察者" class="headerlink" title="具体观察者"></a>具体观察者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class ConcreteObserve implements IObserver &#123;</div><div class="line">    @Override</div><div class="line">    public void update(String msg) &#123;</div><div class="line">        System.out.println(&quot;observe receive information =&gt; &quot; + JSON.toJSONString(msg));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="入口Run"><a href="#入口Run" class="headerlink" title="入口Run"></a>入口<code>Run</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ConcreteSubject subject = new ConcreteSubject();</div><div class="line">        ConcreteObserve observeA = new ConcreteObserve();</div><div class="line">        ConcreteObserve observeB = new ConcreteObserve();</div><div class="line">        subject.attach(observeA);</div><div class="line">        subject.attach(observeB);</div><div class="line">        subject.inform(&quot;notify-1&quot;);</div><div class="line">        subject.detach(observeB);</div><div class="line">        subject.inform(&quot;notify-2&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-18/64270257.jpg" alt=""></p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><ol>
<li>JAVA程序性能优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;观察者模式是非常常用的一种设计模式，在软件系统中，当一个对象的行为依赖另一个对象的状态时，观察者模式相当有用。若不使用观
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA之享元模式</title>
    <link href="http://jianwl.com/2017/06/17/JAVA%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/17/JAVA之享元模式/</id>
    <published>2017-06-17T10:05:18.000Z</published>
    <updated>2017-06-18T06:41:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>享元模式是设计模式中少数几个以提高系统性能为目的的模式之一；它的核心思想是：<strong>如果在一个系统中存在多个相同的对象，那么只需要共享一份对象的拷贝，而不必为每一次使用都创建新的对象。</strong></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>可以节省重复创建对象的开销；</li>
<li>创建对象的数量减少，对系统的内存需求也减小，使得GC的压力降低；</li>
</ol>
<h3 id="2-享元模式角色"><a href="#2-享元模式角色" class="headerlink" title="2. 享元模式角色"></a>2. 享元模式角色</h3><table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>享元工厂</td>
<td>用以创建具体享元类，维护相同的单元对象。它保证相同的享元对象可以被系统共享。即内部使用了类似单例模式的算法，当请求对象已经存在时，直接返回对象，不存在时，再创建对象</td>
</tr>
<tr>
<td>抽象享元</td>
<td>定义需共享的对象的业务接口。享元类被创建出来总是为了实现某些特定的业务逻辑，而抽象享元便定义这些逻辑的语义行为</td>
</tr>
<tr>
<td>具体享元类</td>
<td>实现抽象享元类的接口，完成某一具体的逻辑</td>
</tr>
<tr>
<td>Main</td>
<td>使用享元模式的组件，通过享元工厂取得享元对象</td>
</tr>
</tbody>
</table>
<h3 id="3-实战"><a href="#3-实战" class="headerlink" title="3. 实战"></a>3. 实战</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-18/33093517.jpg" alt=""></p>
<h4 id="可运行实例"><a href="#可运行实例" class="headerlink" title="可运行实例"></a>可运行实例</h4><h5 id="1、-抽象享元IReportManager"><a href="#1、-抽象享元IReportManager" class="headerlink" title="1、 抽象享元IReportManager"></a>1、 抽象享元<code>IReportManager</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface IReportManager &#123;</div><div class="line">     String createReport();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2、-具体享元类-EmployeeReportManager"><a href="#2、-具体享元类-EmployeeReportManager" class="headerlink" title="2、 具体享元类 EmployeeReportManager"></a>2、 具体享元类 <code>EmployeeReportManager</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class EmployeeReportManager implements IReportManager &#123;</div><div class="line">    protected String tenantId = null;</div><div class="line"></div><div class="line">    public EmployeeReportManager(String tenantId) &#123;</div><div class="line">        this.tenantId = tenantId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String createReport() &#123;</div><div class="line">        return &quot;This is a employee report&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3、-具体享元类-FinancialReportManager"><a href="#3、-具体享元类-FinancialReportManager" class="headerlink" title="3、 具体享元类 FinancialReportManager"></a>3、 具体享元类 <code>FinancialReportManager</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class FinancialReportManager implements IReportManager &#123;</div><div class="line">    protected String tenantId = null;</div><div class="line"></div><div class="line">    public FinancialReportManager(String tenantId) &#123;</div><div class="line">        this.tenantId = tenantId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String createReport() &#123;</div><div class="line">        return &quot;This is a financial report&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4、-享元工厂ReportManagerFactory"><a href="#4、-享元工厂ReportManagerFactory" class="headerlink" title="4、 享元工厂ReportManagerFactory"></a>4、 享元工厂<code>ReportManagerFactory</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ReportManagerFactory &#123;</div><div class="line">    Map&lt;String,IReportManager&gt; finanacialReportManager = new HashMap&lt;String,IReportManager&gt;();</div><div class="line">    Map&lt;String,IReportManager&gt; employeeReportManager = new HashMap&lt;String,IReportManager&gt;();</div><div class="line"></div><div class="line">    IReportManager getFinancialReportManager(String tenantId)&#123;</div><div class="line">        IReportManager r = finanacialReportManager.get(tenantId);</div><div class="line">        if (r == null) &#123;</div><div class="line">            r = new FinancialReportManager(tenantId);</div><div class="line">            finanacialReportManager.put(tenantId,r);</div><div class="line">        &#125;</div><div class="line">        return r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    IReportManager getEmployeeReportReportManger(String tenantId)&#123;</div><div class="line">        IReportManager r = employeeReportManager.get(tenantId);</div><div class="line">        if (r == null) &#123;</div><div class="line">            r = new EmployeeReportManager(tenantId);</div><div class="line">            employeeReportManager.put(tenantId,r);</div><div class="line">        &#125;</div><div class="line">        return r;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5、-入口Run"><a href="#5、-入口Run" class="headerlink" title="5、 入口Run"></a>5、 入口<code>Run</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ReportManagerFactory rmf = new ReportManagerFactory();</div><div class="line">        IReportManager rm = rmf.getFinancialReportManager(&quot;A&quot;);</div><div class="line">        System.out.println(rm.createReport());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="6-运行结果"><a href="#6-运行结果" class="headerlink" title="6. 运行结果"></a>6. 运行结果</h5><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-18/81872942.jpg" alt=""></p>
<h3 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h3><ol>
<li>JAVA程序性能优化</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;享元模式是设计模式中少数几个以提高系统性能为目的的模式之一；它的核心思想是：&lt;strong&gt;如果在一个系统中存在多个相同
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA之装饰者模式</title>
    <link href="http://jianwl.com/2017/06/09/JAVA%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://jianwl.com/2017/06/09/JAVA之装饰者模式/</id>
    <published>2017-06-09T00:31:39.000Z</published>
    <updated>2017-06-10T03:23:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>装饰者模式拥有一个设计非常精巧的结构，它可以动态添加对象功能，在基本的设计原则中，有一条重要的设计准则叫做<strong>合成/聚合复用原则。</strong>根据该原则的思想，代码复用应该尽可能使用委托，而不是使用继承。因为继承是一种紧密耦合，任何父类的改动都会影响其子类，不利于系统维护。而委托则是松散耦合，只要接口不变，委托类的改动并不会影响上层对象。</p>
<p>装饰者模式就充分运用了这种思想，通过委托机制，复用系统中的各个组件，在运行时，可以将这些功能进行叠加，从而构造一个“超级对象”，使其拥有所有这些组件的功能。而各个子模块功能，被很好地维护在各个组件的相关类中 ，拥有整洁的系统结构。</p>
<h3 id="2-装饰者模式基本结构"><a href="#2-装饰者模式基本结构" class="headerlink" title="2. 装饰者模式基本结构"></a>2. 装饰者模式基本结构</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-9/53287711.jpg" alt=""></p>
<p>装饰者(Decorator) 和被装饰者(ConcreteComponent)拥有相同的接口Component，被装饰者通常是系统的核心组件，完成特定的功能目标。而装饰者则可以在被装饰者的方法前后，加上特定的前置处理和后置处理，增强被装饰者的功能。</p>
<p>装饰者模式角色</p>
<table>
<thead>
<tr>
<th style="text-align:left">角色</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">组件接口</td>
<td style="text-align:center">组件接口是装饰者和被装饰者的超类或接口，它定义了被装饰者的核心功能和装饰者需要加强的功能点。</td>
</tr>
<tr>
<td style="text-align:left">具体组件</td>
<td style="text-align:center">具体组件实现了组件接口的核心方法，完成某一个具体的业务逻辑，它也是被装饰的对象</td>
</tr>
<tr>
<td style="text-align:left">装饰者</td>
<td style="text-align:center">实现组件接口，并持有一个具体的被装饰对象</td>
</tr>
<tr>
<td style="text-align:left">具体装饰者</td>
<td style="text-align:center">具体实现装饰的业务逻辑，即实现了被分离的各个增强功能点，各个具体装饰者是可以相互叠加的，从而可以构成一个功能更强大的组件对象</td>
</tr>
</tbody>
</table>
<h3 id="3-实战"><a href="#3-实战" class="headerlink" title="3. 实战"></a>3. 实战</h3><h4 id="1）场景描述"><a href="#1）场景描述" class="headerlink" title="1）场景描述"></a>1）场景描述</h4><p>将某一结果通过HTML进行发布，那么首先就需要将内容转化为一个HTML文本，同时由于内容要在网络上通过HTTP流传，故还需要为其增加HTTP头。</p>
<h4 id="2）类图"><a href="#2）类图" class="headerlink" title="2）类图"></a>2）类图</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-10/63142422.jpg" alt=""></p>
<h4 id="3-可运行实例"><a href="#3-可运行实例" class="headerlink" title="3) 可运行实例"></a>3) 可运行实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">// Component</div><div class="line">public interface IPacketCreator &#123;</div><div class="line">    String handleContent();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Concrete Component</div><div class="line">public class PacketBodyCreator implements IPacketCreator &#123;</div><div class="line">    @Override</div><div class="line">    public String handleContent() &#123;</div><div class="line">        return &quot;Content of Packet&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Decorator</div><div class="line">public abstract class PacketDecorator implements IPacketCreator &#123;</div><div class="line">    IPacketCreator component;</div><div class="line"></div><div class="line">    public PacketDecorator(IPacketCreator component) &#123;</div><div class="line">        this.component = component;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Concrete Decorator</div><div class="line">public class PacketHTTPHeaderCreator extends PacketDecorator &#123;</div><div class="line">    public PacketHTTPHeaderCreator(IPacketCreator component) &#123;</div><div class="line">        super(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String handleContent() &#123;</div><div class="line">        StringBuffer sb = new StringBuffer();</div><div class="line">        sb.append(&quot;Cache-Control:no-cache\n&quot;);</div><div class="line">        sb.append(&quot;Date:2017-06-10\n&quot;);</div><div class="line">        sb.append(component.handleContent());</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Concrete Decorator</div><div class="line">public class PacketHTMLHeaderCreator extends PacketDecorator &#123;</div><div class="line"></div><div class="line">    public PacketHTMLHeaderCreator(IPacketCreator component) &#123;</div><div class="line">        super(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String handleContent() &#123;</div><div class="line">        StringBuffer sb = new StringBuffer();</div><div class="line">        sb.append(&quot;&lt;html&gt;&quot;);</div><div class="line">        sb.append(&quot;&lt;body&gt;&quot;);</div><div class="line">        sb.append(component.handleContent());</div><div class="line">        sb.append(&quot;&lt;/body&gt;&quot;);</div><div class="line">        sb.append(&quot;&lt;/html&gt;\n&quot;);</div><div class="line">        return sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 运行</div><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        IPacketCreator pc = new PacketHTTPHeaderCreator(new PacketHTMLHeaderCreator(new PacketBodyCreator()));</div><div class="line">        System.out.println(pc.handleContent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-10/21550495.jpg" alt=""></p>
<h3 id="4-JDK中用装饰者的实例"><a href="#4-JDK中用装饰者的实例" class="headerlink" title="4. JDK中用装饰者的实例"></a>4. JDK中用装饰者的实例</h3><h4 id="1-描述"><a href="#1-描述" class="headerlink" title="1) 描述"></a>1) 描述</h4><p>OutStream为核心的装饰者模式的实现，其中FileOutputStream为系统的核心类，它实现了向文件写入数据。使用DataOutputStream可以在FileOutputStream的基础上，增加对多种数据类型的写操作，而BufferedOutputStream秀使其，可以对FileOutputStream增加缓冲功能，优化I/O的性能，以BufferedOutputStream为代表的性能组件，是将性能模块和功能模块分离的一种典型实现。</p>
<h4 id="2-类图"><a href="#2-类图" class="headerlink" title="2) 类图"></a>2) 类图</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-10/56315217.jpg" alt=""></p>
<h4 id="3）可运行实例"><a href="#3）可运行实例" class="headerlink" title="3）可运行实例"></a>3）可运行实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public class OutputStreamTest &#123;</div><div class="line">    public static void notBufferOut()&#123;</div><div class="line">        long start = System.currentTimeMillis();</div><div class="line">        try &#123;</div><div class="line">            DataOutputStream dout = new DataOutputStream(new FileOutputStream(&quot;/Users/jianweilin/Desktop/output1.txt&quot;));</div><div class="line">            for (int i=0; i&lt; 1000; i++) &#123;</div><div class="line">                dout.writeInt(i);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;notBufferOut spend =&gt; &quot; + (System.currentTimeMillis() - start));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void bufferOut()&#123;</div><div class="line">        long start = System.currentTimeMillis();</div><div class="line">        try &#123;</div><div class="line">            DataOutputStream dout = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(&quot;/Users/jianweilin/Desktop/output2.txt&quot;)));</div><div class="line">            for (int i=0; i&lt; 1000; i++) &#123;</div><div class="line">                dout.writeInt(i);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (FileNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;bufferOut spend =&gt; &quot; + (System.currentTimeMillis() - start));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        notBufferOut();</div><div class="line">        bufferOut();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结果</div><div class="line">// notBufferOut spend =&gt; 11</div><div class="line">// bufferOut spend =&gt; 1</div></pre></td></tr></table></figure>
<h4 id="4-工作流程图"><a href="#4-工作流程图" class="headerlink" title="4) 工作流程图"></a>4) 工作流程图</h4><p><code>FileOutputStream.write()</code>的调用之前，会首先调用<code>BufferedOutputStream.write()</code>。且<code>BufferedOutputStream.write()</code>不会每次都去磁盘写数据，而是将数据写入缓存，当缓存满时，才会调用<code>FileOutputStream.write()</code>方法，实际写入数据。以此实现性能组件与功能组件的分离。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-10/51627202.jpg" alt=""></p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><ol>
<li>Java程序性能优化 by 葛一鸣</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;装饰者模式拥有一个设计非常精巧的结构，它可以动态添加对象功能，在基本的设计原则中，有一条重要的设计准则叫做&lt;strong
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>单例模式之性能比较</title>
    <link href="http://jianwl.com/2017/06/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"/>
    <id>http://jianwl.com/2017/06/08/单例模式之性能比较/</id>
    <published>2017-06-08T14:00:55.000Z</published>
    <updated>2017-06-08T14:48:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>设计模式是前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是对某一特定问题的成熟解决方案。如果能合理地使用设计模式，不仅能使系统更容易被他人理解，同时也能使系统拥有更加合理的结构。本节将对单例模式多种实现进行性能分析。</p>
<h3 id="2-单例模式的好处"><a href="#2-单例模式的好处" class="headerlink" title="2. 单例模式的好处"></a>2. 单例模式的好处</h3><ol>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于new操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间。</li>
</ol>
<h3 id="3-多种实现方式"><a href="#3-多种实现方式" class="headerlink" title="3. 多种实现方式"></a>3. 多种实现方式</h3><h4 id="1-简单的单例实现"><a href="#1-简单的单例实现" class="headerlink" title="1) 简单的单例实现"></a>1) 简单的单例实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton instance = new Singleton();</div><div class="line"></div><div class="line">    private Singleton() &#123;</div><div class="line">        System.out.println(&quot;Singleton is create&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Singleton getInstance()&#123;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void createString()&#123;</div><div class="line">        System.out.println(&quot;createString in Singleton&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Singleton.createString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缺点是无法对instance实例延迟加载，在任何地方使用这个单例类都会初始化这个单例变量，就如例子中的一样，仅仅只调用<code>createString</code>方法，也会初始化单例变量；</p>
<h4 id="2-延迟加载"><a href="#2-延迟加载" class="headerlink" title="2) 延迟加载"></a>2) 延迟加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class LazySingleton &#123;</div><div class="line">    private static LazySingleton instance = null;</div><div class="line"></div><div class="line">    private LazySingleton()&#123;</div><div class="line">        System.out.println(&quot;LazySingleton is create&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static synchronized LazySingleton getInstance()&#123;</div><div class="line">        if (instance == null) &#123;</div><div class="line">            instance = new LazySingleton();</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void createString()&#123;</div><div class="line">        System.out.println(&quot;createString in Singleton&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        LazySingleton.createString()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 结果</div><div class="line">// createString in Singleton</div></pre></td></tr></table></figure>
<p>为了解决例1中的问题，引入延迟加载机制，但这种延迟加载有一致命的缺点，因为引入了同步关键字，在多线程环境时耗远远大于第一种单例模式。</p>
<h4 id="3-改进"><a href="#3-改进" class="headerlink" title="3) 改进"></a>3) 改进</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class StaticSingleton &#123;</div><div class="line">    private StaticSingleton()&#123;</div><div class="line">        System.out.println(&quot;StaticSingleton is create&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class SingletonHolder &#123;</div><div class="line">        private static StaticSingleton instance = new StaticSingleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static StaticSingleton getInstance()&#123;</div><div class="line">        return SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例2为了使用延迟加载引入同步关键字降低了性能，为了解决这个问题，引入例3。当StaticSingleton被加载时，内部类不会被初始化。</p>
<h4 id="4-三种模式性能比较"><a href="#4-三种模式性能比较" class="headerlink" title="4) 三种模式性能比较"></a>4) 三种模式性能比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">// 实现1</div><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton instance = new Singleton();</div><div class="line"></div><div class="line">    public static Singleton getInstance()&#123;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实现2</div><div class="line">public class LazySingleton &#123;</div><div class="line">    private static LazySingleton instance = null;</div><div class="line"></div><div class="line">    public static synchronized LazySingleton getInstance()&#123;</div><div class="line">        if (instance == null) &#123;</div><div class="line">            instance = new LazySingleton();</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实现3</div><div class="line">public class StaticSingleton &#123;</div><div class="line">    private static class SingletonHolder &#123;</div><div class="line">        private static StaticSingleton instance = new StaticSingleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static StaticSingleton getInstance()&#123;</div><div class="line">        return SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 主类</div><div class="line">public class Run &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            long startTime = System.currentTimeMillis();</div><div class="line">            for (int j = 0; j &lt; 100000000; j++) &#123;</div><div class="line">                Singleton.getInstance();</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;Singleton spend =&gt; &quot; + (System.currentTimeMillis() - startTime));</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            long startTime = System.currentTimeMillis();</div><div class="line">            for (int j = 0; j &lt; 100000000; j++) &#123;</div><div class="line">                LazySingleton.getInstance();</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;LazySingleton spend =&gt; &quot; + (System.currentTimeMillis() - startTime));</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">        new Thread(() -&gt; &#123;</div><div class="line">            long startTime = System.currentTimeMillis();</div><div class="line">            for (int j = 0; j &lt; 100000000; j++) &#123;</div><div class="line">                StaticSingleton.getInstance();</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;StaticSingleton spend =&gt; &quot; + (System.currentTimeMillis() - startTime));</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 结果</div><div class="line">// Singleton spend =&gt; 8</div><div class="line">// StaticSingleton spend =&gt; 10</div><div class="line">// LazySingleton spend =&gt; 3268</div></pre></td></tr></table></figure>
<h3 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h3><ol>
<li>Java程序性能优化 by 葛一鸣</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h3&gt;&lt;p&gt;设计模式是前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是对某一特定问题的成熟解决方案。如果能合理地使用设计模式
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Java之异常</title>
    <link href="http://jianwl.com/2017/06/04/Java%E4%B9%8B%E5%BC%82%E5%B8%B8-0/"/>
    <id>http://jianwl.com/2017/06/04/Java之异常-0/</id>
    <published>2017-06-04T04:26:45.000Z</published>
    <updated>2017-06-04T05:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-4/26082118.jpg" alt=""></p>
<p>在Java程序运行时，常常会出现一些非正常现象，根据其性质分为<strong>错误和异常。</strong> Java程序中，所有抛出的异常都必须从<code>Throwable</code>派生而来。Throwable有两个直接子类：Error和Exception。</p>
<p>Error</p>
<p>常见的错误有程序进入死循环、内存泄露等</p>
<p>Exception</p>
<p>异常分为受检异常 &amp; 非受检异常。受检异常是去除RuntimeExeption的其他直接继承Exception的子类；非受检异常是直接继承RunTimeException的子类；</p>
<p>对于受检异常，必须要用<code>try catch</code>去处理这个异常，或者在方法加上<code>throws</code>暗示这个方法可能会抛出某种异常。</p>
<p>非受检异常，不需要明确地去处理这个异常；</p>
<h3 id="2-受检异常-amp-非受检异常实战"><a href="#2-受检异常-amp-非受检异常实战" class="headerlink" title="2. 受检异常 &amp; 非受检异常实战"></a>2. 受检异常 &amp; 非受检异常实战</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-6-4/31638990.jpg" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://stackoverflow.com/questions/2190161/difference-between-java-lang-runtimeexception-and-java-lang-exception" target="_blank" rel="external">difference between java.lang.RuntimeException and java.lang.Exception</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. 基本概念&quot;&gt;&lt;/a&gt;1. 基本概念&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://oc5a5l0a0.bkt.clouddn.com/17-6-4/26
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Java之ClassLoader</title>
    <link href="http://jianwl.com/2017/06/03/Java%E4%B9%8BClassLoader/"/>
    <id>http://jianwl.com/2017/06/03/Java之ClassLoader/</id>
    <published>2017-06-03T01:44:51.000Z</published>
    <updated>2017-06-04T05:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ClassLoader基本概念"><a href="#1-ClassLoader基本概念" class="headerlink" title="1. ClassLoader基本概念"></a>1. ClassLoader基本概念</h3><p>Java程序是由许多独立的类文件组成的，每一个文件对应一个Java类。此外，<strong>这些类文件并非全部装入内存，而是根据程序需要逐渐载入。</strong> </p>
<p>ClassLoader是JVM实现的一部分，ClassLoader 包括 bootstrap classloader(启动类加载器), ClassLoader在JVM运行的时候加载Java核心的API，以满足Java程序最基本的需求，其中就包括用户定义的ClassLoader: <strong>一个是ExtClassLoader，它的作用是用来加载Java的扩展API，也就是/lib/ext中的类；第二个是AppClassLoader,它是用来加载用户机器上CLASSPATH设置目录中的Class的，通常在没有指定ClassLoader的情况下，自定义的类就由该ClassLoader进行加载。</strong></p>
<h3 id="2-ClassLoader加载流程"><a href="#2-ClassLoader加载流程" class="headerlink" title="2. ClassLoader加载流程"></a>2. ClassLoader加载流程</h3><p>当运行一个程序的时候，JVM启动，运行bootstrap classloader，该ClassLoader加载Java核心API(ExtClassLoader和AppClassLoader也在此时被加载)，然后调用ExtClassLoader加载扩展API，最后AppClassLoader加载CLASSPATH目录下定义的Class，这就是一个程序最基本的加载流程。</p>
<p>核心代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</div><div class="line">    throws ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    synchronized (getClassLoadingLock(name)) &#123;</div><div class="line">        // 首先检查该name指定的class是否被加载</div><div class="line">        Class&lt;?&gt; c = findLoadedClass(name);</div><div class="line">        if (c == null) &#123;</div><div class="line">            long t0 = System.nanoTime();</div><div class="line">            try &#123;</div><div class="line">                if (parent != null) &#123;</div><div class="line">                // 如果parent不为null，则调用parent的loadclass进行加载</div><div class="line">                    c = parent.loadClass(name, false);</div><div class="line">                &#125; else &#123;</div><div class="line">                // parent为null，则调用BootstrapClassLoader进行加载</div><div class="line">                    c = findBootstrapClassOrNull(name);</div><div class="line">                &#125;</div><div class="line">            &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (c == null) &#123;</div><div class="line">                long t1 = System.nanoTime();</div><div class="line">                // 如果仍然无法加载成功，则调用自身的findClass进行加载；</div><div class="line">                c = findClass(name);</div><div class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class="line">                sun.misc.PerfCounter.getFindClasses().increment();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (resolve) &#123;</div><div class="line">            resolveClass(c);</div><div class="line">        &#125;</div><div class="line">        return c;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述代码中可以看出，<strong>一个类加载的过程使用了一种父类委托模式。</strong>为什么要使用这种模式？</p>
<ol>
<li>可以避免重复加载，当父类已经加载了该类的时候，就没有必要子ClassLoader再加载一次。</li>
<li>考虑到安全因素，如果不使用这种委托模式，那么可以随时使用自定义的String来动态替换Java核心API中定义的类型，这样会存在非常大的安全隐患，而父类委托的方式可以避免这种情况，因为String已经在启动时被加载，所以，用户自定义类无法加载一个自定义的ClassLoader</li>
</ol>
<h3 id="3-JVM加载类的流程"><a href="#3-JVM加载类的流程" class="headerlink" title="3. JVM加载类的流程"></a>3. JVM加载类的流程</h3><p>JVM加载类的时候，需要经过三个步骤：装载、连接、初始化。装载就是找到相应的class文件，读入JVM；初始化就是class文件初始化，这里详述一下连接，连接分为三步：</p>
<ol>
<li>验证class是否符合规范</li>
<li>准备，为类变量分配内存的同时设置默认初始值</li>
<li>解释，这步可选，根据loadClass中的是否需要解析的参数。解释指: 根据类中的符号引用查找相应的实体，再把符号引用替换成一个直接引用的过程。</li>
</ol>
<h3 id="4-一些重要的方法"><a href="#4-一些重要的方法" class="headerlink" title="4. 一些重要的方法"></a>4. 一些重要的方法</h3><h4 id="1-loadClass"><a href="#1-loadClass" class="headerlink" title="1) loadClass"></a>1) loadClass</h4><p>ClassLoader.loadClass()ClassLoader的入口点，定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class loadClass( String name, boolean resolve );</div></pre></td></tr></table></figure>
<p>name是JVM需要的类名称，如java.lang.Object。resolve参数告诉方法是否需要解析类。如果JVM只需要知道该类是否存在或找出该类的超类，那么就不需要解析；</p>
<h4 id="2-defineClass"><a href="#2-defineClass" class="headerlink" title="2) defineClass"></a>2) defineClass</h4><p>defineClass方法接受由原始字节组成的数组，并把它转换成Class对象。</p>
<h4 id="3-findSystemClass"><a href="#3-findSystemClass" class="headerlink" title="3) findSystemClass"></a>3) findSystemClass</h4><p>findSystemClass方法从本地文件系统装入文件。</p>
<h4 id="4）resolveClass"><a href="#4）resolveClass" class="headerlink" title="4）resolveClass"></a>4）resolveClass</h4><p>当我们编写自己的loadClass时，可以调用 resolveClass,这取决于 loadClass的resolve参数的值。</p>
<h4 id="5-findLoadedClass"><a href="#5-findLoadedClass" class="headerlink" title="5) findLoadedClass"></a>5) findLoadedClass</h4><p>findLoadedClass充当一个缓存，当请求loadClass装入类时，它调用该方法来查看ClassLoader是否已装入这个类，这样可以避免重新装入已存在类所造成的麻烦。</p>
<h4 id="6-findClass"><a href="#6-findClass" class="headerlink" title="6) findClass"></a>6) findClass</h4><p>findClass可以从本地文件系统使用实现的类装载器装载一个类。</p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h3><ol>
<li>Java面试宝典 by 欧立奇 朱梅等</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-ClassLoader基本概念&quot;&gt;&lt;a href=&quot;#1-ClassLoader基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. ClassLoader基本概念&quot;&gt;&lt;/a&gt;1. ClassLoader基本概念&lt;/h3&gt;&lt;p&gt;Java程序是由
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>数据库读写分离&amp;水分拆分&amp;垂直拆分</title>
    <link href="http://jianwl.com/2017/05/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB-%E6%B0%B4%E5%88%86%E6%8B%86%E5%88%86-%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86/"/>
    <id>http://jianwl.com/2017/05/21/数据库读写分离-水分拆分-垂直拆分/</id>
    <published>2017-05-21T07:14:15.000Z</published>
    <updated>2017-05-21T09:28:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数据库读写分离"><a href="#1-数据库读写分离" class="headerlink" title="1. 数据库读写分离"></a>1. 数据库读写分离</h3><p>随着业务的发展，我们的数据量和访问量都在增长，对于大型网站来说，有不少业务是读多写少的，这个状况也会直接反应到数据库上，那么对于这样的情况，我们可以考虑使用读写分离的方式。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/96626968-file_1495352158645_1675c.png" alt=""></p>
<p>通过读库来分担主库上读的压力，数据库提供了数据复制的功能，我们可以直接使用数据库系统自身的功能，但对于数据复制，我们还需要考虑数据复制时延问题，以及复制过程中数据的源和目标之间的映射关系及过滤条件的支持问题。<strong>数据复制延迟带来的就是短期的数据不一致。</strong>例如我们修改了用户信息，在这个信息还没有复制到读库时(因为延时)，我们从读库上读出来的信息就不是最新的，如果把这个信息给进行修改的人看，就会让他觉得没有修改成功。</p>
<h3 id="2-专库专用，数据库垂直拆分"><a href="#2-专库专用，数据库垂直拆分" class="headerlink" title="2. 专库专用，数据库垂直拆分"></a>2. 专库专用，数据库垂直拆分</h3><p>读写分离能够降低主库的压力，解决读的问题，但却无法解决主库写的问题。随着业务的发展，我们的主库也会遇到瓶颈，因此需要解决这个问题，有数据垂直拆分和水平拆分两种选择。</p>
<p>垂直拆分的意思是把数据库中不同的业务数据拆分到不同的数据库中。结合现在的例子，就是把交易、商品、用户的数据分开。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/73834200-file_1495353291315_4f78.png" alt=""></p>
<h4 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h4><p>这样的变化给我们带来的影响是什么呢？应用需要配置多个数据源，这就增加了所需的配置，不过带来的是每个数据库连接池的隔离。不同业务的数据，从原来一个数据库拆分到了多个数据库中，那么就需要<strong>考虑如何处理原来单机中跨业务的事务</strong>。一种办法是使用分布式事务，其性能要明显低于之前的单机事务；而另一种办法就是去掉事务或者不去追求强事务支持，则原来在单裤中可以使用的表关联的查询也就需要改变实现了。</p>
<p>对数据垂直拆分之后，解决了把所有业务数据放在一个数据库中的压力问题。并且也可以根据不同业务的特定进行更多优化。</p>
<h3 id="3-垂直拆分后的单机遇到瓶颈，数据库水平拆分"><a href="#3-垂直拆分后的单机遇到瓶颈，数据库水平拆分" class="headerlink" title="3. 垂直拆分后的单机遇到瓶颈，数据库水平拆分"></a>3. 垂直拆分后的单机遇到瓶颈，数据库水平拆分</h3><p>数据库水平拆分就是把同一个表的数据拆分到两个数据库中。产生数据水平拆分的原因是某个业务的数据表的数据量或者更新量达到了单个数据库的瓶颈，这时就可以把这个表拆分到两个或者多个数据库中。</p>
<p><strong>数据水平拆分</strong>与<strong>读写分离</strong>的区别是，读写分离解决的是读压力大的问题，对于数据库量大或者更新量的情况并不起作用。</p>
<p><strong>数据水平拆分与数据垂直拆分</strong>的区别是，垂直拆分是把不同的表拆分到不同的数据库中，而水平拆分是把一个表拆到不同的数据库中。</p>
<p>例如，经过垂直拆分后，用户表与交易表、商品表不在一个数据库中了，如果数据量或者更新量太大，我们可以进一步把用户表拆分到两个数据库中，他们拥有结构一模一样的用户表，而且每个库中的用户表都只涵盖了一部分的用户，两个数据库的用户合在一起就相当于没有拆分之前的用户表。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/29829023-file_1495358662307_17eca.png" alt=""></p>
<h4 id="水平拆分给业务应用带来的影响"><a href="#水平拆分给业务应用带来的影响" class="headerlink" title="水平拆分给业务应用带来的影响"></a>水平拆分给业务应用带来的影响</h4><ol>
<li>访问用户信息的应用系统应该解决SQL路由的问题，因为现在用户信息分在两个数据库中，需要在进行数据库操作时了解需要操作的数据在哪里。</li>
<li>主键的处理也会变得不同。原来依赖单个数据库的一些机制需要变化。例如原来使用MYSQL表上的自增字段，现在不能简单地继续使用了，并且在不同的数据库中也不能直接使用一些数据库的限制来保证主键不重复。</li>
<li>由于同一个业务的数据被拆分到了不同的数据库中，因此一些查询需要从两个数据库中取数据，如果数据量太大而需要分页，就比较难处理了。</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>大型网站与Java中间件实践 by 曾宪杰</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-数据库读写分离&quot;&gt;&lt;a href=&quot;#1-数据库读写分离&quot; class=&quot;headerlink&quot; title=&quot;1. 数据库读写分离&quot;&gt;&lt;/a&gt;1. 数据库读写分离&lt;/h3&gt;&lt;p&gt;随着业务的发展，我们的数据量和访问量都在增长，对于大型网站来说，有不少业务是读多
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>应用服务器变为集群后的Session问题</title>
    <link href="http://jianwl.com/2017/05/21/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%98%E4%B8%BA%E9%9B%86%E7%BE%A4%E5%90%8E%E7%9A%84Session%E9%97%AE%E9%A2%98/"/>
    <id>http://jianwl.com/2017/05/21/应用服务器变为集群后的Session问题/</id>
    <published>2017-05-21T04:17:24.000Z</published>
    <updated>2017-05-21T07:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h3><p>用户使用网站的服务，基本上需要浏览器与Web服务器的多次交互，HTTP协议本身是无状态的，需要基于HTTP协议支持会话状态(Session State)机制。而这样的机制应该可以使Web服务器从多次单独的HTTP请求中看到”会话”，也就是知道哪些请求是来自哪个会话。具体实现方式为：在会话开始时，分配一个唯一的会话标识(SessionId),通过Cookie把这个标识告诉浏览器，以后每次请求的时候，浏览器都会带上这个会话标识来告诉Web服务器请求是属于哪个会话的。在Web服务器上，各个会话有独立的存储，保存不同会话的信息。如果遇到禁用Cookie的情况，一般的做法就是把这个会话标识放到URL的参数中。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/73320721-file_1495340830067_51c1.png" alt=""></p>
<p>当我们的应用服务器从一台变成两台后，我们会遇到Session的问题，具体是指什么问题？</p>
<p>当一个带有会话标识的HTTP请求到了Web服务器后，需要在HTTP请求的处理过程中找到对应的会话数据(Session)。而问题就在于，会话数据是需要保存在单机上的。如果我第一次访问网站时请求到了A服务器，那么我的Session就创建在A服务器上，如果我们不做处理，就不能保证接下来的请求每次都落在A服务器上了，这就是Session问题。以下提供几种解决方案。</p>
<h3 id="1-Session-Sticky"><a href="#1-Session-Sticky" class="headerlink" title="1. Session Sticky"></a>1. Session Sticky</h3><p>在单机的情况下，会话保存在单机上，请求也都是由这个机器处理，所以不会有问题。Web服务器变成多台后，如果保证同一个会话的请求都在同一个Web服务器上处理，那么对这个会话的个体来说，与之前的单机情况是一样的。</p>
<p>如果要做到这样，就需要负责均衡器能够根据每次请求的会话标识来进行请求转发，如图所示：</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/57581734-file_1495341619642_c22b.png" alt=""></p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>如果有一台Web服务器宕机或者重启，那么这台机器上的会话数据会丢失。<strong>如会话中有登录状态的数据，那么用户就要重新登录了。</strong></li>
<li>会话标识是应用层的信息，那么负载均衡要将同一个会话的请求保存到一个Web服务器上的话，就需要进行应用层(第7层)的解析，这个开销比传输层(第四层)的交换要大。</li>
<li>负载均衡器变为一个有状态的节点，要将会话保存到Web服务器的映射。和无状态的节点相比，内存消耗会更大，容灾方面会更麻烦。</li>
</ol>
<p>这种方式我们成为Session Sticky。打个比方来说，如果说Web服务器是我们每次吃饭的饭店，会话数据就是我们吃饭用的碗筷。要保证每次吃饭都用自己的碗筷的话，我就餐具存在某一家，并且每次都去这家店吃，是个不错的主要。</p>
<h3 id="2-Session-Replication"><a href="#2-Session-Replication" class="headerlink" title="2. Session Replication"></a>2. Session Replication</h3><p>在Session Replication 方式中，不再要求负载均衡器来保存同一个会话的多次请求必须到同一个Web浏览器上了。而我们的Web服务器之间则增加了会话数据的同步。通过同步就保证了不同Web服务器之间的Session数据的一致。就如同每家饭店都有我的碗筷，我就能随便选择去哪家吃饭了。</p>
<p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/38549929-file_1495343662631_181a9.png" alt=""></p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>同步Session数据造成了网络带宽的开销，只要Session数据有变化，就需要将数据同步到所有其他机器上，机器数越多，同步带来的网络带宽开销就越大。</li>
<li>每台Web服务器都需要保存所有的Session数据，如果整个集群的Session数很多(很多人在同时访问网站)的话，每台机器用于保存Session数据的内容占用会很严重。</li>
</ol>
<p>这个方案<strong>不适合集群机器数很多</strong>的场景，如果只有几台机器，用这个方案是可以的。</p>
<h3 id="3-Session数据集中存储"><a href="#3-Session数据集中存储" class="headerlink" title="3. Session数据集中存储"></a>3. Session数据集中存储</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/2688929-file_1495344473634_f8d1.png" alt=""></p>
<p>不论哪台Web服务器，也不论修改的是哪个Session数据，最终的修改都发生在这个集中存储的地方，而Web服务器使用Session时，也是从这个集中存储Sesson数据的地方读取。这样的方式保证了不同服务器上读到的Session数据都是一样的，而存储Session数据的具体方式，可以使用数据库，也可以使用其他分布式存储系统。这个方案解决了Session Replication方案中内存的问题，而对于网络带宽，这个方案也比Session Replication更好。</p>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>读写Session数据引入了网络操作，这相对于本机的数据读取来说，问题就在于存在时延和不稳定性，不过我们的通信基本都是发生在内网，问题不大。</li>
<li>如果集中存储Session机制或者集群出现问题，会影响应用。</li>
</ol>
<p>当Web服务器数据量比较大，Session数比较多的时候，这个集中存储方案的优势非常明显。</p>
<h3 id="4-Cookie-Based"><a href="#4-Cookie-Based" class="headerlink" title="4. Cookie Based"></a>4. Cookie Based</h3><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/66593639-file_1495345259153_114b5.png" alt=""></p>
<p>相对于前面的方案，这个方案不会依赖外部的一个存储系统，也不存在从外部系统获取，写入Session数据的网络时延，不稳定性了。但这个方案依然有不足。</p>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>Cookie长度的限制，我们知道Cookie是有长度限制的，而这也会限制Session数据的长度。</li>
<li>安全性。Session数据本来都是服务器数据，而这个方案是让这些服务器数据到了外部网络及客户端，因此存在<strong>安全性上</strong>的问题。我们可以对写入Cookie的Session数据做加密，不过对于安全来说，物理上不能接触才是安全的。</li>
<li>带宽消耗，这里指的不是内部Web服务器之间的带宽消耗，而是我们数据中心的整体外部带宽的消耗。</li>
<li>性能影响，每次HTTP请求和响应都带有Session数据，对Web服务器来说，在同样的处理情况下，响应的结果输出越少，支持的并发请求就会越多。</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>大型网站系统与Java中间件实践 by 曾宪杰</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是session&quot;&gt;&lt;a href=&quot;#什么是session&quot; class=&quot;headerlink&quot; title=&quot;什么是session&quot;&gt;&lt;/a&gt;什么是session&lt;/h3&gt;&lt;p&gt;用户使用网站的服务，基本上需要浏览器与Web服务器的多次交互，HTTP协议本
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统的基础知识</title>
    <link href="http://jianwl.com/2017/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://jianwl.com/2017/05/21/分布式系统的基础知识/</id>
    <published>2017-05-21T01:21:40.000Z</published>
    <updated>2017-05-21T02:22:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-用户访问网站"><a href="#1-用户访问网站" class="headerlink" title="1. 用户访问网站"></a>1. 用户访问网站</h3><h4 id="1）-用户访问单台服务器的场景"><a href="#1）-用户访问单台服务器的场景" class="headerlink" title="1） 用户访问单台服务器的场景"></a>1） 用户访问单台服务器的场景</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/35909323-file_1495331531540_101c3.png" alt=""></p>
<p>随着压力增大，我们需要变为多台服务器，例如从一台变为两台。两台服务器一起完成工作，这里面就有一个问题，用户应该去访问哪个服务器呢？</p>
<h4 id="2）用户访问集群服务器的场景-一"><a href="#2）用户访问集群服务器的场景-一" class="headerlink" title="2）用户访问集群服务器的场景(一)"></a>2）用户访问集群服务器的场景(一)</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/34398153-file_1495331435274_126a5.png" alt=""></p>
<p>通过DNS服务器进行调度和控制，在用户解析DNS的时候，就会被给予一个服务器的地址，中间没有代理设备，用户能直接知道提供服务的服务器地址。</p>
<h4 id="3）用户访问集群服务器的场景-二"><a href="#3）用户访问集群服务器的场景-二" class="headerlink" title="3）用户访问集群服务器的场景(二)"></a>3）用户访问集群服务器的场景(二)</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/54140669-file_1495331354090_1306.png" alt=""></p>
<p>在用户和网站服务器中间增加了负载均衡设备（纯硬件或者LVS等软件都可以）。DNS返回的永远是负载均衡的地址，而用户的访问都是通过负载均衡达到后面的网站服务器的。</p>
<h3 id="2-日志的处理"><a href="#2-日志的处理" class="headerlink" title="2. 日志的处理"></a>2. 日志的处理</h3><h4 id="1）单日志处理器"><a href="#1）单日志处理器" class="headerlink" title="1）单日志处理器"></a>1）单日志处理器</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/11945650-file_1495332619288_15a0c.png" alt=""></p>
<p>用一台日志处理器从3台服务器上收集日志并处理，随着应用服务器的增多，单台日志处理服务器一定会遇到问题，那么，我们可以通过增加日志处理服务器的数量来提升处理日志的能力。</p>
<h4 id="2-使用Master控制日志处理服务器集群"><a href="#2-使用Master控制日志处理服务器集群" class="headerlink" title="2) 使用Master控制日志处理服务器集群"></a>2) 使用Master控制日志处理服务器集群</h4><p><img src="http://oc5a5l0a0.bkt.clouddn.com/17-5-21/641019-file_1495333108869_a18.png" alt=""></p>
<p>使用Master + Worker方式的控制器来处理日志</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>大型网站系统与Java中间件实践 by 曾宪杰</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-用户访问网站&quot;&gt;&lt;a href=&quot;#1-用户访问网站&quot; class=&quot;headerlink&quot; title=&quot;1. 用户访问网站&quot;&gt;&lt;/a&gt;1. 用户访问网站&lt;/h3&gt;&lt;h4 id=&quot;1）-用户访问单台服务器的场景&quot;&gt;&lt;a href=&quot;#1）-用户访问单台服务器
    
    </summary>
    
      <category term="JAVA" scheme="http://jianwl.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://jianwl.com/tags/JAVA/"/>
    
  </entry>
  
</feed>
